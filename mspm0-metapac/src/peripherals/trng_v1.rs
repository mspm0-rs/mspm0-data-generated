// This file is autogenerated by mspm0-metapac-gen: do not edit by hand.
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::identity_op)]
#![allow(clippy::unnecessary_cast)]
#![allow(clippy::erasing_op)]

#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Gprcm {
    ptr: *mut u8,
}
unsafe impl Send for Gprcm {}
unsafe impl Sync for Gprcm {}
impl Gprcm {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Power enable."]
    #[inline(always)]
    pub const fn pwren(self) -> crate::common::Reg<regs::Pwren, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "Reset Control."]
    #[inline(always)]
    pub const fn rstctl(self) -> crate::common::Reg<regs::Rstctl, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
    }
    #[doc = "Status Register."]
    #[inline(always)]
    pub const fn stat(self) -> crate::common::Reg<regs::GprcmStat, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
    }
}
#[doc = "PERIPHERALREGION."]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Trng {
    ptr: *mut u8,
}
unsafe impl Send for Trng {}
unsafe impl Sync for Trng {}
impl Trng {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[inline(always)]
    pub const fn gprcm(self) -> Gprcm {
        unsafe { Gprcm::from_ptr(self.ptr.add(0x0800usize) as _) }
    }
    #[doc = "Interrupt index."]
    #[inline(always)]
    pub const fn iidx(self) -> crate::common::Reg<regs::Iidx, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1020usize) as _) }
    }
    #[doc = "Interrupt mask."]
    #[inline(always)]
    pub const fn imask(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1028usize) as _) }
    }
    #[doc = "Raw interrupt status."]
    #[inline(always)]
    pub const fn ris(self) -> crate::common::Reg<regs::Int, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1030usize) as _) }
    }
    #[doc = "Masked interrupt status."]
    #[inline(always)]
    pub const fn mis(self) -> crate::common::Reg<regs::Int, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1038usize) as _) }
    }
    #[doc = "Interrupt set."]
    #[inline(always)]
    pub const fn iset(self) -> crate::common::Reg<regs::Int, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1040usize) as _) }
    }
    #[doc = "Interrupt clear."]
    #[inline(always)]
    pub const fn iclr(self) -> crate::common::Reg<regs::Int, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1048usize) as _) }
    }
    #[doc = "Module descriptions."]
    #[inline(always)]
    pub const fn desc(self) -> crate::common::Reg<regs::Desc, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10fcusize) as _) }
    }
    #[doc = "Controls the command and decimation rate."]
    #[inline(always)]
    pub const fn ctl(self) -> crate::common::Reg<regs::Ctl, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1100usize) as _) }
    }
    #[doc = "Status register that informs health test results and last issued command."]
    #[inline(always)]
    pub const fn stat(self) -> crate::common::Reg<regs::Stat, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1104usize) as _) }
    }
    #[doc = "Captured word buffer of RNG data."]
    #[inline(always)]
    pub const fn data_capture(self) -> crate::common::Reg<u32, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1108usize) as _) }
    }
    #[doc = "Test results from TEST_ANA and TEST_DIG."]
    #[inline(always)]
    pub const fn test_results(self) -> crate::common::Reg<regs::TestResults, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x110cusize) as _) }
    }
    #[doc = "Clock Divider."]
    #[inline(always)]
    pub const fn clkdiv(self) -> crate::common::Reg<regs::Clkdiv, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1110usize) as _) }
    }
}
pub mod regs {
    #[doc = "Clock Divider."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Clkdiv(pub u32);
    impl Clkdiv {
        #[doc = "Selects divide ratio of module clock."]
        #[inline(always)]
        pub const fn ratio(&self) -> super::vals::Ratio {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::Ratio::from_bits(val as u8)
        }
        #[doc = "Selects divide ratio of module clock."]
        #[inline(always)]
        pub fn set_ratio(&mut self, val: super::vals::Ratio) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
    }
    impl Default for Clkdiv {
        #[inline(always)]
        fn default() -> Clkdiv {
            Clkdiv(0)
        }
    }
    #[doc = "Controls the command and decimation rate."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ctl(pub u32);
    impl Ctl {
        #[doc = "Sets the TRNG mode through a command. The mode will not be updated until the previous command is done, as indicated by IRQ_CMD_DONE."]
        #[inline(always)]
        pub const fn cmd(&self) -> super::vals::Cmd {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::Cmd::from_bits(val as u8)
        }
        #[doc = "Sets the TRNG mode through a command. The mode will not be updated until the previous command is done, as indicated by IRQ_CMD_DONE."]
        #[inline(always)]
        pub fn set_cmd(&mut self, val: super::vals::Cmd) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
        #[doc = "Set decimation rate."]
        #[inline(always)]
        pub const fn decim_rate(&self) -> super::vals::DecimRate {
            let val = (self.0 >> 8usize) & 0x07;
            super::vals::DecimRate::from_bits(val as u8)
        }
        #[doc = "Set decimation rate."]
        #[inline(always)]
        pub fn set_decim_rate(&mut self, val: super::vals::DecimRate) {
            self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
        }
        #[doc = "When '1', the powerup sequence will take twice as long (i.e., clock frequency halved)."]
        #[inline(always)]
        pub const fn pwrup_clkdiv(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "When '1', the powerup sequence will take twice as long (i.e., clock frequency halved)."]
        #[inline(always)]
        pub fn set_pwrup_clkdiv(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "Configure PCHARGE sequence length."]
        #[inline(always)]
        pub const fn pwrup_pchrg_cfg(&self) -> super::vals::PwrupPchrg {
            let val = (self.0 >> 17usize) & 0x03;
            super::vals::PwrupPchrg::from_bits(val as u8)
        }
        #[doc = "Configure PCHARGE sequence length."]
        #[inline(always)]
        pub fn set_pwrup_pchrg_cfg(&mut self, val: super::vals::PwrupPchrg) {
            self.0 = (self.0 & !(0x03 << 17usize)) | (((val.to_bits() as u32) & 0x03) << 17usize);
        }
        #[doc = "Configure pulse startup sequence length."]
        #[inline(always)]
        pub const fn pwrup_pstart_cfg(&self) -> super::vals::PwrupPstart {
            let val = (self.0 >> 19usize) & 0x03;
            super::vals::PwrupPstart::from_bits(val as u8)
        }
        #[doc = "Configure pulse startup sequence length."]
        #[inline(always)]
        pub fn set_pwrup_pstart_cfg(&mut self, val: super::vals::PwrupPstart) {
            self.0 = (self.0 & !(0x03 << 19usize)) | (((val.to_bits() as u32) & 0x03) << 19usize);
        }
    }
    impl Default for Ctl {
        #[inline(always)]
        fn default() -> Ctl {
            Ctl(0)
        }
    }
    #[doc = "Module descriptions."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Desc(pub u32);
    impl Desc {
        #[doc = "Minor rev of the IP."]
        #[inline(always)]
        pub const fn minrev(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x0f;
            val as u8
        }
        #[doc = "Minor rev of the IP."]
        #[inline(always)]
        pub fn set_minrev(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
        }
        #[doc = "Major rev of the IP."]
        #[inline(always)]
        pub const fn majrev(&self) -> u8 {
            let val = (self.0 >> 4usize) & 0x0f;
            val as u8
        }
        #[doc = "Major rev of the IP."]
        #[inline(always)]
        pub fn set_majrev(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
        }
        #[doc = "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances."]
        #[inline(always)]
        pub const fn instnum(&self) -> u8 {
            let val = (self.0 >> 8usize) & 0x0f;
            val as u8
        }
        #[doc = "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances."]
        #[inline(always)]
        pub fn set_instnum(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
        }
        #[doc = "Feature Set for the module *instance*."]
        #[inline(always)]
        pub const fn featurever(&self) -> u8 {
            let val = (self.0 >> 12usize) & 0x0f;
            val as u8
        }
        #[doc = "Feature Set for the module *instance*."]
        #[inline(always)]
        pub fn set_featurever(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
        }
        #[doc = "Module Identifier - An internal TI page has been created to request unique module IDs."]
        #[inline(always)]
        pub const fn moduleid(&self) -> u16 {
            let val = (self.0 >> 16usize) & 0xffff;
            val as u16
        }
        #[doc = "Module Identifier - An internal TI page has been created to request unique module IDs."]
        #[inline(always)]
        pub fn set_moduleid(&mut self, val: u16) {
            self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
        }
    }
    impl Default for Desc {
        #[inline(always)]
        fn default() -> Desc {
            Desc(0)
        }
    }
    #[doc = "Status Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct GprcmStat(pub u32);
    impl GprcmStat {
        #[doc = "This bit indicates if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register."]
        #[inline(always)]
        pub const fn resetstky(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "This bit indicates if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register."]
        #[inline(always)]
        pub fn set_resetstky(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
    }
    impl Default for GprcmStat {
        #[inline(always)]
        fn default() -> GprcmStat {
            GprcmStat(0)
        }
    }
    #[doc = "Interrupt index."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iidx(pub u32);
    impl Iidx {
        #[doc = "Interrupt index status."]
        #[inline(always)]
        pub const fn stat(&self) -> super::vals::Stat {
            let val = (self.0 >> 0usize) & 0xff;
            super::vals::Stat::from_bits(val as u8)
        }
        #[doc = "Interrupt index status."]
        #[inline(always)]
        pub fn set_stat(&mut self, val: super::vals::Stat) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
        }
    }
    impl Default for Iidx {
        #[inline(always)]
        fn default() -> Iidx {
            Iidx(0)
        }
    }
    #[doc = "Interrupt mask."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Int(pub u32);
    impl Int {
        #[doc = "Mask for IRQ_HEALTH_FAIL. Indicates that a health test has failed."]
        #[inline(always)]
        pub const fn irq_health_fail(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Mask for IRQ_HEALTH_FAIL. Indicates that a health test has failed."]
        #[inline(always)]
        pub fn set_irq_health_fail(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Masked interrupt source for IRQ_CMD_FAIL. Indicates that the just issued command/mode has been rejected."]
        #[inline(always)]
        pub const fn irq_cmd_fail(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Masked interrupt source for IRQ_CMD_FAIL. Indicates that the just issued command/mode has been rejected."]
        #[inline(always)]
        pub fn set_irq_cmd_fail(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Mask for IRQ_CMD_DONE. Indicates that a command has finished."]
        #[inline(always)]
        pub const fn irq_cmd_done(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Mask for IRQ_CMD_DONE. Indicates that a command has finished."]
        #[inline(always)]
        pub fn set_irq_cmd_done(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Mask for IRQ_CAPTURED_RDY. Indicates to the CPU that the Captured Word is ready to be read."]
        #[inline(always)]
        pub const fn irq_captured_rdy(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Mask for IRQ_CAPTURED_RDY. Indicates to the CPU that the Captured Word is ready to be read."]
        #[inline(always)]
        pub fn set_irq_captured_rdy(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
    }
    impl Default for Int {
        #[inline(always)]
        fn default() -> Int {
            Int(0)
        }
    }
    #[doc = "Power enable."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pwren(pub u32);
    impl Pwren {
        #[doc = "Enable the power."]
        #[inline(always)]
        pub const fn enable(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Enable the power."]
        #[inline(always)]
        pub fn set_enable(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "KEY to allow Power State Change."]
        #[inline(always)]
        pub const fn key(&self) -> super::vals::PwrenKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::PwrenKey::from_bits(val as u8)
        }
        #[doc = "KEY to allow Power State Change."]
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::PwrenKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Pwren {
        #[inline(always)]
        fn default() -> Pwren {
            Pwren(0)
        }
    }
    #[doc = "Reset Control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rstctl(pub u32);
    impl Rstctl {
        #[doc = "Assert reset to the peripheral."]
        #[inline(always)]
        pub const fn resetassert(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Assert reset to the peripheral."]
        #[inline(always)]
        pub fn set_resetassert(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Clear the RESETSTKY bit in the STAT register."]
        #[inline(always)]
        pub const fn resetstkyclr(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Clear the RESETSTKY bit in the STAT register."]
        #[inline(always)]
        pub fn set_resetstkyclr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Unlock key."]
        #[inline(always)]
        pub const fn key(&self) -> super::vals::RstctlKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::RstctlKey::from_bits(val as u8)
        }
        #[doc = "Unlock key."]
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::RstctlKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Rstctl {
        #[inline(always)]
        fn default() -> Rstctl {
            Rstctl(0)
        }
    }
    #[doc = "Status register that informs health test results and last issued command."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Stat(pub u32);
    impl Stat {
        #[doc = "Indicates that the Adaptive Proportion Test (1,2,3, or 4-bit counters) failed by having too many or too few counted samples in the last 1024 bit window."]
        #[inline(always)]
        pub const fn adap_fail(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Indicates that the Adaptive Proportion Test (1,2,3, or 4-bit counters) failed by having too many or too few counted samples in the last 1024 bit window."]
        #[inline(always)]
        pub fn set_adap_fail(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Indicates that the repetition counter test caused the most recent failure. Thus, the health count numbers are most likely not for a complete 1024-bit window."]
        #[inline(always)]
        pub const fn rep_fail(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Indicates that the repetition counter test caused the most recent failure. Thus, the health count numbers are most likely not for a complete 1024-bit window."]
        #[inline(always)]
        pub fn set_rep_fail(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Indicates the last accepted command that is issued to the TRNG interface. Upon writing a valid command, this register will update and the command will be in progress until CMD_DONE_IRQ is set. CMD_DONE_IRQ indicates that the state is in PWROFF, NORM_FUNC, or ERROR. These states will accept new commands."]
        #[inline(always)]
        pub const fn issued_cmd(&self) -> super::vals::Cmd {
            let val = (self.0 >> 8usize) & 0x03;
            super::vals::Cmd::from_bits(val as u8)
        }
        #[doc = "Indicates the last accepted command that is issued to the TRNG interface. Upon writing a valid command, this register will update and the command will be in progress until CMD_DONE_IRQ is set. CMD_DONE_IRQ indicates that the state is in PWROFF, NORM_FUNC, or ERROR. These states will accept new commands."]
        #[inline(always)]
        pub fn set_issued_cmd(&mut self, val: super::vals::Cmd) {
            self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
        }
        #[doc = "Current state of the front end FSM (behind a clock domain crossing). 2 reads are REQUIRED as there is a chance of metastability when reading this."]
        #[inline(always)]
        pub const fn fsm_state(&self) -> super::vals::FsmState {
            let val = (self.0 >> 16usize) & 0x0f;
            super::vals::FsmState::from_bits(val as u8)
        }
        #[doc = "Current state of the front end FSM (behind a clock domain crossing). 2 reads are REQUIRED as there is a chance of metastability when reading this."]
        #[inline(always)]
        pub fn set_fsm_state(&mut self, val: super::vals::FsmState) {
            self.0 = (self.0 & !(0x0f << 16usize)) | (((val.to_bits() as u32) & 0x0f) << 16usize);
        }
    }
    impl Default for Stat {
        #[inline(always)]
        fn default() -> Stat {
            Stat(0)
        }
    }
    #[doc = "Test results from TEST_ANA and TEST_DIG."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TestResults(pub u32);
    impl TestResults {
        #[doc = "Indicates if the decimation rate test and health test (verifies conditioning, decimation, and captured buffer) has succeeded."]
        #[inline(always)]
        pub const fn dig_test(&self, n: usize) -> bool {
            assert!(n < 8usize);
            let offs = 0usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "Indicates if the decimation rate test and health test (verifies conditioning, decimation, and captured buffer) has succeeded."]
        #[inline(always)]
        pub fn set_dig_test(&mut self, n: usize, val: bool) {
            assert!(n < 8usize);
            let offs = 0usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
        #[doc = "Runs through 4096 samples from an enabled entropy source and verifies that none of the health tests failed, indicating sufficient entropy was produced by the analog components."]
        #[inline(always)]
        pub const fn ana_test(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "Runs through 4096 samples from an enabled entropy source and verifies that none of the health tests failed, indicating sufficient entropy was produced by the analog components."]
        #[inline(always)]
        pub fn set_ana_test(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
    }
    impl Default for TestResults {
        #[inline(always)]
        fn default() -> TestResults {
            TestResults(0)
        }
    }
}
pub mod vals {
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Cmd {
        #[doc = "Turns the power off of the analog source and clocks the digital interface."]
        PWR_OFF = 0x0,
        #[doc = "Initiates the powerup test sequence for the digital components. This verifies that the digital components are properly working. IRQ_CMD_DONE indicates that the test is done. The results of this test are in DIG_TEST of the TEST_RESULTS register."]
        PWRUP_DIG = 0x01,
        #[doc = "Initiates the powerup test sequence for the analog TRNG. This verifies that the analog component is generating sequences with enough entropy. IRQ_CMD_DONE indicates that the test is done. The results of this test are ANA_TEST of the TEST_RESULTS register."]
        PWRUP_ANA = 0x02,
        #[doc = "Normal operating mode for TRNG. All components are turned on."]
        NORM_FUNC = 0x03,
    }
    impl Cmd {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Cmd {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Cmd {
        #[inline(always)]
        fn from(val: u8) -> Cmd {
            Cmd::from_bits(val)
        }
    }
    impl From<Cmd> for u8 {
        #[inline(always)]
        fn from(val: Cmd) -> u8 {
            Cmd::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum DecimRate {
        #[doc = "Decimation by 1 (no decimation)"]
        DECIM_1 = 0x0,
        #[doc = "Decimation by 2 (skip every other sample)"]
        DECIM_2 = 0x01,
        #[doc = "Decimation by 3 (take every 3rd sample)"]
        DECIM_3 = 0x02,
        #[doc = "Decimation by 4 (take every 4th sample)"]
        DECIM_4 = 0x03,
        #[doc = "Decimation by 5 (take every 5th sample)"]
        DECIM_5 = 0x04,
        #[doc = "Decimation by 6 (take every 6th sample)"]
        DECIM_6 = 0x05,
        #[doc = "Decimation by 7 (take every 7th sample)"]
        DECIM_7 = 0x06,
        #[doc = "Decimation by 8 (take every 8th sample)"]
        DECIM_8 = 0x07,
    }
    impl DecimRate {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> DecimRate {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for DecimRate {
        #[inline(always)]
        fn from(val: u8) -> DecimRate {
            DecimRate::from_bits(val)
        }
    }
    impl From<DecimRate> for u8 {
        #[inline(always)]
        fn from(val: DecimRate) -> u8 {
            DecimRate::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum FsmState {
        OFF = 0x0,
        PWRUP_ES = 0x01,
        PWRDOWN_ES = 0x02,
        NORM_FUNC = 0x03,
        _RESERVED_4 = 0x04,
        _RESERVED_5 = 0x05,
        _RESERVED_6 = 0x06,
        TEST_DIG = 0x07,
        _RESERVED_8 = 0x08,
        _RESERVED_9 = 0x09,
        ERROR = 0x0a,
        TEST_ANA = 0x0b,
        _RESERVED_c = 0x0c,
        _RESERVED_d = 0x0d,
        _RESERVED_e = 0x0e,
        _RESERVED_f = 0x0f,
    }
    impl FsmState {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> FsmState {
            unsafe { core::mem::transmute(val & 0x0f) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for FsmState {
        #[inline(always)]
        fn from(val: u8) -> FsmState {
            FsmState::from_bits(val)
        }
    }
    impl From<FsmState> for u8 {
        #[inline(always)]
        fn from(val: FsmState) -> u8 {
            FsmState::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct PwrenKey(pub u8);
    impl PwrenKey {
        pub const KEY: Self = Self(0x26);
    }
    impl PwrenKey {
        pub const fn from_bits(val: u8) -> PwrenKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for PwrenKey {
        #[inline(always)]
        fn from(val: u8) -> PwrenKey {
            PwrenKey::from_bits(val)
        }
    }
    impl From<PwrenKey> for u8 {
        #[inline(always)]
        fn from(val: PwrenKey) -> u8 {
            PwrenKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum PwrupPchrg {
        DISABLE = 0x0,
        #[doc = "20 us PCHARGE"]
        US_20 = 0x01,
        #[doc = "30 us PCHARGE (default)"]
        US_30 = 0x02,
        #[doc = "40 us PCHARGE"]
        US_40 = 0x03,
    }
    impl PwrupPchrg {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> PwrupPchrg {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for PwrupPchrg {
        #[inline(always)]
        fn from(val: u8) -> PwrupPchrg {
            PwrupPchrg::from_bits(val)
        }
    }
    impl From<PwrupPchrg> for u8 {
        #[inline(always)]
        fn from(val: PwrupPchrg) -> u8 {
            PwrupPchrg::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum PwrupPstart {
        DISABLE = 0x0,
        #[doc = "rise at 10us, fall at 50us"]
        RISE_10_FALL_50 = 0x01,
        #[doc = "rise at 10us, fall at 70us (default)"]
        RISE_10_FALL_70 = 0x02,
        #[doc = "rise at 10us, fall at 90us"]
        RISE_10_FALL_90 = 0x03,
    }
    impl PwrupPstart {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> PwrupPstart {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for PwrupPstart {
        #[inline(always)]
        fn from(val: u8) -> PwrupPstart {
            PwrupPstart::from_bits(val)
        }
    }
    impl From<PwrupPstart> for u8 {
        #[inline(always)]
        fn from(val: PwrupPstart) -> u8 {
            PwrupPstart::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Ratio {
        #[doc = "Do not divide clock source."]
        DIV_BY_1 = 0x0,
        #[doc = "Divide clock source by 2."]
        DIV_BY_2 = 0x01,
        _RESERVED_2 = 0x02,
        #[doc = "Divide clock source by 4."]
        DIV_BY_4 = 0x03,
        _RESERVED_4 = 0x04,
        #[doc = "Divide clock source by 6."]
        DIV_BY_6 = 0x05,
        _RESERVED_6 = 0x06,
        #[doc = "Divide clock source by 8."]
        DIV_BY_8 = 0x07,
    }
    impl Ratio {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ratio {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ratio {
        #[inline(always)]
        fn from(val: u8) -> Ratio {
            Ratio::from_bits(val)
        }
    }
    impl From<Ratio> for u8 {
        #[inline(always)]
        fn from(val: Ratio) -> u8 {
            Ratio::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct RstctlKey(pub u8);
    impl RstctlKey {
        pub const KEY: Self = Self(0xb1);
    }
    impl RstctlKey {
        pub const fn from_bits(val: u8) -> RstctlKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for RstctlKey {
        #[inline(always)]
        fn from(val: u8) -> RstctlKey {
            RstctlKey::from_bits(val)
        }
    }
    impl From<RstctlKey> for u8 {
        #[inline(always)]
        fn from(val: RstctlKey) -> u8 {
            RstctlKey::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Stat(pub u8);
    impl Stat {
        #[doc = "No bit is set means there is no pending interrupt request."]
        pub const NO_INTR: Self = Self(0x0);
        #[doc = "Indicates that a health test has failed. The TRNG is in an error state until the interrupt is cleared."]
        pub const IRQ_HEALTH_FAIL: Self = Self(0x01);
        #[doc = "Indicates that the just issued command was rejected and is not being performed."]
        pub const IRQ_CMD_FAIL: Self = Self(0x02);
        #[doc = "Indicates that the current command/mode is done. This may have different meanings based on the mode: OFF --> Power has been turned off PWRUP_DIG --> Digital powerup tests are done PWRUP_ANA --> Analog powerup tests are done NORM_FUNC --> No IRQ, since mode runs indefinitely until a new command is issued."]
        pub const IRQ_CMD_DONE: Self = Self(0x03);
        #[doc = "Indicates that the captured word buffer is ready to be copied to memory."]
        pub const IRQ_CAPTURED_RDY: Self = Self(0x04);
    }
    impl Stat {
        pub const fn from_bits(val: u8) -> Stat {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for Stat {
        #[inline(always)]
        fn from(val: u8) -> Stat {
            Stat::from_bits(val)
        }
    }
    impl From<Stat> for u8 {
        #[inline(always)]
        fn from(val: Stat) -> u8 {
            Stat::to_bits(val)
        }
    }
}
