// This file is autogenerated by mspm0-metapac-gen: do not edit by hand.
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::identity_op)]
#![allow(clippy::unnecessary_cast)]
#![allow(clippy::erasing_op)]

#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Controller {
    ptr: *mut u8,
}
unsafe impl Send for Controller {}
unsafe impl Sync for Controller {}
impl Controller {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "I2C Controller Target Address Register."]
    #[inline(always)]
    pub const fn csa(self) -> crate::common::Reg<regs::Csa, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "I2C Controller Control Register."]
    #[inline(always)]
    pub const fn cctr(self) -> crate::common::Reg<regs::Cctr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
    }
    #[doc = "I2C Controller Status Register."]
    #[inline(always)]
    pub const fn csr(self) -> crate::common::Reg<regs::Csr, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
    }
    #[doc = "I2C Controller RXData."]
    #[inline(always)]
    pub const fn crxdata(self) -> crate::common::Reg<regs::Crxdata, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
    }
    #[doc = "I2C Controller TXData."]
    #[inline(always)]
    pub const fn ctxdata(self) -> crate::common::Reg<regs::Ctxdata, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
    }
    #[doc = "I2C Controller Timer Period."]
    #[inline(always)]
    pub const fn ctpr(self) -> crate::common::Reg<regs::Ctpr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
    }
    #[doc = "I2C Controller Configuration."]
    #[inline(always)]
    pub const fn ccr(self) -> crate::common::Reg<regs::Ccr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
    }
    #[doc = "I2C Controller Bus Monitor."]
    #[inline(always)]
    pub const fn cbmon(self) -> crate::common::Reg<regs::Cbmon, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
    }
    #[doc = "I2C Controller FIFO Control."]
    #[inline(always)]
    pub const fn cfifoctl(self) -> crate::common::Reg<regs::Cfifoctl, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
    }
    #[doc = "I2C Controller FIFO Status Register."]
    #[inline(always)]
    pub const fn cfifosr(self) -> crate::common::Reg<regs::Cfifosr, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
    }
    #[doc = "I2C Controller PEC control register."]
    #[inline(always)]
    pub const fn controller_i2cpecctl(
        self,
    ) -> crate::common::Reg<regs::ControllerI2cpecctl, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
    }
    #[doc = "I2C Controller PEC status register."]
    #[inline(always)]
    pub const fn controller_pecsr(
        self,
    ) -> crate::common::Reg<regs::ControllerPecsr, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
    }
}
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct CpuInt {
    ptr: *mut u8,
}
unsafe impl Send for CpuInt {}
unsafe impl Sync for CpuInt {}
impl CpuInt {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Interrupt index."]
    #[inline(always)]
    pub const fn iidx(self) -> crate::common::Reg<regs::CpuIntIidx, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "Interrupt mask."]
    #[inline(always)]
    pub const fn imask(self) -> crate::common::Reg<regs::CpuInt, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
    }
    #[doc = "Raw interrupt status."]
    #[inline(always)]
    pub const fn ris(self) -> crate::common::Reg<regs::CpuInt, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
    }
    #[doc = "Masked interrupt status."]
    #[inline(always)]
    pub const fn mis(self) -> crate::common::Reg<regs::CpuInt, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
    }
    #[doc = "Interrupt set."]
    #[inline(always)]
    pub const fn iset(self) -> crate::common::Reg<regs::CpuInt, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
    }
    #[doc = "Interrupt clear."]
    #[inline(always)]
    pub const fn iclr(self) -> crate::common::Reg<regs::CpuInt, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
    }
}
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct DmaTrig {
    ptr: *mut u8,
}
unsafe impl Send for DmaTrig {}
unsafe impl Sync for DmaTrig {}
impl DmaTrig {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Interrupt index."]
    #[inline(always)]
    pub const fn iidx(self) -> crate::common::Reg<regs::DmaTrigIidx, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "Interrupt mask."]
    #[inline(always)]
    pub const fn imask(self) -> crate::common::Reg<regs::DmaTrig, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
    }
    #[doc = "Raw interrupt status."]
    #[inline(always)]
    pub const fn ris(self) -> crate::common::Reg<regs::DmaTrig, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
    }
    #[doc = "Masked interrupt status."]
    #[inline(always)]
    pub const fn mis(self) -> crate::common::Reg<regs::DmaTrig, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
    }
    #[doc = "Interrupt set."]
    #[inline(always)]
    pub const fn iset(self) -> crate::common::Reg<regs::DmaTrig, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
    }
    #[doc = "Interrupt clear."]
    #[inline(always)]
    pub const fn iclr(self) -> crate::common::Reg<regs::DmaTrig, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
    }
}
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Gprcm {
    ptr: *mut u8,
}
unsafe impl Send for Gprcm {}
unsafe impl Sync for Gprcm {}
impl Gprcm {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Power enable."]
    #[inline(always)]
    pub const fn pwren(self) -> crate::common::Reg<regs::Pwren, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "Reset Control."]
    #[inline(always)]
    pub const fn rstctl(self) -> crate::common::Reg<regs::Rstctl, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
    }
    #[doc = "Peripheral Clock Configuration Register."]
    #[inline(always)]
    pub const fn clkcfg(self) -> crate::common::Reg<regs::Clkcfg, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
    }
    #[doc = "Status Register."]
    #[inline(always)]
    pub const fn stat(self) -> crate::common::Reg<regs::Stat, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
    }
}
#[doc = "PERIPHERALREGION."]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct I2c {
    ptr: *mut u8,
}
unsafe impl Send for I2c {}
unsafe impl Sync for I2c {}
impl I2c {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[inline(always)]
    pub const fn gprcm(self, n: usize) -> Gprcm {
        assert!(n < 1usize);
        unsafe { Gprcm::from_ptr(self.ptr.add(0x0800usize + n * 24usize) as _) }
    }
    #[doc = "Clock Divider."]
    #[inline(always)]
    pub const fn clkdiv(self) -> crate::common::Reg<regs::Clkdiv, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1000usize) as _) }
    }
    #[doc = "Clock Select for Ultra Low Power peripherals."]
    #[inline(always)]
    pub const fn clksel(self) -> crate::common::Reg<regs::Clksel, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1004usize) as _) }
    }
    #[doc = "Peripheral Debug Control."]
    #[inline(always)]
    pub const fn pdbgctl(self) -> crate::common::Reg<regs::Pdbgctl, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1018usize) as _) }
    }
    #[inline(always)]
    pub const fn cpu_int(self, n: usize) -> CpuInt {
        assert!(n < 1usize);
        unsafe { CpuInt::from_ptr(self.ptr.add(0x1020usize + n * 44usize) as _) }
    }
    #[inline(always)]
    pub const fn dma_trig1(self, n: usize) -> DmaTrig {
        assert!(n < 1usize);
        unsafe { DmaTrig::from_ptr(self.ptr.add(0x1050usize + n * 44usize) as _) }
    }
    #[inline(always)]
    pub const fn dma_trig0(self, n: usize) -> DmaTrig {
        assert!(n < 1usize);
        unsafe { DmaTrig::from_ptr(self.ptr.add(0x1080usize + n * 44usize) as _) }
    }
    #[doc = "Event Mode."]
    #[inline(always)]
    pub const fn evt_mode(self) -> crate::common::Reg<regs::EvtMode, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10e0usize) as _) }
    }
    #[doc = "Interrupt control register."]
    #[inline(always)]
    pub const fn intctl(self) -> crate::common::Reg<regs::Intctl, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10e4usize) as _) }
    }
    #[doc = "Module Description."]
    #[inline(always)]
    pub const fn desc(self) -> crate::common::Reg<regs::Desc, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10fcusize) as _) }
    }
    #[doc = "I2C Glitch Filter Control."]
    #[inline(always)]
    pub const fn gfctl(self) -> crate::common::Reg<regs::Gfctl, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1200usize) as _) }
    }
    #[doc = "I2C Timeout Count Control Register."]
    #[inline(always)]
    pub const fn timeout_ctl(self) -> crate::common::Reg<regs::TimeoutCtl, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1204usize) as _) }
    }
    #[doc = "I2C Timeout Count Register."]
    #[inline(always)]
    pub const fn timeout_cnt(self) -> crate::common::Reg<regs::TimeoutCnt, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1208usize) as _) }
    }
    #[inline(always)]
    pub const fn controller(self, n: usize) -> Controller {
        assert!(n < 1usize);
        unsafe { Controller::from_ptr(self.ptr.add(0x1210usize + n * 56usize) as _) }
    }
    #[inline(always)]
    pub const fn target(self, n: usize) -> Target {
        assert!(n < 1usize);
        unsafe { Target::from_ptr(self.ptr.add(0x1250usize + n * 44usize) as _) }
    }
}
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Target {
    ptr: *mut u8,
}
unsafe impl Send for Target {}
unsafe impl Sync for Target {}
impl Target {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "I2C Target Own Address."]
    #[inline(always)]
    pub const fn toar(self) -> crate::common::Reg<regs::Toar, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "I2C Target Own Address 2."]
    #[inline(always)]
    pub const fn toar2(self) -> crate::common::Reg<regs::Toar2, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
    }
    #[doc = "I2C Target Control Register."]
    #[inline(always)]
    pub const fn tctr(self) -> crate::common::Reg<regs::Tctr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
    }
    #[doc = "I2C Target Status Register."]
    #[inline(always)]
    pub const fn tsr(self) -> crate::common::Reg<regs::Tsr, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
    }
    #[doc = "I2C Target RXData."]
    #[inline(always)]
    pub const fn trxdata(self) -> crate::common::Reg<regs::Trxdata, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
    }
    #[doc = "I2C Target TXData."]
    #[inline(always)]
    pub const fn ttxdata(self) -> crate::common::Reg<regs::Ttxdata, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
    }
    #[doc = "I2C Target ACK Control."]
    #[inline(always)]
    pub const fn tackctl(self) -> crate::common::Reg<regs::Tackctl, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
    }
    #[doc = "I2C Target FIFO Control."]
    #[inline(always)]
    pub const fn tfifoctl(self) -> crate::common::Reg<regs::Tfifoctl, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
    }
    #[doc = "I2C Target FIFO Status Register."]
    #[inline(always)]
    pub const fn tfifosr(self) -> crate::common::Reg<regs::Tfifosr, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
    }
    #[doc = "I2C Target PEC control register."]
    #[inline(always)]
    pub const fn target_pecctl(self) -> crate::common::Reg<regs::TargetPecctl, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
    }
    #[doc = "I2C Target PEC status register."]
    #[inline(always)]
    pub const fn target_pecsr(self) -> crate::common::Reg<regs::TargetPecsr, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
    }
}
pub mod regs {
    #[doc = "I2C Controller Bus Monitor."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cbmon(pub u32);
    impl Cbmon {
        #[doc = "I2C SCL Status."]
        #[inline(always)]
        pub const fn scl(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "I2C SCL Status."]
        #[inline(always)]
        pub fn set_scl(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "I2C SDA Status."]
        #[inline(always)]
        pub const fn sda(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "I2C SDA Status."]
        #[inline(always)]
        pub fn set_sda(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
    }
    impl Default for Cbmon {
        #[inline(always)]
        fn default() -> Cbmon {
            Cbmon(0)
        }
    }
    #[doc = "I2C Controller Configuration."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ccr(pub u32);
    impl Ccr {
        #[doc = "Device Active After this bit has been set, it should not be set again unless it has been cleared by writing a 0 or by a reset, otherwise transfer failures may occur."]
        #[inline(always)]
        pub const fn active(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Device Active After this bit has been set, it should not be set again unless it has been cleared by writing a 0 or by a reset, otherwise transfer failures may occur."]
        #[inline(always)]
        pub fn set_active(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "MultiController mode. In MultiController mode the SCL high time counts once the SCL line has been detected high. If this is not enabled the high time counts as soon as the SCL line has been set high by the I2C controller."]
        #[inline(always)]
        pub const fn mctl(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "MultiController mode. In MultiController mode the SCL high time counts once the SCL line has been detected high. If this is not enabled the high time counts as soon as the SCL line has been set high by the I2C controller."]
        #[inline(always)]
        pub fn set_mctl(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Clock Stretching. This bit controls the support for clock stretching of the I2C bus."]
        #[inline(always)]
        pub const fn clkstretch(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Clock Stretching. This bit controls the support for clock stretching of the I2C bus."]
        #[inline(always)]
        pub fn set_clkstretch(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "I2C Loopback."]
        #[inline(always)]
        pub const fn lpbk(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "I2C Loopback."]
        #[inline(always)]
        pub fn set_lpbk(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
    }
    impl Default for Ccr {
        #[inline(always)]
        fn default() -> Ccr {
            Ccr(0)
        }
    }
    #[doc = "I2C Controller Control Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cctr(pub u32);
    impl Cctr {
        #[doc = "I2C Controller Enable and start transaction."]
        #[inline(always)]
        pub const fn burstrun(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "I2C Controller Enable and start transaction."]
        #[inline(always)]
        pub fn set_burstrun(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Generate START."]
        #[inline(always)]
        pub const fn start(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Generate START."]
        #[inline(always)]
        pub fn set_start(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Generate STOP."]
        #[inline(always)]
        pub const fn stop(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Generate STOP."]
        #[inline(always)]
        pub fn set_stop(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Data Acknowledge Enable. Software needs to configure this bit to send the ACK or NACK."]
        #[inline(always)]
        pub const fn ack(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Data Acknowledge Enable. Software needs to configure this bit to send the ACK or NACK."]
        #[inline(always)]
        pub fn set_ack(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Controller ACK overrride Enable."]
        #[inline(always)]
        pub const fn cackoen(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Controller ACK overrride Enable."]
        #[inline(always)]
        pub fn set_cackoen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Read on TX Empty."]
        #[inline(always)]
        pub const fn rd_on_txempty(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Read on TX Empty."]
        #[inline(always)]
        pub fn set_rd_on_txempty(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "I2C transaction length This field contains the programmed length of bytes of the Transaction."]
        #[inline(always)]
        pub const fn cblen(&self) -> u16 {
            let val = (self.0 >> 16usize) & 0x0fff;
            val as u16
        }
        #[doc = "I2C transaction length This field contains the programmed length of bytes of the Transaction."]
        #[inline(always)]
        pub fn set_cblen(&mut self, val: u16) {
            self.0 = (self.0 & !(0x0fff << 16usize)) | (((val as u32) & 0x0fff) << 16usize);
        }
    }
    impl Default for Cctr {
        #[inline(always)]
        fn default() -> Cctr {
            Cctr(0)
        }
    }
    #[doc = "I2C Controller FIFO Control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cfifoctl(pub u32);
    impl Cfifoctl {
        #[doc = "TX FIFO Trigger Indicates at what fill level in the TX FIFO a trigger will be generated."]
        #[inline(always)]
        pub const fn txtrig(&self) -> super::vals::CfifoctlTxtrig {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::CfifoctlTxtrig::from_bits(val as u8)
        }
        #[doc = "TX FIFO Trigger Indicates at what fill level in the TX FIFO a trigger will be generated."]
        #[inline(always)]
        pub fn set_txtrig(&mut self, val: super::vals::CfifoctlTxtrig) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
        #[doc = "TX FIFO Flush Setting this bit will Flush the TX FIFO. Before clearing this bit to stop Flush the TXFIFOCNT should be checked to be 8 and indicating that the Flush has completed."]
        #[inline(always)]
        pub const fn txflush(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "TX FIFO Flush Setting this bit will Flush the TX FIFO. Before clearing this bit to stop Flush the TXFIFOCNT should be checked to be 8 and indicating that the Flush has completed."]
        #[inline(always)]
        pub fn set_txflush(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "RX FIFO Trigger Indicates at what fill level in the RX FIFO a trigger will be generated. Note: Programming RXTRIG to 0x0 has no effect since no data is present to transfer out of RX FIFO."]
        #[inline(always)]
        pub const fn rxtrig(&self) -> super::vals::CfifoctlRxtrig {
            let val = (self.0 >> 8usize) & 0x07;
            super::vals::CfifoctlRxtrig::from_bits(val as u8)
        }
        #[doc = "RX FIFO Trigger Indicates at what fill level in the RX FIFO a trigger will be generated. Note: Programming RXTRIG to 0x0 has no effect since no data is present to transfer out of RX FIFO."]
        #[inline(always)]
        pub fn set_rxtrig(&mut self, val: super::vals::CfifoctlRxtrig) {
            self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
        }
        #[doc = "RX FIFO Flush Setting this bit will Flush the RX FIFO. Before clearing this bit to stop Flush the RXFIFOCNT should be checked to be 0 and indicating that the Flush has completed."]
        #[inline(always)]
        pub const fn rxflush(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "RX FIFO Flush Setting this bit will Flush the RX FIFO. Before clearing this bit to stop Flush the RXFIFOCNT should be checked to be 0 and indicating that the Flush has completed."]
        #[inline(always)]
        pub fn set_rxflush(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
    }
    impl Default for Cfifoctl {
        #[inline(always)]
        fn default() -> Cfifoctl {
            Cfifoctl(0)
        }
    }
    #[doc = "I2C Controller FIFO Status Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cfifosr(pub u32);
    impl Cfifosr {
        #[doc = "Number of Bytes which could be read from the RX FIFO."]
        #[inline(always)]
        pub const fn rxfifocnt(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x0f;
            val as u8
        }
        #[doc = "Number of Bytes which could be read from the RX FIFO."]
        #[inline(always)]
        pub fn set_rxfifocnt(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
        }
        #[doc = "RX FIFO Flush When this bit is set a Flush operation for the RX FIFO is active. Clear the RXFLUSH bit in the control register to stop."]
        #[inline(always)]
        pub const fn rxflush(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "RX FIFO Flush When this bit is set a Flush operation for the RX FIFO is active. Clear the RXFLUSH bit in the control register to stop."]
        #[inline(always)]
        pub fn set_rxflush(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "Number of Bytes which could be put into the TX FIFO."]
        #[inline(always)]
        pub const fn txfifocnt(&self) -> u8 {
            let val = (self.0 >> 8usize) & 0x0f;
            val as u8
        }
        #[doc = "Number of Bytes which could be put into the TX FIFO."]
        #[inline(always)]
        pub fn set_txfifocnt(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
        }
        #[doc = "TX FIFO Flush When this bit is set a Flush operation for the TX FIFO is active. Clear the TXFLUSH bit in the control register to stop."]
        #[inline(always)]
        pub const fn txflush(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "TX FIFO Flush When this bit is set a Flush operation for the TX FIFO is active. Clear the TXFLUSH bit in the control register to stop."]
        #[inline(always)]
        pub fn set_txflush(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
    }
    impl Default for Cfifosr {
        #[inline(always)]
        fn default() -> Cfifosr {
            Cfifosr(0)
        }
    }
    #[doc = "Peripheral Clock Configuration Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Clkcfg(pub u32);
    impl Clkcfg {
        #[doc = "Async Clock Request is blocked from starting SYSOSC or forcing bus clock to 32MHz."]
        #[inline(always)]
        pub const fn blockasync(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "Async Clock Request is blocked from starting SYSOSC or forcing bus clock to 32MHz."]
        #[inline(always)]
        pub fn set_blockasync(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "KEY to Allow State Change A9h = KEY to allow write access to this register"]
        #[inline(always)]
        pub const fn key(&self) -> super::vals::ClkcfgKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::ClkcfgKey::from_bits(val as u8)
        }
        #[doc = "KEY to Allow State Change A9h = KEY to allow write access to this register"]
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::ClkcfgKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Clkcfg {
        #[inline(always)]
        fn default() -> Clkcfg {
            Clkcfg(0)
        }
    }
    #[doc = "Clock Divider."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Clkdiv(pub u32);
    impl Clkdiv {
        #[doc = "Selects divide ratio of module clock."]
        #[inline(always)]
        pub const fn ratio(&self) -> super::vals::Ratio {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::Ratio::from_bits(val as u8)
        }
        #[doc = "Selects divide ratio of module clock."]
        #[inline(always)]
        pub fn set_ratio(&mut self, val: super::vals::Ratio) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
    }
    impl Default for Clkdiv {
        #[inline(always)]
        fn default() -> Clkdiv {
            Clkdiv(0)
        }
    }
    #[doc = "Clock Select for Ultra Low Power peripherals."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Clksel(pub u32);
    impl Clksel {
        #[doc = "Selects MFCLK as clock source if enabled."]
        #[inline(always)]
        pub const fn mfclk_sel(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Selects MFCLK as clock source if enabled."]
        #[inline(always)]
        pub fn set_mfclk_sel(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Selects BUSCLK as clock source if enabled."]
        #[inline(always)]
        pub const fn busclk_sel(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Selects BUSCLK as clock source if enabled."]
        #[inline(always)]
        pub fn set_busclk_sel(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
    }
    impl Default for Clksel {
        #[inline(always)]
        fn default() -> Clksel {
            Clksel(0)
        }
    }
    #[doc = "I2C Controller PEC control register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct ControllerI2cpecctl(pub u32);
    impl ControllerI2cpecctl {
        #[doc = "PEC Count When this field is non zero, the number of I2C bytes are counted (Note that although the PEC is calculated on the I2C address it is not counted at a byte). When the byte count = PECCNT and the state machine is transmitting, the contents of the LSFR is loaded into the shift register instead of the byte received from the Tx FIFO. When the state machine is receiving, after the last bit of this byte is received the LSFR is checked and if it is non-zero, a PEC RX Error interrupt is generated. The I2C packet must be padded to include the PEC byte for both transmit and receive. In transmit mode the FIFO must be loaded with a dummy PEC byte. In receive mode the PEC byte will be passed to the Rx FIFO. In the normal Controller use case, FW would set PECEN=1 and PECCNT=SMB packet length (Not including Target Address byte, but including the PEC byte). FW would then configure DMA to allow the packet to complete unassisted and write MCTR to initiate the transaction. Note that when the byte count = PEC CNT, the byte count is reset to 0 and multiple PEC calculation can automatically occur within a single I2C transaction. Note that any write to the Controller_I2CPECCTL Register will clear the current PEC Byte Count in the Controller State Machine."]
        #[inline(always)]
        pub const fn peccnt(&self) -> u16 {
            let val = (self.0 >> 0usize) & 0x01ff;
            val as u16
        }
        #[doc = "PEC Count When this field is non zero, the number of I2C bytes are counted (Note that although the PEC is calculated on the I2C address it is not counted at a byte). When the byte count = PECCNT and the state machine is transmitting, the contents of the LSFR is loaded into the shift register instead of the byte received from the Tx FIFO. When the state machine is receiving, after the last bit of this byte is received the LSFR is checked and if it is non-zero, a PEC RX Error interrupt is generated. The I2C packet must be padded to include the PEC byte for both transmit and receive. In transmit mode the FIFO must be loaded with a dummy PEC byte. In receive mode the PEC byte will be passed to the Rx FIFO. In the normal Controller use case, FW would set PECEN=1 and PECCNT=SMB packet length (Not including Target Address byte, but including the PEC byte). FW would then configure DMA to allow the packet to complete unassisted and write MCTR to initiate the transaction. Note that when the byte count = PEC CNT, the byte count is reset to 0 and multiple PEC calculation can automatically occur within a single I2C transaction. Note that any write to the Controller_I2CPECCTL Register will clear the current PEC Byte Count in the Controller State Machine."]
        #[inline(always)]
        pub fn set_peccnt(&mut self, val: u16) {
            self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
        }
        #[doc = "PEC Enable This bit enables the SMB Packet Error Checking (PEC). When enabled the PEC is calculated on all bits except the Start, Stop, Ack and Nack. The PEC LSFR and the Byte Counter is set to 0 when the State Machine is in the IDLE state, which occur following a Stop or when a timeout occurs. The Counter is also set to 0 after the PEC byte is sent or received. Note that the NACK is automatically send following a PEC byte that results in a PEC error. The PEC Polynomial is x^8 + x^2 + x^1 + 1."]
        #[inline(always)]
        pub const fn pecen(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "PEC Enable This bit enables the SMB Packet Error Checking (PEC). When enabled the PEC is calculated on all bits except the Start, Stop, Ack and Nack. The PEC LSFR and the Byte Counter is set to 0 when the State Machine is in the IDLE state, which occur following a Stop or when a timeout occurs. The Counter is also set to 0 after the PEC byte is sent or received. Note that the NACK is automatically send following a PEC byte that results in a PEC error. The PEC Polynomial is x^8 + x^2 + x^1 + 1."]
        #[inline(always)]
        pub fn set_pecen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
    }
    impl Default for ControllerI2cpecctl {
        #[inline(always)]
        fn default() -> ControllerI2cpecctl {
            ControllerI2cpecctl(0)
        }
    }
    #[doc = "I2C Controller PEC status register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct ControllerPecsr(pub u32);
    impl ControllerPecsr {
        #[doc = "PEC Byte Count. This is the current PEC Byte Count of the Controller State Machine."]
        #[inline(always)]
        pub const fn pecbytecnt(&self) -> u16 {
            let val = (self.0 >> 0usize) & 0x01ff;
            val as u16
        }
        #[doc = "PEC Byte Count. This is the current PEC Byte Count of the Controller State Machine."]
        #[inline(always)]
        pub fn set_pecbytecnt(&mut self, val: u16) {
            self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
        }
        #[doc = "This status bit indicates if the PEC was checked in the transaction that occurred before the last Stop. Latched on Stop."]
        #[inline(always)]
        pub const fn pecsts_check(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "This status bit indicates if the PEC was checked in the transaction that occurred before the last Stop. Latched on Stop."]
        #[inline(always)]
        pub fn set_pecsts_check(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "This status bit indicates if a PEC check error occurred in the transaction that occurred before the last Stop. Latched on Stop."]
        #[inline(always)]
        pub const fn pecsts_error(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "This status bit indicates if a PEC check error occurred in the transaction that occurred before the last Stop. Latched on Stop."]
        #[inline(always)]
        pub fn set_pecsts_error(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
    }
    impl Default for ControllerPecsr {
        #[inline(always)]
        fn default() -> ControllerPecsr {
            ControllerPecsr(0)
        }
    }
    #[doc = "Interrupt clear."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct CpuInt(pub u32);
    impl CpuInt {
        #[doc = "Controller Receive Data Interrupt Signals that a byte has been received."]
        #[inline(always)]
        pub const fn crxdone(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Controller Receive Data Interrupt Signals that a byte has been received."]
        #[inline(always)]
        pub fn set_crxdone(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Controller Transmit Transaction completed Interrupt."]
        #[inline(always)]
        pub const fn ctxdone(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Controller Transmit Transaction completed Interrupt."]
        #[inline(always)]
        pub fn set_ctxdone(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Controller Receive FIFO Trigger Trigger when RX FIFO contains >= defined bytes."]
        #[inline(always)]
        pub const fn crxfifotrg(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Controller Receive FIFO Trigger Trigger when RX FIFO contains >= defined bytes."]
        #[inline(always)]
        pub fn set_crxfifotrg(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Controller Transmit FIFO Trigger Trigger when Transmit FIFO contains <= defined bytes."]
        #[inline(always)]
        pub const fn ctxfifotrg(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Controller Transmit FIFO Trigger Trigger when Transmit FIFO contains <= defined bytes."]
        #[inline(always)]
        pub fn set_ctxfifotrg(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "RXFIFO full event."]
        #[inline(always)]
        pub const fn crxfifofull(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "RXFIFO full event."]
        #[inline(always)]
        pub fn set_crxfifofull(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode."]
        #[inline(always)]
        pub const fn ctxempty(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode."]
        #[inline(always)]
        pub fn set_ctxempty(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "Address/Data NACK Interrupt."]
        #[inline(always)]
        pub const fn cnack(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "Address/Data NACK Interrupt."]
        #[inline(always)]
        pub fn set_cnack(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "START Detection Interrupt."]
        #[inline(always)]
        pub const fn cstart(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "START Detection Interrupt."]
        #[inline(always)]
        pub fn set_cstart(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "STOP Detection Interrupt."]
        #[inline(always)]
        pub const fn cstop(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "STOP Detection Interrupt."]
        #[inline(always)]
        pub fn set_cstop(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "Arbitration Lost Interrupt."]
        #[inline(always)]
        pub const fn carblost(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "Arbitration Lost Interrupt."]
        #[inline(always)]
        pub fn set_carblost(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "DMA Done on Event Channel TX."]
        #[inline(always)]
        pub const fn cdma_done_tx(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "DMA Done on Event Channel TX."]
        #[inline(always)]
        pub fn set_cdma_done_tx(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "DMA Done on Event Channel RX."]
        #[inline(always)]
        pub const fn cdma_done_rx(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "DMA Done on Event Channel RX."]
        #[inline(always)]
        pub fn set_cdma_done_rx(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "Controller RX Pec Error Interrupt."]
        #[inline(always)]
        pub const fn cpec_rx_err(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "Controller RX Pec Error Interrupt."]
        #[inline(always)]
        pub fn set_cpec_rx_err(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "Timeout A interrupt."]
        #[inline(always)]
        pub const fn timeouta(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "Timeout A interrupt."]
        #[inline(always)]
        pub fn set_timeouta(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "Timeout B Interrupt."]
        #[inline(always)]
        pub const fn timeoutb(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "Timeout B Interrupt."]
        #[inline(always)]
        pub fn set_timeoutb(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "Target Receive Data Interrupt Signals that a byte has been received."]
        #[inline(always)]
        pub const fn trxdone(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "Target Receive Data Interrupt Signals that a byte has been received."]
        #[inline(always)]
        pub fn set_trxdone(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "Target Transmit Transaction completed Interrupt."]
        #[inline(always)]
        pub const fn ttxdone(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "Target Transmit Transaction completed Interrupt."]
        #[inline(always)]
        pub fn set_ttxdone(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "Target Receive FIFO Trigger."]
        #[inline(always)]
        pub const fn trxfifotrg(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "Target Receive FIFO Trigger."]
        #[inline(always)]
        pub fn set_trxfifotrg(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "Target Transmit FIFO Trigger."]
        #[inline(always)]
        pub const fn ttxfifotrg(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "Target Transmit FIFO Trigger."]
        #[inline(always)]
        pub fn set_ttxfifotrg(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
        #[doc = "RXFIFO full event. This interrupt is set if an RX FIFO is full."]
        #[inline(always)]
        pub const fn trxfifofull(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "RXFIFO full event. This interrupt is set if an RX FIFO is full."]
        #[inline(always)]
        pub fn set_trxfifofull(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode."]
        #[inline(always)]
        pub const fn ttxempty(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "Transmit FIFO Empty interrupt mask. This interrupt is set if all data in the Transmit FIFO have been shifted out and the transmit goes into idle mode."]
        #[inline(always)]
        pub fn set_ttxempty(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
        #[doc = "Target START Detection Interrupt."]
        #[inline(always)]
        pub const fn tstart(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "Target START Detection Interrupt."]
        #[inline(always)]
        pub fn set_tstart(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "Target STOP Detection Interrupt."]
        #[inline(always)]
        pub const fn tstop(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "Target STOP Detection Interrupt."]
        #[inline(always)]
        pub fn set_tstop(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "General Call Interrupt."]
        #[inline(always)]
        pub const fn tgencall(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "General Call Interrupt."]
        #[inline(always)]
        pub fn set_tgencall(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
        #[doc = "DMA Done on Event Channel TX."]
        #[inline(always)]
        pub const fn tdma_done_tx(&self) -> bool {
            let val = (self.0 >> 25usize) & 0x01;
            val != 0
        }
        #[doc = "DMA Done on Event Channel TX."]
        #[inline(always)]
        pub fn set_tdma_done_tx(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
        }
        #[doc = "DMA Done on Event Channel RX."]
        #[inline(always)]
        pub const fn tdma_done_rx(&self) -> bool {
            let val = (self.0 >> 26usize) & 0x01;
            val != 0
        }
        #[doc = "DMA Done on Event Channel RX."]
        #[inline(always)]
        pub fn set_tdma_done_rx(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
        }
        #[doc = "Target RX Pec Error Interrupt."]
        #[inline(always)]
        pub const fn tpec_rx_err(&self) -> bool {
            let val = (self.0 >> 27usize) & 0x01;
            val != 0
        }
        #[doc = "Target RX Pec Error Interrupt."]
        #[inline(always)]
        pub fn set_tpec_rx_err(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
        }
        #[doc = "Target TX FIFO underflow."]
        #[inline(always)]
        pub const fn ttx_unfl(&self) -> bool {
            let val = (self.0 >> 28usize) & 0x01;
            val != 0
        }
        #[doc = "Target TX FIFO underflow."]
        #[inline(always)]
        pub fn set_ttx_unfl(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
        }
        #[doc = "Target RX FIFO overflow."]
        #[inline(always)]
        pub const fn trx_ovfl(&self) -> bool {
            let val = (self.0 >> 29usize) & 0x01;
            val != 0
        }
        #[doc = "Target RX FIFO overflow."]
        #[inline(always)]
        pub fn set_trx_ovfl(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
        }
        #[doc = "Target Arbitration Lost."]
        #[inline(always)]
        pub const fn tarblost(&self) -> bool {
            let val = (self.0 >> 30usize) & 0x01;
            val != 0
        }
        #[doc = "Target Arbitration Lost."]
        #[inline(always)]
        pub fn set_tarblost(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
        }
        #[doc = "Interrupt overflow."]
        #[inline(always)]
        pub const fn intr_ovfl(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "Interrupt overflow."]
        #[inline(always)]
        pub fn set_intr_ovfl(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for CpuInt {
        #[inline(always)]
        fn default() -> CpuInt {
            CpuInt(0)
        }
    }
    #[doc = "Interrupt index."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct CpuIntIidx(pub u32);
    impl CpuIntIidx {
        #[doc = "I2C Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in RIS and MISC. 15h-1Fh = Reserved."]
        #[inline(always)]
        pub const fn stat(&self) -> super::vals::CpuIntIidxStat {
            let val = (self.0 >> 0usize) & 0xff;
            super::vals::CpuIntIidxStat::from_bits(val as u8)
        }
        #[doc = "I2C Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in RIS and MISC. 15h-1Fh = Reserved."]
        #[inline(always)]
        pub fn set_stat(&mut self, val: super::vals::CpuIntIidxStat) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
        }
    }
    impl Default for CpuIntIidx {
        #[inline(always)]
        fn default() -> CpuIntIidx {
            CpuIntIidx(0)
        }
    }
    #[doc = "I2C Controller RXData."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Crxdata(pub u32);
    impl Crxdata {
        #[doc = "Received Data. This field contains the last received data."]
        #[inline(always)]
        pub const fn value(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0xff;
            val as u8
        }
        #[doc = "Received Data. This field contains the last received data."]
        #[inline(always)]
        pub fn set_value(&mut self, val: u8) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
        }
    }
    impl Default for Crxdata {
        #[inline(always)]
        fn default() -> Crxdata {
            Crxdata(0)
        }
    }
    #[doc = "I2C Controller Target Address Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Csa(pub u32);
    impl Csa {
        #[doc = "Receive/Send The DIR bit specifies if the next Controller operation is a Receive (High) or Transmit (Low). 0h = Transmit 1h = Receive."]
        #[inline(always)]
        pub const fn dir(&self) -> super::vals::Dir {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Dir::from_bits(val as u8)
        }
        #[doc = "Receive/Send The DIR bit specifies if the next Controller operation is a Receive (High) or Transmit (Low). 0h = Transmit 1h = Receive."]
        #[inline(always)]
        pub fn set_dir(&mut self, val: super::vals::Dir) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "I2C Target Address This field specifies bits A9 through A0 of the Target address. In 7-bit addressing mode as selected by MSA.MODE bit, the top 3 bits are don't care."]
        #[inline(always)]
        pub const fn taddr(&self) -> u16 {
            let val = (self.0 >> 1usize) & 0x03ff;
            val as u16
        }
        #[doc = "I2C Target Address This field specifies bits A9 through A0 of the Target address. In 7-bit addressing mode as selected by MSA.MODE bit, the top 3 bits are don't care."]
        #[inline(always)]
        pub fn set_taddr(&mut self, val: u16) {
            self.0 = (self.0 & !(0x03ff << 1usize)) | (((val as u32) & 0x03ff) << 1usize);
        }
        #[doc = "This bit selects the adressing mode to be used in Controller mode When 0, 7-bit addressing is used. When 1, 10-bit addressing is used."]
        #[inline(always)]
        pub const fn cmode(&self) -> super::vals::Mode {
            let val = (self.0 >> 15usize) & 0x01;
            super::vals::Mode::from_bits(val as u8)
        }
        #[doc = "This bit selects the adressing mode to be used in Controller mode When 0, 7-bit addressing is used. When 1, 10-bit addressing is used."]
        #[inline(always)]
        pub fn set_cmode(&mut self, val: super::vals::Mode) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
        }
    }
    impl Default for Csa {
        #[inline(always)]
        fn default() -> Csa {
            Csa(0)
        }
    }
    #[doc = "I2C Controller Status Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Csr(pub u32);
    impl Csr {
        #[doc = "I2C Controller FSM Busy The BUSY bit is set during an ongoing transaction, so is set during the transmit/receive of the amount of data set in MBLEN including START, RESTART, Address and STOP signal generation when required for the current transaction."]
        #[inline(always)]
        pub const fn busy(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "I2C Controller FSM Busy The BUSY bit is set during an ongoing transaction, so is set during the transmit/receive of the amount of data set in MBLEN including START, RESTART, Address and STOP signal generation when required for the current transaction."]
        #[inline(always)]
        pub fn set_busy(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Error The error can be from the Target address not being acknowledged or the transmit data not being acknowledged."]
        #[inline(always)]
        pub const fn err(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Error The error can be from the Target address not being acknowledged or the transmit data not being acknowledged."]
        #[inline(always)]
        pub fn set_err(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Acknowledge Address."]
        #[inline(always)]
        pub const fn adrack(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Acknowledge Address."]
        #[inline(always)]
        pub fn set_adrack(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Acknowledge Data."]
        #[inline(always)]
        pub const fn datack(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Acknowledge Data."]
        #[inline(always)]
        pub fn set_datack(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Arbitration Lost."]
        #[inline(always)]
        pub const fn arblst(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Arbitration Lost."]
        #[inline(always)]
        pub fn set_arblst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "I2C Idle."]
        #[inline(always)]
        pub const fn idle(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "I2C Idle."]
        #[inline(always)]
        pub fn set_idle(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "I2C Bus is Busy Controller State Machine will wait until this bit is cleared before starting a transaction. When first enabling the Controller in multi Controller environments, FW should wait for one I2C clock period after setting ACTIVE high before writing to the MTCR register to start the transaction so that if SCL goes low it will trigger the BUSBSY."]
        #[inline(always)]
        pub const fn busbsy(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "I2C Bus is Busy Controller State Machine will wait until this bit is cleared before starting a transaction. When first enabling the Controller in multi Controller environments, FW should wait for one I2C clock period after setting ACTIVE high before writing to the MTCR register to start the transaction so that if SCL goes low it will trigger the BUSBSY."]
        #[inline(always)]
        pub fn set_busbsy(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "I2C Controller Transaction Count This field contains the current count-down value of the transaction."]
        #[inline(always)]
        pub const fn cbcnt(&self) -> u16 {
            let val = (self.0 >> 16usize) & 0x0fff;
            val as u16
        }
        #[doc = "I2C Controller Transaction Count This field contains the current count-down value of the transaction."]
        #[inline(always)]
        pub fn set_cbcnt(&mut self, val: u16) {
            self.0 = (self.0 & !(0x0fff << 16usize)) | (((val as u32) & 0x0fff) << 16usize);
        }
    }
    impl Default for Csr {
        #[inline(always)]
        fn default() -> Csr {
            Csr(0)
        }
    }
    #[doc = "I2C Controller Timer Period."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ctpr(pub u32);
    impl Ctpr {
        #[doc = "Timer Period This field is used in the equation to configure SCL_PERIOD : SCL_PERIOD = (1 + TPR ) * (SCL_LP + SCL_HP ) * INT_CLK_PRD where: SCL_PRD is the SCL line period (I2C clock). TPR is the Timer Period register value (range of 1 to 127). SCL_LP is the SCL Low period (fixed at 6). SCL_HP is the SCL High period (fixed at 4). CLK_PRD is the functional clock period in ns."]
        #[inline(always)]
        pub const fn tpr(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x7f;
            val as u8
        }
        #[doc = "Timer Period This field is used in the equation to configure SCL_PERIOD : SCL_PERIOD = (1 + TPR ) * (SCL_LP + SCL_HP ) * INT_CLK_PRD where: SCL_PRD is the SCL line period (I2C clock). TPR is the Timer Period register value (range of 1 to 127). SCL_LP is the SCL Low period (fixed at 6). SCL_HP is the SCL High period (fixed at 4). CLK_PRD is the functional clock period in ns."]
        #[inline(always)]
        pub fn set_tpr(&mut self, val: u8) {
            self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
        }
    }
    impl Default for Ctpr {
        #[inline(always)]
        fn default() -> Ctpr {
            Ctpr(0)
        }
    }
    #[doc = "I2C Controller TXData."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ctxdata(pub u32);
    impl Ctxdata {
        #[doc = "Transmit Data This byte contains the data to be transferred during the next transaction."]
        #[inline(always)]
        pub const fn value(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0xff;
            val as u8
        }
        #[doc = "Transmit Data This byte contains the data to be transferred during the next transaction."]
        #[inline(always)]
        pub fn set_value(&mut self, val: u8) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
        }
    }
    impl Default for Ctxdata {
        #[inline(always)]
        fn default() -> Ctxdata {
            Ctxdata(0)
        }
    }
    #[doc = "Module Description."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Desc(pub u32);
    impl Desc {
        #[doc = "Minor rev of the IP."]
        #[inline(always)]
        pub const fn minrev(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x0f;
            val as u8
        }
        #[doc = "Minor rev of the IP."]
        #[inline(always)]
        pub fn set_minrev(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
        }
        #[doc = "Major rev of the IP."]
        #[inline(always)]
        pub const fn majrev(&self) -> u8 {
            let val = (self.0 >> 4usize) & 0x0f;
            val as u8
        }
        #[doc = "Major rev of the IP."]
        #[inline(always)]
        pub fn set_majrev(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
        }
        #[doc = "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances."]
        #[inline(always)]
        pub const fn instnum(&self) -> u8 {
            let val = (self.0 >> 8usize) & 0x0f;
            val as u8
        }
        #[doc = "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances."]
        #[inline(always)]
        pub fn set_instnum(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
        }
        #[doc = "Feature Set for the module *instance*."]
        #[inline(always)]
        pub const fn featurever(&self) -> u8 {
            let val = (self.0 >> 12usize) & 0x0f;
            val as u8
        }
        #[doc = "Feature Set for the module *instance*."]
        #[inline(always)]
        pub fn set_featurever(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
        }
        #[doc = "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness."]
        #[inline(always)]
        pub const fn moduleid(&self) -> u16 {
            let val = (self.0 >> 16usize) & 0xffff;
            val as u16
        }
        #[doc = "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness."]
        #[inline(always)]
        pub fn set_moduleid(&mut self, val: u16) {
            self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
        }
    }
    impl Default for Desc {
        #[inline(always)]
        fn default() -> Desc {
            Desc(0)
        }
    }
    #[doc = "Interrupt clear."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTrig(pub u32);
    impl DmaTrig {
        #[doc = "Controller Receive FIFO Trigger Trigger when RX FIFO contains >= defined bytes."]
        #[inline(always)]
        pub const fn crxfifotrg(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Controller Receive FIFO Trigger Trigger when RX FIFO contains >= defined bytes."]
        #[inline(always)]
        pub fn set_crxfifotrg(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Controller Transmit FIFO Trigger Trigger when Transmit FIFO contains <= defined bytes."]
        #[inline(always)]
        pub const fn ctxfifotrg(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Controller Transmit FIFO Trigger Trigger when Transmit FIFO contains <= defined bytes."]
        #[inline(always)]
        pub fn set_ctxfifotrg(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Target Receive FIFO Trigger."]
        #[inline(always)]
        pub const fn trxfifotrg(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Target Receive FIFO Trigger."]
        #[inline(always)]
        pub fn set_trxfifotrg(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Target Transmit FIFO Trigger."]
        #[inline(always)]
        pub const fn ttxfifotrg(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Target Transmit FIFO Trigger."]
        #[inline(always)]
        pub fn set_ttxfifotrg(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
    }
    impl Default for DmaTrig {
        #[inline(always)]
        fn default() -> DmaTrig {
            DmaTrig(0)
        }
    }
    #[doc = "Interrupt index."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTrigIidx(pub u32);
    impl DmaTrigIidx {
        #[doc = "I2C Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in RIS and MISC. 15h-1Fh = Reserved."]
        #[inline(always)]
        pub const fn stat(&self) -> super::vals::DmaTrigIidxStat {
            let val = (self.0 >> 0usize) & 0xff;
            super::vals::DmaTrigIidxStat::from_bits(val as u8)
        }
        #[doc = "I2C Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in RIS and MISC. 15h-1Fh = Reserved."]
        #[inline(always)]
        pub fn set_stat(&mut self, val: super::vals::DmaTrigIidxStat) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
        }
    }
    impl Default for DmaTrigIidx {
        #[inline(always)]
        fn default() -> DmaTrigIidx {
            DmaTrigIidx(0)
        }
    }
    #[doc = "Event Mode."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EvtMode(pub u32);
    impl EvtMode {
        #[doc = "Event line mode select for event corresponding to \\[IPSTANDARD.CPU_INT\\]."]
        #[inline(always)]
        pub const fn cpu_int(&self) -> super::vals::EvtCfg {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::EvtCfg::from_bits(val as u8)
        }
        #[doc = "Event line mode select for event corresponding to \\[IPSTANDARD.CPU_INT\\]."]
        #[inline(always)]
        pub fn set_cpu_int(&mut self, val: super::vals::EvtCfg) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
        #[doc = "Event line mode select for event corresponding to \\[IPSTANDARD.DMA_TRIG1\\]."]
        #[inline(always)]
        pub const fn dma_trig1(&self) -> super::vals::EvtCfg {
            let val = (self.0 >> 2usize) & 0x03;
            super::vals::EvtCfg::from_bits(val as u8)
        }
        #[doc = "Event line mode select for event corresponding to \\[IPSTANDARD.DMA_TRIG1\\]."]
        #[inline(always)]
        pub fn set_dma_trig1(&mut self, val: super::vals::EvtCfg) {
            self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
        }
        #[doc = "Event line mode select for event corresponding to \\[IPSTANDARD.DMA_TRIG0\\]."]
        #[inline(always)]
        pub const fn dma_trig0(&self) -> super::vals::EvtCfg {
            let val = (self.0 >> 4usize) & 0x03;
            super::vals::EvtCfg::from_bits(val as u8)
        }
        #[doc = "Event line mode select for event corresponding to \\[IPSTANDARD.DMA_TRIG0\\]."]
        #[inline(always)]
        pub fn set_dma_trig0(&mut self, val: super::vals::EvtCfg) {
            self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
        }
    }
    impl Default for EvtMode {
        #[inline(always)]
        fn default() -> EvtMode {
            EvtMode(0)
        }
    }
    #[doc = "I2C Glitch Filter Control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gfctl(pub u32);
    impl Gfctl {
        #[doc = "Glitch Suppression Pulse Width This field controls the pulse width select for glitch suppression on the SCL and SDA lines. The following values are the glitch suppression values in terms of functional clocks. (Core Domain only)."]
        #[inline(always)]
        pub const fn dgfsel(&self) -> super::vals::Dgfsel {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::Dgfsel::from_bits(val as u8)
        }
        #[doc = "Glitch Suppression Pulse Width This field controls the pulse width select for glitch suppression on the SCL and SDA lines. The following values are the glitch suppression values in terms of functional clocks. (Core Domain only)."]
        #[inline(always)]
        pub fn set_dgfsel(&mut self, val: super::vals::Dgfsel) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
        #[doc = "Analog Glitch Suppression Enable."]
        #[inline(always)]
        pub const fn agfen(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "Analog Glitch Suppression Enable."]
        #[inline(always)]
        pub fn set_agfen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "Analog Glitch Suppression Pulse Width This field controls the pulse width select for the analog glitch suppression on SCL and SDA lines. See device datasheet for exact values. (ULP I2C only)."]
        #[inline(always)]
        pub const fn agfsel(&self) -> super::vals::Agfsel {
            let val = (self.0 >> 9usize) & 0x03;
            super::vals::Agfsel::from_bits(val as u8)
        }
        #[doc = "Analog Glitch Suppression Pulse Width This field controls the pulse width select for the analog glitch suppression on SCL and SDA lines. See device datasheet for exact values. (ULP I2C only)."]
        #[inline(always)]
        pub fn set_agfsel(&mut self, val: super::vals::Agfsel) {
            self.0 = (self.0 & !(0x03 << 9usize)) | (((val.to_bits() as u32) & 0x03) << 9usize);
        }
        #[doc = "Analog and digital noise filters chaining enable."]
        #[inline(always)]
        pub const fn chain(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "Analog and digital noise filters chaining enable."]
        #[inline(always)]
        pub fn set_chain(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
    }
    impl Default for Gfctl {
        #[inline(always)]
        fn default() -> Gfctl {
            Gfctl(0)
        }
    }
    #[doc = "Interrupt control register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Intctl(pub u32);
    impl Intctl {
        #[doc = "Writing a 1 to this field re-evaluates the interrupt sources."]
        #[inline(always)]
        pub const fn inteval(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Writing a 1 to this field re-evaluates the interrupt sources."]
        #[inline(always)]
        pub fn set_inteval(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Intctl {
        #[inline(always)]
        fn default() -> Intctl {
            Intctl(0)
        }
    }
    #[doc = "Peripheral Debug Control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pdbgctl(pub u32);
    impl Pdbgctl {
        #[doc = "Free run control."]
        #[inline(always)]
        pub const fn free(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Free run control."]
        #[inline(always)]
        pub fn set_free(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Soft halt boundary control. This function is only available, if \\[FREE\\]
is set to 'STOP'."]
        #[inline(always)]
        pub const fn soft(&self) -> super::vals::Soft {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Soft::from_bits(val as u8)
        }
        #[doc = "Soft halt boundary control. This function is only available, if \\[FREE\\]
is set to 'STOP'."]
        #[inline(always)]
        pub fn set_soft(&mut self, val: super::vals::Soft) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
    }
    impl Default for Pdbgctl {
        #[inline(always)]
        fn default() -> Pdbgctl {
            Pdbgctl(0)
        }
    }
    #[doc = "Power enable."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pwren(pub u32);
    impl Pwren {
        #[doc = "Enable the power."]
        #[inline(always)]
        pub const fn enable(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Enable the power."]
        #[inline(always)]
        pub fn set_enable(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "KEY to allow Power State Change 26h = KEY to allow write access to this register"]
        #[inline(always)]
        pub const fn key(&self) -> super::vals::PwrenKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::PwrenKey::from_bits(val as u8)
        }
        #[doc = "KEY to allow Power State Change 26h = KEY to allow write access to this register"]
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::PwrenKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Pwren {
        #[inline(always)]
        fn default() -> Pwren {
            Pwren(0)
        }
    }
    #[doc = "Reset Control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rstctl(pub u32);
    impl Rstctl {
        #[doc = "Assert reset to the peripheral."]
        #[inline(always)]
        pub const fn resetassert(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Assert reset to the peripheral."]
        #[inline(always)]
        pub fn set_resetassert(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Clear the RESETSTKY bit in the STAT register."]
        #[inline(always)]
        pub const fn resetstkyclr(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Clear the RESETSTKY bit in the STAT register."]
        #[inline(always)]
        pub fn set_resetstkyclr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Unlock key B1h = KEY to allow write access to this register"]
        #[inline(always)]
        pub const fn key(&self) -> super::vals::ResetKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::ResetKey::from_bits(val as u8)
        }
        #[doc = "Unlock key B1h = KEY to allow write access to this register"]
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::ResetKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Rstctl {
        #[inline(always)]
        fn default() -> Rstctl {
            Rstctl(0)
        }
    }
    #[doc = "Status Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Stat(pub u32);
    impl Stat {
        #[doc = "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register."]
        #[inline(always)]
        pub const fn resetstky(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register."]
        #[inline(always)]
        pub fn set_resetstky(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
    }
    impl Default for Stat {
        #[inline(always)]
        fn default() -> Stat {
            Stat(0)
        }
    }
    #[doc = "I2C Target ACK Control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tackctl(pub u32);
    impl Tackctl {
        #[doc = "I2C Target ACK Override Enable."]
        #[inline(always)]
        pub const fn ackoen(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "I2C Target ACK Override Enable."]
        #[inline(always)]
        pub fn set_ackoen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "I2C Target ACK Override Value Note: for General Call this bit will be ignored if set to NACK and Target continues to receive data."]
        #[inline(always)]
        pub const fn ackoval(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "I2C Target ACK Override Value Note: for General Call this bit will be ignored if set to NACK and Target continues to receive data."]
        #[inline(always)]
        pub fn set_ackoval(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "When set this bit will automatically turn on the Target ACKOEN field following a Start Condition."]
        #[inline(always)]
        pub const fn ackoen_on_start(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "When set this bit will automatically turn on the Target ACKOEN field following a Start Condition."]
        #[inline(always)]
        pub fn set_ackoen_on_start(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "When set this bit will automatically turn on the Target ACKOEN field following the ACK/NACK of the byte received just prior to the PEC byte. Note that when ACKOEN is set the PEC byte will not automatically be ACKed/NACKed by the State Machine and FW must perform this function by writing Target_SACKCTL."]
        #[inline(always)]
        pub const fn ackoen_on_pecnext(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "When set this bit will automatically turn on the Target ACKOEN field following the ACK/NACK of the byte received just prior to the PEC byte. Note that when ACKOEN is set the PEC byte will not automatically be ACKed/NACKed by the State Machine and FW must perform this function by writing Target_SACKCTL."]
        #[inline(always)]
        pub fn set_ackoen_on_pecnext(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "When set this bit will automatically turn on the Target ACKOEN field following the ACK/NACK of the received PEC byte."]
        #[inline(always)]
        pub const fn ackoen_on_pecdone(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "When set this bit will automatically turn on the Target ACKOEN field following the ACK/NACK of the received PEC byte."]
        #[inline(always)]
        pub fn set_ackoen_on_pecdone(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
    }
    impl Default for Tackctl {
        #[inline(always)]
        fn default() -> Tackctl {
            Tackctl(0)
        }
    }
    #[doc = "I2C Target PEC control register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TargetPecctl(pub u32);
    impl TargetPecctl {
        #[doc = "When this field is non zero, the number of I2C data bytes are counted. When the byte count = PECCNT and the state machine is transmitting, the contents of the LSFR is loaded into the shift register instead of the byte received from the Tx FIFO. When the state machine is receiving, after the last bit of this byte is received the LSFR is checked and if it is non-zero, a PEC RX Error interrupt is generated. The I2C packet must be padded to include the PEC byte for both transmit and receive. In transmit mode the FIFO must be loaded with a dummy PEC byte. In receive mode the PEC byte will be passed to the Rx FIFO. In the normal Target use case, FW would set PECEN=1 and PECCNT=0 and use the ACKOEN until the remaining SMB packet length is known. FW would then set the PECCNT to the remaining packet length (Including PEC bye). FW would then configure DMA to allow the packet to complete unassisted and exit NoAck mode. Note that when the byte count = PEC CNT, the byte count is reset to 0 and multiple PEC calculation can automatically occur within a single I2C transaction."]
        #[inline(always)]
        pub const fn peccnt(&self) -> u16 {
            let val = (self.0 >> 0usize) & 0x01ff;
            val as u16
        }
        #[doc = "When this field is non zero, the number of I2C data bytes are counted. When the byte count = PECCNT and the state machine is transmitting, the contents of the LSFR is loaded into the shift register instead of the byte received from the Tx FIFO. When the state machine is receiving, after the last bit of this byte is received the LSFR is checked and if it is non-zero, a PEC RX Error interrupt is generated. The I2C packet must be padded to include the PEC byte for both transmit and receive. In transmit mode the FIFO must be loaded with a dummy PEC byte. In receive mode the PEC byte will be passed to the Rx FIFO. In the normal Target use case, FW would set PECEN=1 and PECCNT=0 and use the ACKOEN until the remaining SMB packet length is known. FW would then set the PECCNT to the remaining packet length (Including PEC bye). FW would then configure DMA to allow the packet to complete unassisted and exit NoAck mode. Note that when the byte count = PEC CNT, the byte count is reset to 0 and multiple PEC calculation can automatically occur within a single I2C transaction."]
        #[inline(always)]
        pub fn set_peccnt(&mut self, val: u16) {
            self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
        }
        #[doc = "PEC Enable This bit enables the SMB Packet Error Checking (PEC). When enabled the PEC is calculated on all bits except the Start, Stop, Ack and Nack. The PEC LSFR and the Byte Counter is set to 0 when the State Machine is in the IDLE state, which occur following a Stop or when a timeout occurs. The Counter is also set to 0 after the PEC byte is sent or received. Note that the NACK is automatically send following a PEC byte that results in a PEC error. The PEC Polynomial is x^8 + x^2 + x^1 + 1."]
        #[inline(always)]
        pub const fn pecen(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "PEC Enable This bit enables the SMB Packet Error Checking (PEC). When enabled the PEC is calculated on all bits except the Start, Stop, Ack and Nack. The PEC LSFR and the Byte Counter is set to 0 when the State Machine is in the IDLE state, which occur following a Stop or when a timeout occurs. The Counter is also set to 0 after the PEC byte is sent or received. Note that the NACK is automatically send following a PEC byte that results in a PEC error. The PEC Polynomial is x^8 + x^2 + x^1 + 1."]
        #[inline(always)]
        pub fn set_pecen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
    }
    impl Default for TargetPecctl {
        #[inline(always)]
        fn default() -> TargetPecctl {
            TargetPecctl(0)
        }
    }
    #[doc = "I2C Target PEC status register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TargetPecsr(pub u32);
    impl TargetPecsr {
        #[doc = "This is the current PEC Byte Count of the Target State Machine."]
        #[inline(always)]
        pub const fn pecbytecnt(&self) -> u16 {
            let val = (self.0 >> 0usize) & 0x01ff;
            val as u16
        }
        #[doc = "This is the current PEC Byte Count of the Target State Machine."]
        #[inline(always)]
        pub fn set_pecbytecnt(&mut self, val: u16) {
            self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
        }
        #[doc = "This status bit indicates if the PEC was checked in the transaction that occurred before the last Stop. Latched on Stop."]
        #[inline(always)]
        pub const fn pecsts_check(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "This status bit indicates if the PEC was checked in the transaction that occurred before the last Stop. Latched on Stop."]
        #[inline(always)]
        pub fn set_pecsts_check(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "This status bit indicates if a PEC check error occurred in the transaction that occurred before the last Stop. Latched on Stop."]
        #[inline(always)]
        pub const fn pecsts_error(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "This status bit indicates if a PEC check error occurred in the transaction that occurred before the last Stop. Latched on Stop."]
        #[inline(always)]
        pub fn set_pecsts_error(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
    }
    impl Default for TargetPecsr {
        #[inline(always)]
        fn default() -> TargetPecsr {
            TargetPecsr(0)
        }
    }
    #[doc = "I2C Target Control Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tctr(pub u32);
    impl Tctr {
        #[doc = "Device Active. Setting this bit enables the Target functionality."]
        #[inline(always)]
        pub const fn active(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Device Active. Setting this bit enables the Target functionality."]
        #[inline(always)]
        pub fn set_active(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "General call response enable Modify only when UCSWRST = 1. 0b = Do not respond to a general call 1b = Respond to a general call."]
        #[inline(always)]
        pub const fn gencall(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "General call response enable Modify only when UCSWRST = 1. 0b = Do not respond to a general call 1b = Respond to a general call."]
        #[inline(always)]
        pub fn set_gencall(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Target Clock Stretch Enable."]
        #[inline(always)]
        pub const fn tclkstretch(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Target Clock Stretch Enable."]
        #[inline(always)]
        pub fn set_tclkstretch(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Tx Empty Interrupt on TREQ."]
        #[inline(always)]
        pub const fn txempty_on_treq(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Tx Empty Interrupt on TREQ."]
        #[inline(always)]
        pub fn set_txempty_on_treq(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Tx Trigger when Target FSM is in Tx Mode."]
        #[inline(always)]
        pub const fn txtrig_txmode(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Tx Trigger when Target FSM is in Tx Mode."]
        #[inline(always)]
        pub fn set_txtrig_txmode(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Tx transfer waits when stale data in Tx FIFO. This prevents stale bytes left in the TX FIFO from automatically being sent on the next I2C packet. Note: this should be used with TXEMPTY_ON_TREQ set to prevent the Target State Machine from waiting for TX FIFO data without an interrupt notification when the FIFO data is stale."]
        #[inline(always)]
        pub const fn txwait_stale_txfifo(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Tx transfer waits when stale data in Tx FIFO. This prevents stale bytes left in the TX FIFO from automatically being sent on the next I2C packet. Note: this should be used with TXEMPTY_ON_TREQ set to prevent the Target State Machine from waiting for TX FIFO data without an interrupt notification when the FIFO data is stale."]
        #[inline(always)]
        pub fn set_txwait_stale_txfifo(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "Rx full interrupt generated on RREQ condition as indicated in SSR."]
        #[inline(always)]
        pub const fn rxfull_on_rreq(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "Rx full interrupt generated on RREQ condition as indicated in SSR."]
        #[inline(always)]
        pub fn set_rxfull_on_rreq(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "Enable Default Host Address."]
        #[inline(always)]
        pub const fn en_defhostadr(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "Enable Default Host Address."]
        #[inline(always)]
        pub fn set_en_defhostadr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "Enable Alert Response Address."]
        #[inline(always)]
        pub const fn en_alrespadr(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "Enable Alert Response Address."]
        #[inline(always)]
        pub fn set_en_alrespadr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "Enable Deault device address."]
        #[inline(always)]
        pub const fn en_defdevadr(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "Enable Deault device address."]
        #[inline(always)]
        pub fn set_en_defdevadr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "Target Wakeup Enable."]
        #[inline(always)]
        pub const fn twuen(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "Target Wakeup Enable."]
        #[inline(always)]
        pub fn set_twuen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
    }
    impl Default for Tctr {
        #[inline(always)]
        fn default() -> Tctr {
            Tctr(0)
        }
    }
    #[doc = "I2C Target FIFO Control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tfifoctl(pub u32);
    impl Tfifoctl {
        #[doc = "TX FIFO Trigger Indicates at what fill level in the TX FIFO a trigger will be generated."]
        #[inline(always)]
        pub const fn txtrig(&self) -> super::vals::TfifoctlTxtrig {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::TfifoctlTxtrig::from_bits(val as u8)
        }
        #[doc = "TX FIFO Trigger Indicates at what fill level in the TX FIFO a trigger will be generated."]
        #[inline(always)]
        pub fn set_txtrig(&mut self, val: super::vals::TfifoctlTxtrig) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
        #[doc = "TX FIFO Flush Setting this bit will Flush the TX FIFO. Before clearing this bit to stop Flush the TXFIFOCNT should be checked to be 8 and indicating that the Flush has completed."]
        #[inline(always)]
        pub const fn txflush(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "TX FIFO Flush Setting this bit will Flush the TX FIFO. Before clearing this bit to stop Flush the TXFIFOCNT should be checked to be 8 and indicating that the Flush has completed."]
        #[inline(always)]
        pub fn set_txflush(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "RX FIFO Trigger Indicates at what fill level in the RX FIFO a trigger will be generated. Note: Programming RXTRIG to 0x0 has no effect since no data is present to transfer out of RX FIFO."]
        #[inline(always)]
        pub const fn rxtrig(&self) -> super::vals::TfifoctlRxtrig {
            let val = (self.0 >> 8usize) & 0x07;
            super::vals::TfifoctlRxtrig::from_bits(val as u8)
        }
        #[doc = "RX FIFO Trigger Indicates at what fill level in the RX FIFO a trigger will be generated. Note: Programming RXTRIG to 0x0 has no effect since no data is present to transfer out of RX FIFO."]
        #[inline(always)]
        pub fn set_rxtrig(&mut self, val: super::vals::TfifoctlRxtrig) {
            self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
        }
        #[doc = "RX FIFO Flush Setting this bit will Flush the RX FIFO. Before clearing this bit to stop Flush the RXFIFOCNT should be checked to be 0 and indicating that the Flush has completed."]
        #[inline(always)]
        pub const fn rxflush(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "RX FIFO Flush Setting this bit will Flush the RX FIFO. Before clearing this bit to stop Flush the RXFIFOCNT should be checked to be 0 and indicating that the Flush has completed."]
        #[inline(always)]
        pub fn set_rxflush(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
    }
    impl Default for Tfifoctl {
        #[inline(always)]
        fn default() -> Tfifoctl {
            Tfifoctl(0)
        }
    }
    #[doc = "I2C Target FIFO Status Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tfifosr(pub u32);
    impl Tfifosr {
        #[doc = "Number of Bytes which could be read from the RX FIFO."]
        #[inline(always)]
        pub const fn rxfifocnt(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x0f;
            val as u8
        }
        #[doc = "Number of Bytes which could be read from the RX FIFO."]
        #[inline(always)]
        pub fn set_rxfifocnt(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
        }
        #[doc = "RX FIFO Flush When this bit is set a Flush operation for the RX FIFO is active. Clear the RXFLUSH bit in the control register to stop."]
        #[inline(always)]
        pub const fn rxflush(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "RX FIFO Flush When this bit is set a Flush operation for the RX FIFO is active. Clear the RXFLUSH bit in the control register to stop."]
        #[inline(always)]
        pub fn set_rxflush(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "Number of Bytes which could be put into the TX FIFO."]
        #[inline(always)]
        pub const fn txfifocnt(&self) -> u8 {
            let val = (self.0 >> 8usize) & 0x0f;
            val as u8
        }
        #[doc = "Number of Bytes which could be put into the TX FIFO."]
        #[inline(always)]
        pub fn set_txfifocnt(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
        }
        #[doc = "TX FIFO Flush When this bit is set a Flush operation for the TX FIFO is active. Clear the TXFLUSH bit in the control register to stop."]
        #[inline(always)]
        pub const fn txflush(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "TX FIFO Flush When this bit is set a Flush operation for the TX FIFO is active. Clear the TXFLUSH bit in the control register to stop."]
        #[inline(always)]
        pub fn set_txflush(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
    }
    impl Default for Tfifosr {
        #[inline(always)]
        fn default() -> Tfifosr {
            Tfifosr(0)
        }
    }
    #[doc = "I2C Timeout Count Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TimeoutCnt(pub u32);
    impl TimeoutCnt {
        #[doc = "Timeout Count A Current Count: This field contains the upper 8 bits of a 12-bit current counter for timeout counter A."]
        #[inline(always)]
        pub const fn tcnta(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0xff;
            val as u8
        }
        #[doc = "Timeout Count A Current Count: This field contains the upper 8 bits of a 12-bit current counter for timeout counter A."]
        #[inline(always)]
        pub fn set_tcnta(&mut self, val: u8) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
        }
        #[doc = "Timeout Count B Current Count: This field contains the upper 8 bits of a 12-bit current counter for timeout counter B."]
        #[inline(always)]
        pub const fn tcntb(&self) -> u8 {
            let val = (self.0 >> 16usize) & 0xff;
            val as u8
        }
        #[doc = "Timeout Count B Current Count: This field contains the upper 8 bits of a 12-bit current counter for timeout counter B."]
        #[inline(always)]
        pub fn set_tcntb(&mut self, val: u8) {
            self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
        }
    }
    impl Default for TimeoutCnt {
        #[inline(always)]
        fn default() -> TimeoutCnt {
            TimeoutCnt(0)
        }
    }
    #[doc = "I2C Timeout Count Control Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TimeoutCtl(pub u32);
    impl TimeoutCtl {
        #[doc = "Timeout counter A load value Counter A is used for SCL low detection. This field contains the upper 8 bits of a 12-bit pre-load value for the Timeout A count. NOTE: The value of CNTLA must be greater than 1h. Each count is equal to 520 times the timeout period of functional clock. For example, with 8MHz functional clock and a 100KHz operating I2C clock, one timeout period will be equal to (1 / 8MHz) * 520 or 65 us."]
        #[inline(always)]
        pub const fn tcntla(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0xff;
            val as u8
        }
        #[doc = "Timeout counter A load value Counter A is used for SCL low detection. This field contains the upper 8 bits of a 12-bit pre-load value for the Timeout A count. NOTE: The value of CNTLA must be greater than 1h. Each count is equal to 520 times the timeout period of functional clock. For example, with 8MHz functional clock and a 100KHz operating I2C clock, one timeout period will be equal to (1 / 8MHz) * 520 or 65 us."]
        #[inline(always)]
        pub fn set_tcntla(&mut self, val: u8) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
        }
        #[doc = "Timeout Counter A Enable."]
        #[inline(always)]
        pub const fn tcntaen(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "Timeout Counter A Enable."]
        #[inline(always)]
        pub fn set_tcntaen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "Timeout Count B Load: Counter B is used for SCL High Detection. This field contains the upper 8 bits of a 12-bit pre-load value for the Timeout B count. NOTE: The value of CNTLB must be greater than 1h. Each count is equal to 1* clock period. For example, with 10MHz functional clock one timeout period will be equal to1*100ns."]
        #[inline(always)]
        pub const fn tcntlb(&self) -> u8 {
            let val = (self.0 >> 16usize) & 0xff;
            val as u8
        }
        #[doc = "Timeout Count B Load: Counter B is used for SCL High Detection. This field contains the upper 8 bits of a 12-bit pre-load value for the Timeout B count. NOTE: The value of CNTLB must be greater than 1h. Each count is equal to 1* clock period. For example, with 10MHz functional clock one timeout period will be equal to1*100ns."]
        #[inline(always)]
        pub fn set_tcntlb(&mut self, val: u8) {
            self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
        }
        #[doc = "Timeout Counter B Enable."]
        #[inline(always)]
        pub const fn tcntben(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "Timeout Counter B Enable."]
        #[inline(always)]
        pub fn set_tcntben(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for TimeoutCtl {
        #[inline(always)]
        fn default() -> TimeoutCtl {
            TimeoutCtl(0)
        }
    }
    #[doc = "I2C Target Own Address."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Toar(pub u32);
    impl Toar {
        #[doc = "I2C Target Own Address: This field specifies bits A9 through A0 of the Target address. In 7-bit addressing mode as selected by I2CSOAR.MODE bit, the top 3 bits are don't care."]
        #[inline(always)]
        pub const fn oar(&self) -> u16 {
            let val = (self.0 >> 0usize) & 0x03ff;
            val as u16
        }
        #[doc = "I2C Target Own Address: This field specifies bits A9 through A0 of the Target address. In 7-bit addressing mode as selected by I2CSOAR.MODE bit, the top 3 bits are don't care."]
        #[inline(always)]
        pub fn set_oar(&mut self, val: u16) {
            self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
        }
        #[doc = "I2C Target Own Address Enable."]
        #[inline(always)]
        pub const fn oaren(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "I2C Target Own Address Enable."]
        #[inline(always)]
        pub fn set_oaren(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "This bit selects the adressing mode to be used in Target mode. When 0, 7-bit addressing is used. When 1, 10-bit addressing is used."]
        #[inline(always)]
        pub const fn tmode(&self) -> super::vals::Mode {
            let val = (self.0 >> 15usize) & 0x01;
            super::vals::Mode::from_bits(val as u8)
        }
        #[doc = "This bit selects the adressing mode to be used in Target mode. When 0, 7-bit addressing is used. When 1, 10-bit addressing is used."]
        #[inline(always)]
        pub fn set_tmode(&mut self, val: super::vals::Mode) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
        }
    }
    impl Default for Toar {
        #[inline(always)]
        fn default() -> Toar {
            Toar(0)
        }
    }
    #[doc = "I2C Target Own Address 2."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Toar2(pub u32);
    impl Toar2 {
        #[doc = "I2C Target Own Address 2 This field specifies the alternate OAR2 address."]
        #[inline(always)]
        pub const fn oar2(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x7f;
            val as u8
        }
        #[doc = "I2C Target Own Address 2 This field specifies the alternate OAR2 address."]
        #[inline(always)]
        pub fn set_oar2(&mut self, val: u8) {
            self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
        }
        #[doc = "I2C Target Own Address 2 Enable."]
        #[inline(always)]
        pub const fn oar2en(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "I2C Target Own Address 2 Enable."]
        #[inline(always)]
        pub fn set_oar2en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "I2C Target Own Address 2 Mask: This field specifies bits A6 through A0 of the Target address. The bits with value 1 in SOAR2.OAR2_MASK field will make the corresponding incoming address bits to match by default regardless of the value inside SOAR2.OAR2 i.e. corresponding SOAR2.OAR2 bit is a dont care."]
        #[inline(always)]
        pub const fn oar2_mask(&self) -> u8 {
            let val = (self.0 >> 16usize) & 0x7f;
            val as u8
        }
        #[doc = "I2C Target Own Address 2 Mask: This field specifies bits A6 through A0 of the Target address. The bits with value 1 in SOAR2.OAR2_MASK field will make the corresponding incoming address bits to match by default regardless of the value inside SOAR2.OAR2 i.e. corresponding SOAR2.OAR2 bit is a dont care."]
        #[inline(always)]
        pub fn set_oar2_mask(&mut self, val: u8) {
            self.0 = (self.0 & !(0x7f << 16usize)) | (((val as u32) & 0x7f) << 16usize);
        }
    }
    impl Default for Toar2 {
        #[inline(always)]
        fn default() -> Toar2 {
            Toar2(0)
        }
    }
    #[doc = "I2C Target RXData."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Trxdata(pub u32);
    impl Trxdata {
        #[doc = "Received Data. This field contains the last received data."]
        #[inline(always)]
        pub const fn value(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0xff;
            val as u8
        }
        #[doc = "Received Data. This field contains the last received data."]
        #[inline(always)]
        pub fn set_value(&mut self, val: u8) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
        }
    }
    impl Default for Trxdata {
        #[inline(always)]
        fn default() -> Trxdata {
            Trxdata(0)
        }
    }
    #[doc = "I2C Target Status Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tsr(pub u32);
    impl Tsr {
        #[doc = "Receive Request."]
        #[inline(always)]
        pub const fn rreq(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Receive Request."]
        #[inline(always)]
        pub fn set_rreq(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Transmit Request."]
        #[inline(always)]
        pub const fn treq(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Transmit Request."]
        #[inline(always)]
        pub fn set_treq(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Target FSM is in Rx MODE."]
        #[inline(always)]
        pub const fn rxmode(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Target FSM is in Rx MODE."]
        #[inline(always)]
        pub fn set_rxmode(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "OAR2 Address Matched This bit gets reevaluated after every address comparison."]
        #[inline(always)]
        pub const fn oar2sel(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "OAR2 Address Matched This bit gets reevaluated after every address comparison."]
        #[inline(always)]
        pub fn set_oar2sel(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Quick Command Status Value Description: 0: The last transaction was a normal transaction or a transaction has not occurred. 1: The last transaction was a Quick Command transaction."]
        #[inline(always)]
        pub const fn qcmdst(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Quick Command Status Value Description: 0: The last transaction was a normal transaction or a transaction has not occurred. 1: The last transaction was a Quick Command transaction."]
        #[inline(always)]
        pub fn set_qcmdst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Quick Command Read / Write This bit only has meaning when the QCMDST bit is set. Value Description: 0: Quick command was a write 1: Quick command was a read."]
        #[inline(always)]
        pub const fn qcmdrw(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Quick Command Read / Write This bit only has meaning when the QCMDST bit is set. Value Description: 0: Quick command was a write 1: Quick command was a read."]
        #[inline(always)]
        pub fn set_qcmdrw(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "I2C bus is busy."]
        #[inline(always)]
        pub const fn busbsy(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "I2C bus is busy."]
        #[inline(always)]
        pub fn set_busbsy(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "Target FSM is in TX MODE."]
        #[inline(always)]
        pub const fn txmode(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "Target FSM is in TX MODE."]
        #[inline(always)]
        pub fn set_txmode(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "Stale Tx FIFO."]
        #[inline(always)]
        pub const fn stale_txfifo(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "Stale Tx FIFO."]
        #[inline(always)]
        pub fn set_stale_txfifo(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "Indicates the address for which Target address match happened."]
        #[inline(always)]
        pub const fn addrmatch(&self) -> u16 {
            let val = (self.0 >> 9usize) & 0x03ff;
            val as u16
        }
        #[doc = "Indicates the address for which Target address match happened."]
        #[inline(always)]
        pub fn set_addrmatch(&mut self, val: u16) {
            self.0 = (self.0 & !(0x03ff << 9usize)) | (((val as u32) & 0x03ff) << 9usize);
        }
    }
    impl Default for Tsr {
        #[inline(always)]
        fn default() -> Tsr {
            Tsr(0)
        }
    }
    #[doc = "I2C Target TXData."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ttxdata(pub u32);
    impl Ttxdata {
        #[doc = "Transmit Data This byte contains the data to be transferred during the next transaction."]
        #[inline(always)]
        pub const fn value(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0xff;
            val as u8
        }
        #[doc = "Transmit Data This byte contains the data to be transferred during the next transaction."]
        #[inline(always)]
        pub fn set_value(&mut self, val: u8) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
        }
    }
    impl Default for Ttxdata {
        #[inline(always)]
        fn default() -> Ttxdata {
            Ttxdata(0)
        }
    }
}
pub mod vals {
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Agfsel {
        #[doc = "Pulses shorter then 5ns length are filtered."]
        AGLIT_5 = 0x0,
        #[doc = "Pulses shorter then 10ns length are filtered."]
        AGLIT_10 = 0x01,
        #[doc = "Pulses shorter then 25ns length are filtered."]
        AGLIT_25 = 0x02,
        #[doc = "Pulses shorter then 50ns length are filtered."]
        AGLIT_50 = 0x03,
    }
    impl Agfsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Agfsel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Agfsel {
        #[inline(always)]
        fn from(val: u8) -> Agfsel {
            Agfsel::from_bits(val)
        }
    }
    impl From<Agfsel> for u8 {
        #[inline(always)]
        fn from(val: Agfsel) -> u8 {
            Agfsel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum CfifoctlRxtrig {
        #[doc = "Trigger when RX FIFO contains >= 1 byte."]
        LEVEL_1 = 0x0,
        #[doc = "Trigger when RX FIFO contains >= 2 byte."]
        LEVEL_2 = 0x01,
        #[doc = "Trigger when RX FIFO contains >= 3 byte."]
        LEVEL_3 = 0x02,
        #[doc = "Trigger when RX FIFO contains >= 4 byte."]
        LEVEL_4 = 0x03,
        #[doc = "Trigger when RX FIFO contains >= 5 byte."]
        LEVEL_5 = 0x04,
        #[doc = "Trigger when RX FIFO contains >= 6 byte."]
        LEVEL_6 = 0x05,
        #[doc = "Trigger when RX FIFO contains >= 7 byte."]
        LEVEL_7 = 0x06,
        #[doc = "Trigger when RX FIFO contains >= 8 byte."]
        LEVEL_8 = 0x07,
    }
    impl CfifoctlRxtrig {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> CfifoctlRxtrig {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for CfifoctlRxtrig {
        #[inline(always)]
        fn from(val: u8) -> CfifoctlRxtrig {
            CfifoctlRxtrig::from_bits(val)
        }
    }
    impl From<CfifoctlRxtrig> for u8 {
        #[inline(always)]
        fn from(val: CfifoctlRxtrig) -> u8 {
            CfifoctlRxtrig::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum CfifoctlTxtrig {
        #[doc = "Trigger when the TX FIFO is empty."]
        EMPTY = 0x0,
        #[doc = "Trigger when TX FIFO contains 1 byte."]
        LEVEL_1 = 0x01,
        #[doc = "Trigger when TX FIFO contains 2 byte."]
        LEVEL_2 = 0x02,
        #[doc = "Trigger when TX FIFO contains 3 byte."]
        LEVEL_3 = 0x03,
        #[doc = "Trigger when TX FIFO contains 4 byte."]
        LEVEL_4 = 0x04,
        #[doc = "Trigger when TX FIFO contains 5 byte."]
        LEVEL_5 = 0x05,
        #[doc = "Trigger when TX FIFO contains 6 byte."]
        LEVEL_6 = 0x06,
        #[doc = "Trigger when TX FIFO contains 7 byte."]
        LEVEL_7 = 0x07,
    }
    impl CfifoctlTxtrig {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> CfifoctlTxtrig {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for CfifoctlTxtrig {
        #[inline(always)]
        fn from(val: u8) -> CfifoctlTxtrig {
            CfifoctlTxtrig::from_bits(val)
        }
    }
    impl From<CfifoctlTxtrig> for u8 {
        #[inline(always)]
        fn from(val: CfifoctlTxtrig) -> u8 {
            CfifoctlTxtrig::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct ClkcfgKey(pub u8);
    impl ClkcfgKey {
        pub const KEY: Self = Self(0xa9);
    }
    impl ClkcfgKey {
        pub const fn from_bits(val: u8) -> ClkcfgKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for ClkcfgKey {
        #[inline(always)]
        fn from(val: u8) -> ClkcfgKey {
            ClkcfgKey::from_bits(val)
        }
    }
    impl From<ClkcfgKey> for u8 {
        #[inline(always)]
        fn from(val: ClkcfgKey) -> u8 {
            ClkcfgKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum CpuIntIidxStat {
        #[doc = "No interrupt pending."]
        NO_INTR = 0x0,
        #[doc = "Controller data received."]
        CRXDONEFG = 0x01,
        #[doc = "Controller data transmitted."]
        CTXDONEFG = 0x02,
        #[doc = "Controller receive FIFO Trigger Level."]
        CRXFIFOTRG = 0x03,
        #[doc = "Controller transmit FIFO Trigger level."]
        CTXFIFOTRG = 0x04,
        #[doc = "RX FIFO FULL Event/interrupt pending."]
        CRXFIFOFULL = 0x05,
        #[doc = "Transmit FIFO/Buffer Empty Event/interrupt pending."]
        CTX_EMPTY = 0x06,
        _RESERVED_7 = 0x07,
        #[doc = "Address/Data NACK."]
        CNACKFG = 0x08,
        #[doc = "Start Event."]
        CSTARTFG = 0x09,
        #[doc = "Stop Event."]
        CSTOPFG = 0x0a,
        #[doc = "Arbitration Lost."]
        CARBLOSTFG = 0x0b,
        #[doc = "DMA DONE on Channel TX."]
        CDMA_DONE_TX = 0x0c,
        #[doc = "DMA DONE on Channel RX."]
        CDMA_DONE_RX = 0x0d,
        #[doc = "Controller PEC Receive Error Event."]
        CPEC_RX_ERR = 0x0e,
        #[doc = "Timeout A Event."]
        TIMEOUTA = 0x0f,
        #[doc = "Timeout B Event."]
        TIMEOUTB = 0x10,
        #[doc = "Target Data Event."]
        TRXDONEFG = 0x11,
        #[doc = "Target Data Event."]
        TTXDONEFG = 0x12,
        #[doc = "Target receive FIFO Trigger Level."]
        TRXFIFOTRG = 0x13,
        #[doc = "Target transmit FIFO Trigger level."]
        TTXFIFOTRG = 0x14,
        #[doc = "RX FIFO FULL Event/interrupt pending."]
        TRXFIFOFULL = 0x15,
        #[doc = "Transmit FIFO/Buffer Empty Event/interrupt pending."]
        TTXEMPTY = 0x16,
        #[doc = "Start Event."]
        TSTARTFG = 0x17,
        #[doc = "Stop Event."]
        TSTOPFG = 0x18,
        #[doc = "General Call Event."]
        TGENCALL = 0x19,
        #[doc = "DMA DONE on Channel TX."]
        TDMA_DONE_TX = 0x1a,
        #[doc = "DMA DONE on Channel RX."]
        TDMA_DONE_RX = 0x1b,
        #[doc = "Target PEC receive error event."]
        TPEC_RX_ERR = 0x1c,
        #[doc = "Target TX FIFO underflow."]
        TTX_UNFL = 0x1d,
        #[doc = "Target RX FIFO overflow event."]
        TRX_OVFL = 0x1e,
        #[doc = "Target arbitration lost event."]
        TARBLOST = 0x1f,
        #[doc = "Interrupt overflow event."]
        INTR_OVFL = 0x20,
        _RESERVED_21 = 0x21,
        _RESERVED_22 = 0x22,
        _RESERVED_23 = 0x23,
        _RESERVED_24 = 0x24,
        _RESERVED_25 = 0x25,
        _RESERVED_26 = 0x26,
        _RESERVED_27 = 0x27,
        _RESERVED_28 = 0x28,
        _RESERVED_29 = 0x29,
        _RESERVED_2a = 0x2a,
        _RESERVED_2b = 0x2b,
        _RESERVED_2c = 0x2c,
        _RESERVED_2d = 0x2d,
        _RESERVED_2e = 0x2e,
        _RESERVED_2f = 0x2f,
        _RESERVED_30 = 0x30,
        _RESERVED_31 = 0x31,
        _RESERVED_32 = 0x32,
        _RESERVED_33 = 0x33,
        _RESERVED_34 = 0x34,
        _RESERVED_35 = 0x35,
        _RESERVED_36 = 0x36,
        _RESERVED_37 = 0x37,
        _RESERVED_38 = 0x38,
        _RESERVED_39 = 0x39,
        _RESERVED_3a = 0x3a,
        _RESERVED_3b = 0x3b,
        _RESERVED_3c = 0x3c,
        _RESERVED_3d = 0x3d,
        _RESERVED_3e = 0x3e,
        _RESERVED_3f = 0x3f,
        _RESERVED_40 = 0x40,
        _RESERVED_41 = 0x41,
        _RESERVED_42 = 0x42,
        _RESERVED_43 = 0x43,
        _RESERVED_44 = 0x44,
        _RESERVED_45 = 0x45,
        _RESERVED_46 = 0x46,
        _RESERVED_47 = 0x47,
        _RESERVED_48 = 0x48,
        _RESERVED_49 = 0x49,
        _RESERVED_4a = 0x4a,
        _RESERVED_4b = 0x4b,
        _RESERVED_4c = 0x4c,
        _RESERVED_4d = 0x4d,
        _RESERVED_4e = 0x4e,
        _RESERVED_4f = 0x4f,
        _RESERVED_50 = 0x50,
        _RESERVED_51 = 0x51,
        _RESERVED_52 = 0x52,
        _RESERVED_53 = 0x53,
        _RESERVED_54 = 0x54,
        _RESERVED_55 = 0x55,
        _RESERVED_56 = 0x56,
        _RESERVED_57 = 0x57,
        _RESERVED_58 = 0x58,
        _RESERVED_59 = 0x59,
        _RESERVED_5a = 0x5a,
        _RESERVED_5b = 0x5b,
        _RESERVED_5c = 0x5c,
        _RESERVED_5d = 0x5d,
        _RESERVED_5e = 0x5e,
        _RESERVED_5f = 0x5f,
        _RESERVED_60 = 0x60,
        _RESERVED_61 = 0x61,
        _RESERVED_62 = 0x62,
        _RESERVED_63 = 0x63,
        _RESERVED_64 = 0x64,
        _RESERVED_65 = 0x65,
        _RESERVED_66 = 0x66,
        _RESERVED_67 = 0x67,
        _RESERVED_68 = 0x68,
        _RESERVED_69 = 0x69,
        _RESERVED_6a = 0x6a,
        _RESERVED_6b = 0x6b,
        _RESERVED_6c = 0x6c,
        _RESERVED_6d = 0x6d,
        _RESERVED_6e = 0x6e,
        _RESERVED_6f = 0x6f,
        _RESERVED_70 = 0x70,
        _RESERVED_71 = 0x71,
        _RESERVED_72 = 0x72,
        _RESERVED_73 = 0x73,
        _RESERVED_74 = 0x74,
        _RESERVED_75 = 0x75,
        _RESERVED_76 = 0x76,
        _RESERVED_77 = 0x77,
        _RESERVED_78 = 0x78,
        _RESERVED_79 = 0x79,
        _RESERVED_7a = 0x7a,
        _RESERVED_7b = 0x7b,
        _RESERVED_7c = 0x7c,
        _RESERVED_7d = 0x7d,
        _RESERVED_7e = 0x7e,
        _RESERVED_7f = 0x7f,
        _RESERVED_80 = 0x80,
        _RESERVED_81 = 0x81,
        _RESERVED_82 = 0x82,
        _RESERVED_83 = 0x83,
        _RESERVED_84 = 0x84,
        _RESERVED_85 = 0x85,
        _RESERVED_86 = 0x86,
        _RESERVED_87 = 0x87,
        _RESERVED_88 = 0x88,
        _RESERVED_89 = 0x89,
        _RESERVED_8a = 0x8a,
        _RESERVED_8b = 0x8b,
        _RESERVED_8c = 0x8c,
        _RESERVED_8d = 0x8d,
        _RESERVED_8e = 0x8e,
        _RESERVED_8f = 0x8f,
        _RESERVED_90 = 0x90,
        _RESERVED_91 = 0x91,
        _RESERVED_92 = 0x92,
        _RESERVED_93 = 0x93,
        _RESERVED_94 = 0x94,
        _RESERVED_95 = 0x95,
        _RESERVED_96 = 0x96,
        _RESERVED_97 = 0x97,
        _RESERVED_98 = 0x98,
        _RESERVED_99 = 0x99,
        _RESERVED_9a = 0x9a,
        _RESERVED_9b = 0x9b,
        _RESERVED_9c = 0x9c,
        _RESERVED_9d = 0x9d,
        _RESERVED_9e = 0x9e,
        _RESERVED_9f = 0x9f,
        _RESERVED_a0 = 0xa0,
        _RESERVED_a1 = 0xa1,
        _RESERVED_a2 = 0xa2,
        _RESERVED_a3 = 0xa3,
        _RESERVED_a4 = 0xa4,
        _RESERVED_a5 = 0xa5,
        _RESERVED_a6 = 0xa6,
        _RESERVED_a7 = 0xa7,
        _RESERVED_a8 = 0xa8,
        _RESERVED_a9 = 0xa9,
        _RESERVED_aa = 0xaa,
        _RESERVED_ab = 0xab,
        _RESERVED_ac = 0xac,
        _RESERVED_ad = 0xad,
        _RESERVED_ae = 0xae,
        _RESERVED_af = 0xaf,
        _RESERVED_b0 = 0xb0,
        _RESERVED_b1 = 0xb1,
        _RESERVED_b2 = 0xb2,
        _RESERVED_b3 = 0xb3,
        _RESERVED_b4 = 0xb4,
        _RESERVED_b5 = 0xb5,
        _RESERVED_b6 = 0xb6,
        _RESERVED_b7 = 0xb7,
        _RESERVED_b8 = 0xb8,
        _RESERVED_b9 = 0xb9,
        _RESERVED_ba = 0xba,
        _RESERVED_bb = 0xbb,
        _RESERVED_bc = 0xbc,
        _RESERVED_bd = 0xbd,
        _RESERVED_be = 0xbe,
        _RESERVED_bf = 0xbf,
        _RESERVED_c0 = 0xc0,
        _RESERVED_c1 = 0xc1,
        _RESERVED_c2 = 0xc2,
        _RESERVED_c3 = 0xc3,
        _RESERVED_c4 = 0xc4,
        _RESERVED_c5 = 0xc5,
        _RESERVED_c6 = 0xc6,
        _RESERVED_c7 = 0xc7,
        _RESERVED_c8 = 0xc8,
        _RESERVED_c9 = 0xc9,
        _RESERVED_ca = 0xca,
        _RESERVED_cb = 0xcb,
        _RESERVED_cc = 0xcc,
        _RESERVED_cd = 0xcd,
        _RESERVED_ce = 0xce,
        _RESERVED_cf = 0xcf,
        _RESERVED_d0 = 0xd0,
        _RESERVED_d1 = 0xd1,
        _RESERVED_d2 = 0xd2,
        _RESERVED_d3 = 0xd3,
        _RESERVED_d4 = 0xd4,
        _RESERVED_d5 = 0xd5,
        _RESERVED_d6 = 0xd6,
        _RESERVED_d7 = 0xd7,
        _RESERVED_d8 = 0xd8,
        _RESERVED_d9 = 0xd9,
        _RESERVED_da = 0xda,
        _RESERVED_db = 0xdb,
        _RESERVED_dc = 0xdc,
        _RESERVED_dd = 0xdd,
        _RESERVED_de = 0xde,
        _RESERVED_df = 0xdf,
        _RESERVED_e0 = 0xe0,
        _RESERVED_e1 = 0xe1,
        _RESERVED_e2 = 0xe2,
        _RESERVED_e3 = 0xe3,
        _RESERVED_e4 = 0xe4,
        _RESERVED_e5 = 0xe5,
        _RESERVED_e6 = 0xe6,
        _RESERVED_e7 = 0xe7,
        _RESERVED_e8 = 0xe8,
        _RESERVED_e9 = 0xe9,
        _RESERVED_ea = 0xea,
        _RESERVED_eb = 0xeb,
        _RESERVED_ec = 0xec,
        _RESERVED_ed = 0xed,
        _RESERVED_ee = 0xee,
        _RESERVED_ef = 0xef,
        _RESERVED_f0 = 0xf0,
        _RESERVED_f1 = 0xf1,
        _RESERVED_f2 = 0xf2,
        _RESERVED_f3 = 0xf3,
        _RESERVED_f4 = 0xf4,
        _RESERVED_f5 = 0xf5,
        _RESERVED_f6 = 0xf6,
        _RESERVED_f7 = 0xf7,
        _RESERVED_f8 = 0xf8,
        _RESERVED_f9 = 0xf9,
        _RESERVED_fa = 0xfa,
        _RESERVED_fb = 0xfb,
        _RESERVED_fc = 0xfc,
        _RESERVED_fd = 0xfd,
        _RESERVED_fe = 0xfe,
        _RESERVED_ff = 0xff,
    }
    impl CpuIntIidxStat {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> CpuIntIidxStat {
            unsafe { core::mem::transmute(val & 0xff) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for CpuIntIidxStat {
        #[inline(always)]
        fn from(val: u8) -> CpuIntIidxStat {
            CpuIntIidxStat::from_bits(val)
        }
    }
    impl From<CpuIntIidxStat> for u8 {
        #[inline(always)]
        fn from(val: CpuIntIidxStat) -> u8 {
            CpuIntIidxStat::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Dgfsel {
        #[doc = "Bypass."]
        DISABLED = 0x0,
        #[doc = "1 clock."]
        CLK_1 = 0x01,
        #[doc = "2 clocks."]
        CLK_2 = 0x02,
        #[doc = "3 clocks."]
        CLK_3 = 0x03,
        #[doc = "4 clocks."]
        CLK_4 = 0x04,
        #[doc = "8 clocks."]
        CLK_8 = 0x05,
        #[doc = "16 clocks."]
        CLK_16 = 0x06,
        #[doc = "31 clocks."]
        CLK_31 = 0x07,
    }
    impl Dgfsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Dgfsel {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Dgfsel {
        #[inline(always)]
        fn from(val: u8) -> Dgfsel {
            Dgfsel::from_bits(val)
        }
    }
    impl From<Dgfsel> for u8 {
        #[inline(always)]
        fn from(val: Dgfsel) -> u8 {
            Dgfsel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Dir {
        #[doc = "The Controller is in transmit mode."]
        TRANSMIT = 0x0,
        #[doc = "The Controller is in receive mode."]
        RECEIVE = 0x01,
    }
    impl Dir {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Dir {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Dir {
        #[inline(always)]
        fn from(val: u8) -> Dir {
            Dir::from_bits(val)
        }
    }
    impl From<Dir> for u8 {
        #[inline(always)]
        fn from(val: Dir) -> u8 {
            Dir::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct DmaTrigIidxStat(pub u8);
    impl DmaTrigIidxStat {
        #[doc = "No interrupt pending."]
        pub const NO_INTR: Self = Self(0x0);
        #[doc = "Controller receive FIFO Trigger Level."]
        pub const CRXFIFOTRG: Self = Self(0x01);
        #[doc = "Controller transmit FIFO Trigger level."]
        pub const CTXFIFOTRG: Self = Self(0x02);
        #[doc = "Target receive FIFO Trigger Level."]
        pub const TRXFIFOTRG: Self = Self(0x03);
        #[doc = "Target transmit FIFO Trigger level."]
        pub const TTXFIFOTRG: Self = Self(0x04);
    }
    impl DmaTrigIidxStat {
        pub const fn from_bits(val: u8) -> DmaTrigIidxStat {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for DmaTrigIidxStat {
        #[inline(always)]
        fn from(val: u8) -> DmaTrigIidxStat {
            DmaTrigIidxStat::from_bits(val)
        }
    }
    impl From<DmaTrigIidxStat> for u8 {
        #[inline(always)]
        fn from(val: DmaTrigIidxStat) -> u8 {
            DmaTrigIidxStat::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum EvtCfg {
        #[doc = "The interrupt or event line is disabled."]
        DISABLE = 0x0,
        #[doc = "The interrupt or event line is in software mode. Software must clear the RIS."]
        SOFTWARE = 0x01,
        #[doc = "The interrupt or event line is in hardware mode. The hardware (another module) clears automatically the associated RIS flag."]
        HARDWARE = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl EvtCfg {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> EvtCfg {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for EvtCfg {
        #[inline(always)]
        fn from(val: u8) -> EvtCfg {
            EvtCfg::from_bits(val)
        }
    }
    impl From<EvtCfg> for u8 {
        #[inline(always)]
        fn from(val: EvtCfg) -> u8 {
            EvtCfg::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Mode {
        #[doc = "7-bit addressing mode."]
        MODE7 = 0x0,
        #[doc = "10-bit addressing mode."]
        MODE10 = 0x01,
    }
    impl Mode {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Mode {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Mode {
        #[inline(always)]
        fn from(val: u8) -> Mode {
            Mode::from_bits(val)
        }
    }
    impl From<Mode> for u8 {
        #[inline(always)]
        fn from(val: Mode) -> u8 {
            Mode::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct PwrenKey(pub u8);
    impl PwrenKey {
        pub const KEY: Self = Self(0x26);
    }
    impl PwrenKey {
        pub const fn from_bits(val: u8) -> PwrenKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for PwrenKey {
        #[inline(always)]
        fn from(val: u8) -> PwrenKey {
            PwrenKey::from_bits(val)
        }
    }
    impl From<PwrenKey> for u8 {
        #[inline(always)]
        fn from(val: PwrenKey) -> u8 {
            PwrenKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Ratio {
        #[doc = "Do not divide clock source."]
        DIV_BY_1 = 0x0,
        #[doc = "Divide clock source by 2."]
        DIV_BY_2 = 0x01,
        #[doc = "Divide clock source by 3."]
        DIV_BY_3 = 0x02,
        #[doc = "Divide clock source by 4."]
        DIV_BY_4 = 0x03,
        #[doc = "Divide clock source by 5."]
        DIV_BY_5 = 0x04,
        #[doc = "Divide clock source by 6."]
        DIV_BY_6 = 0x05,
        #[doc = "Divide clock source by 7."]
        DIV_BY_7 = 0x06,
        #[doc = "Divide clock source by 8."]
        DIV_BY_8 = 0x07,
    }
    impl Ratio {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Ratio {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Ratio {
        #[inline(always)]
        fn from(val: u8) -> Ratio {
            Ratio::from_bits(val)
        }
    }
    impl From<Ratio> for u8 {
        #[inline(always)]
        fn from(val: Ratio) -> u8 {
            Ratio::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct ResetKey(pub u8);
    impl ResetKey {
        pub const KEY: Self = Self(0xb1);
    }
    impl ResetKey {
        pub const fn from_bits(val: u8) -> ResetKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for ResetKey {
        #[inline(always)]
        fn from(val: u8) -> ResetKey {
            ResetKey::from_bits(val)
        }
    }
    impl From<ResetKey> for u8 {
        #[inline(always)]
        fn from(val: ResetKey) -> u8 {
            ResetKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Soft {
        #[doc = "The peripheral will halt immediately, even if the resultant state will result in corruption if the system is restarted."]
        IMMEDIATE = 0x0,
        #[doc = "The peripheral blocks the debug freeze until it has reached a boundary where it can resume without corruption."]
        DELAYED = 0x01,
    }
    impl Soft {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Soft {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Soft {
        #[inline(always)]
        fn from(val: u8) -> Soft {
            Soft::from_bits(val)
        }
    }
    impl From<Soft> for u8 {
        #[inline(always)]
        fn from(val: Soft) -> u8 {
            Soft::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum TfifoctlRxtrig {
        _RESERVED_0 = 0x0,
        _RESERVED_1 = 0x01,
        _RESERVED_2 = 0x02,
        _RESERVED_3 = 0x03,
        #[doc = "Trigger when RX FIFO contains >= 5 byte."]
        LEVEL_5 = 0x04,
        #[doc = "Trigger when RX FIFO contains >= 6 byte."]
        LEVEL_6 = 0x05,
        #[doc = "Trigger when RX FIFO contains >= 7 byte."]
        LEVEL_7 = 0x06,
        #[doc = "Trigger when RX FIFO contains >= 8 byte."]
        LEVEL_8 = 0x07,
    }
    impl TfifoctlRxtrig {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> TfifoctlRxtrig {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for TfifoctlRxtrig {
        #[inline(always)]
        fn from(val: u8) -> TfifoctlRxtrig {
            TfifoctlRxtrig::from_bits(val)
        }
    }
    impl From<TfifoctlRxtrig> for u8 {
        #[inline(always)]
        fn from(val: TfifoctlRxtrig) -> u8 {
            TfifoctlRxtrig::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum TfifoctlTxtrig {
        _RESERVED_0 = 0x0,
        _RESERVED_1 = 0x01,
        _RESERVED_2 = 0x02,
        _RESERVED_3 = 0x03,
        #[doc = "Trigger when TX FIFO contains 4 byte."]
        LEVEL_4 = 0x04,
        #[doc = "Trigger when TX FIFO contains 5 byte."]
        LEVEL_5 = 0x05,
        #[doc = "Trigger when TX FIFO contains 6 byte."]
        LEVEL_6 = 0x06,
        #[doc = "Trigger when TX FIFO contains 7 byte."]
        LEVEL_7 = 0x07,
    }
    impl TfifoctlTxtrig {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> TfifoctlTxtrig {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for TfifoctlTxtrig {
        #[inline(always)]
        fn from(val: u8) -> TfifoctlTxtrig {
            TfifoctlTxtrig::from_bits(val)
        }
    }
    impl From<TfifoctlTxtrig> for u8 {
        #[inline(always)]
        fn from(val: TfifoctlTxtrig) -> u8 {
            TfifoctlTxtrig::to_bits(val)
        }
    }
}
