// This file is autogenerated by mspm0-metapac-gen: do not edit by hand.
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::identity_op)]
#![allow(clippy::unnecessary_cast)]
#![allow(clippy::erasing_op)]

#[derive(Copy, Clone, Eq, PartialEq)]
pub struct CpuInt {
    ptr: *mut u8,
}
unsafe impl Send for CpuInt {}
unsafe impl Sync for CpuInt {}
impl CpuInt {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Interrupt index."]
    #[inline(always)]
    pub const fn iidx(self) -> crate::common::Reg<regs::CpuIntIidx, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "Interrupt mask."]
    #[inline(always)]
    pub const fn imask(self) -> crate::common::Reg<regs::CpuInt, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
    }
    #[doc = "Raw interrupt status."]
    #[inline(always)]
    pub const fn ris(self) -> crate::common::Reg<regs::CpuInt, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
    }
    #[doc = "Masked interrupt status."]
    #[inline(always)]
    pub const fn mis(self) -> crate::common::Reg<regs::CpuInt, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
    }
    #[doc = "Interrupt set."]
    #[inline(always)]
    pub const fn iset(self) -> crate::common::Reg<regs::CpuInt, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
    }
    #[doc = "Interrupt clear."]
    #[inline(always)]
    pub const fn iclr(self) -> crate::common::Reg<regs::CpuInt, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
    }
}
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct DmaTrigRx {
    ptr: *mut u8,
}
unsafe impl Send for DmaTrigRx {}
unsafe impl Sync for DmaTrigRx {}
impl DmaTrigRx {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Interrupt index."]
    #[inline(always)]
    pub const fn iidx(self) -> crate::common::Reg<regs::DmaTrigRxIidx, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "Interrupt mask."]
    #[inline(always)]
    pub const fn imask(self) -> crate::common::Reg<regs::DmaTrigRx, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
    }
    #[doc = "Raw interrupt status."]
    #[inline(always)]
    pub const fn ris(self) -> crate::common::Reg<regs::DmaTrigRx, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
    }
    #[doc = "Masked interrupt status."]
    #[inline(always)]
    pub const fn mis(self) -> crate::common::Reg<regs::DmaTrigRx, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
    }
    #[doc = "Interrupt set."]
    #[inline(always)]
    pub const fn iset(self) -> crate::common::Reg<regs::DmaTrigRx, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
    }
    #[doc = "Interrupt clear."]
    #[inline(always)]
    pub const fn iclr(self) -> crate::common::Reg<regs::DmaTrigRx, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
    }
}
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct DmaTrigTx {
    ptr: *mut u8,
}
unsafe impl Send for DmaTrigTx {}
unsafe impl Sync for DmaTrigTx {}
impl DmaTrigTx {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Interrupt index."]
    #[inline(always)]
    pub const fn iidx(self) -> crate::common::Reg<regs::DmaTrigTxIidx, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "Interrupt mask."]
    #[inline(always)]
    pub const fn imask(self) -> crate::common::Reg<regs::DmaTrigTx, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
    }
    #[doc = "Raw interrupt status."]
    #[inline(always)]
    pub const fn ris(self) -> crate::common::Reg<regs::DmaTrigTx, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
    }
    #[doc = "Masked interrupt status."]
    #[inline(always)]
    pub const fn mis(self) -> crate::common::Reg<regs::DmaTrigTx, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
    }
    #[doc = "Interrupt set."]
    #[inline(always)]
    pub const fn iset(self) -> crate::common::Reg<regs::DmaTrigTx, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
    }
    #[doc = "Interrupt clear."]
    #[inline(always)]
    pub const fn iclr(self) -> crate::common::Reg<regs::DmaTrigTx, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
    }
}
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Gprcm {
    ptr: *mut u8,
}
unsafe impl Send for Gprcm {}
unsafe impl Sync for Gprcm {}
impl Gprcm {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Power enable."]
    #[inline(always)]
    pub const fn pwren(self) -> crate::common::Reg<regs::Pwren, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "Reset Control."]
    #[inline(always)]
    pub const fn rstctl(self) -> crate::common::Reg<regs::Rstctl, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
    }
    #[doc = "Peripheral Clock Configuration Register."]
    #[inline(always)]
    pub const fn clkcfg(self) -> crate::common::Reg<regs::Clkcfg, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
    }
    #[doc = "Status Register."]
    #[inline(always)]
    pub const fn gprcm_stat(self) -> crate::common::Reg<regs::GprcmStat, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
    }
}
#[doc = "PERIPHERALREGION."]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Uart {
    ptr: *mut u8,
}
unsafe impl Send for Uart {}
unsafe impl Sync for Uart {}
impl Uart {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[inline(always)]
    pub const fn gprcm(self, n: usize) -> Gprcm {
        assert!(n < 1usize);
        unsafe { Gprcm::from_ptr(self.ptr.add(0x0800usize + n * 24usize) as _) }
    }
    #[doc = "Clock Divider."]
    #[inline(always)]
    pub const fn clkdiv(self) -> crate::common::Reg<regs::Clkdiv, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1000usize) as _) }
    }
    #[doc = "Clock Select for Ultra Low Power peripherals."]
    #[inline(always)]
    pub const fn clksel(self) -> crate::common::Reg<regs::Clksel, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1008usize) as _) }
    }
    #[doc = "Peripheral Debug Control."]
    #[inline(always)]
    pub const fn pdbgctl(self) -> crate::common::Reg<regs::Pdbgctl, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1018usize) as _) }
    }
    #[inline(always)]
    pub const fn cpu_int(self, n: usize) -> CpuInt {
        assert!(n < 1usize);
        unsafe { CpuInt::from_ptr(self.ptr.add(0x1020usize + n * 44usize) as _) }
    }
    #[inline(always)]
    pub const fn dma_trig_rx(self, n: usize) -> DmaTrigRx {
        assert!(n < 1usize);
        unsafe { DmaTrigRx::from_ptr(self.ptr.add(0x1050usize + n * 44usize) as _) }
    }
    #[inline(always)]
    pub const fn dma_trig_tx(self, n: usize) -> DmaTrigTx {
        assert!(n < 1usize);
        unsafe { DmaTrigTx::from_ptr(self.ptr.add(0x1080usize + n * 44usize) as _) }
    }
    #[doc = "Event Mode."]
    #[inline(always)]
    pub const fn evt_mode(self) -> crate::common::Reg<regs::EvtMode, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10e0usize) as _) }
    }
    #[doc = "Interrupt control register."]
    #[inline(always)]
    pub const fn intctl(self) -> crate::common::Reg<regs::Intctl, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10e4usize) as _) }
    }
    #[doc = "UART Control Register 0."]
    #[inline(always)]
    pub const fn ctl0(self) -> crate::common::Reg<regs::Ctl0, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1100usize) as _) }
    }
    #[doc = "UART Line Control Register."]
    #[inline(always)]
    pub const fn lcrh(self) -> crate::common::Reg<regs::Lcrh, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1104usize) as _) }
    }
    #[doc = "UART Status Register."]
    #[inline(always)]
    pub const fn stat(self) -> crate::common::Reg<regs::Stat, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1108usize) as _) }
    }
    #[doc = "UART Interrupt FIFO Level Select Register."]
    #[inline(always)]
    pub const fn ifls(self) -> crate::common::Reg<regs::Ifls, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x110cusize) as _) }
    }
    #[doc = "UART Integer Baud-Rate Divisor Register."]
    #[inline(always)]
    pub const fn ibrd(self) -> crate::common::Reg<regs::Ibrd, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1110usize) as _) }
    }
    #[doc = "UART Fractional Baud-Rate Divisor Register."]
    #[inline(always)]
    pub const fn fbrd(self) -> crate::common::Reg<regs::Fbrd, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1114usize) as _) }
    }
    #[doc = "Glitch Filter Control."]
    #[inline(always)]
    pub const fn gfctl(self) -> crate::common::Reg<regs::Gfctl, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1118usize) as _) }
    }
    #[doc = "UART Transmit Data Register."]
    #[inline(always)]
    pub const fn txdata(self) -> crate::common::Reg<regs::Txdata, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1120usize) as _) }
    }
    #[doc = "UART Receive Data Register."]
    #[inline(always)]
    pub const fn rxdata(self) -> crate::common::Reg<regs::Rxdata, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1124usize) as _) }
    }
    #[doc = "UART LIN Mode Counter Register."]
    #[inline(always)]
    pub const fn lincnt(self) -> crate::common::Reg<regs::Lincnt, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1130usize) as _) }
    }
    #[doc = "UART LIN Mode Control Register."]
    #[inline(always)]
    pub const fn linctl(self) -> crate::common::Reg<regs::Linctl, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1134usize) as _) }
    }
    #[doc = "UART LIN Mode Capture 0 Register."]
    #[inline(always)]
    pub const fn linc(self, n: usize) -> crate::common::Reg<regs::Linc, crate::common::RW> {
        assert!(n < 2usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1138usize + n * 4usize) as _) }
    }
    #[doc = "eUSCI_Ax IrDA Control Word Register."]
    #[inline(always)]
    pub const fn irctl(self) -> crate::common::Reg<regs::Irctl, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1140usize) as _) }
    }
    #[doc = "Self Address Mask Register."]
    #[inline(always)]
    pub const fn amask(self) -> crate::common::Reg<regs::Amask, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1148usize) as _) }
    }
    #[doc = "Self Address Register."]
    #[inline(always)]
    pub const fn addr(self) -> crate::common::Reg<regs::Addr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x114cusize) as _) }
    }
    #[doc = "Clock Divider."]
    #[inline(always)]
    pub const fn clkdiv2(self) -> crate::common::Reg<regs::Clkdiv, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1160usize) as _) }
    }
}
pub mod regs {
    #[doc = "Self Address Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Addr(pub u32);
    impl Addr {
        #[doc = "Self Address for 9-Bit Mode This field contains the address that should be matched when UARTxAMASK is FFh."]
        #[inline(always)]
        pub const fn addr(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0xff;
            val as u8
        }
        #[doc = "Self Address for 9-Bit Mode This field contains the address that should be matched when UARTxAMASK is FFh."]
        #[inline(always)]
        pub fn set_addr(&mut self, val: u8) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
        }
    }
    impl Default for Addr {
        #[inline(always)]
        fn default() -> Addr {
            Addr(0)
        }
    }
    #[doc = "Self Address Mask Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Amask(pub u32);
    impl Amask {
        #[doc = "Self Address Mask for 9-Bit Mode This field contains the address mask that creates a set of addresses that should be matched. A 0 bit in the MSK bitfield configures, that the corresponding bit in the ADDR bitfield of the UARTxADDR register is don't care. A 1 bit in the MSK bitfield configures, that the corresponding bit in the ADDR bitfield of the UARTxADDR register must match."]
        #[inline(always)]
        pub const fn msk(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0xff;
            val as u8
        }
        #[doc = "Self Address Mask for 9-Bit Mode This field contains the address mask that creates a set of addresses that should be matched. A 0 bit in the MSK bitfield configures, that the corresponding bit in the ADDR bitfield of the UARTxADDR register is don't care. A 1 bit in the MSK bitfield configures, that the corresponding bit in the ADDR bitfield of the UARTxADDR register must match."]
        #[inline(always)]
        pub fn set_msk(&mut self, val: u8) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
        }
    }
    impl Default for Amask {
        #[inline(always)]
        fn default() -> Amask {
            Amask(0)
        }
    }
    #[doc = "Peripheral Clock Configuration Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Clkcfg(pub u32);
    impl Clkcfg {
        #[doc = "Async Clock Request is blocked from starting SYSOSC or forcing bus clock to 32MHz."]
        #[inline(always)]
        pub const fn blockasync(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "Async Clock Request is blocked from starting SYSOSC or forcing bus clock to 32MHz."]
        #[inline(always)]
        pub fn set_blockasync(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "KEY to Allow State Change A9h = KEY to allow write access to this register"]
        #[inline(always)]
        pub const fn key(&self) -> super::vals::ClkcfgKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::ClkcfgKey::from_bits(val as u8)
        }
        #[doc = "KEY to Allow State Change A9h = KEY to allow write access to this register"]
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::ClkcfgKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Clkcfg {
        #[inline(always)]
        fn default() -> Clkcfg {
            Clkcfg(0)
        }
    }
    #[doc = "Clock Divider."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Clkdiv(pub u32);
    impl Clkdiv {
        #[doc = "Selects divide ratio of module clock."]
        #[inline(always)]
        pub const fn ratio(&self) -> super::vals::Clkdiv {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::Clkdiv::from_bits(val as u8)
        }
        #[doc = "Selects divide ratio of module clock."]
        #[inline(always)]
        pub fn set_ratio(&mut self, val: super::vals::Clkdiv) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
    }
    impl Default for Clkdiv {
        #[inline(always)]
        fn default() -> Clkdiv {
            Clkdiv(0)
        }
    }
    #[doc = "Clock Select for Ultra Low Power peripherals."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Clksel(pub u32);
    impl Clksel {
        #[doc = "Selects LFCLK as clock source if enabled."]
        #[inline(always)]
        pub const fn lfclk_sel(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Selects LFCLK as clock source if enabled."]
        #[inline(always)]
        pub fn set_lfclk_sel(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Selects MFCLK as clock source if enabled."]
        #[inline(always)]
        pub const fn mfclk_sel(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Selects MFCLK as clock source if enabled."]
        #[inline(always)]
        pub fn set_mfclk_sel(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Selects BUS CLK as clock source if enabled."]
        #[inline(always)]
        pub const fn busclk_sel(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Selects BUS CLK as clock source if enabled."]
        #[inline(always)]
        pub fn set_busclk_sel(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
    }
    impl Default for Clksel {
        #[inline(always)]
        fn default() -> Clksel {
            Clksel(0)
        }
    }
    #[doc = "Interrupt clear."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct CpuInt(pub u32);
    impl CpuInt {
        #[doc = "Clear UARTOUT Receive Time-Out Interrupt."]
        #[inline(always)]
        pub const fn rtout(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Clear UARTOUT Receive Time-Out Interrupt."]
        #[inline(always)]
        pub fn set_rtout(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Clear UART Framing Error Interrupt."]
        #[inline(always)]
        pub const fn frmerr(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Clear UART Framing Error Interrupt."]
        #[inline(always)]
        pub fn set_frmerr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Clear UART Parity Error Interrupt."]
        #[inline(always)]
        pub const fn parerr(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Clear UART Parity Error Interrupt."]
        #[inline(always)]
        pub fn set_parerr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Clear UART Break Error Interrupt."]
        #[inline(always)]
        pub const fn brkerr(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Clear UART Break Error Interrupt."]
        #[inline(always)]
        pub fn set_brkerr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Clear UART Receive Overrun Error Interrupt."]
        #[inline(always)]
        pub const fn ovrerr(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Clear UART Receive Overrun Error Interrupt."]
        #[inline(always)]
        pub fn set_ovrerr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Clear Negative Edge on UARTxRXD Interrupt."]
        #[inline(always)]
        pub const fn rxne(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Clear Negative Edge on UARTxRXD Interrupt."]
        #[inline(always)]
        pub fn set_rxne(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "Clear Positive Edge on UARTxRXD Interrupt."]
        #[inline(always)]
        pub const fn rxpe(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "Clear Positive Edge on UARTxRXD Interrupt."]
        #[inline(always)]
        pub fn set_rxpe(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "Clear LIN Capture 0 / Match Interrupt."]
        #[inline(always)]
        pub const fn linc0(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "Clear LIN Capture 0 / Match Interrupt."]
        #[inline(always)]
        pub fn set_linc0(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "Clear LIN Capture 1 Interrupt."]
        #[inline(always)]
        pub const fn linc1(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "Clear LIN Capture 1 Interrupt."]
        #[inline(always)]
        pub fn set_linc1(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "Clear LIN Hardware Counter Overflow Interrupt."]
        #[inline(always)]
        pub const fn linovf(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "Clear LIN Hardware Counter Overflow Interrupt."]
        #[inline(always)]
        pub fn set_linovf(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "Clear UART Receive Interrupt."]
        #[inline(always)]
        pub const fn rxint(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "Clear UART Receive Interrupt."]
        #[inline(always)]
        pub fn set_rxint(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "Clear UART Transmit Interrupt."]
        #[inline(always)]
        pub const fn txint(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "Clear UART Transmit Interrupt."]
        #[inline(always)]
        pub fn set_txint(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "Clear UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer."]
        #[inline(always)]
        pub const fn eot(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "Clear UART End of Transmission Interrupt Indicates that the last bit of all transmitted data and flags has left the serializer and without any further Data in the TX Fifo or Buffer."]
        #[inline(always)]
        pub fn set_eot(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "Clear Address Match Interrupt."]
        #[inline(always)]
        pub const fn addr_match(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "Clear Address Match Interrupt."]
        #[inline(always)]
        pub fn set_addr_match(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "Clear UART Clear to Send Modem Interrupt."]
        #[inline(always)]
        pub const fn cts(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "Clear UART Clear to Send Modem Interrupt."]
        #[inline(always)]
        pub fn set_cts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "Clear DMA Done on RX Event Channel Interrupt."]
        #[inline(always)]
        pub const fn dma_done_rx(&self) -> bool {
            let val = (self.0 >> 15usize) & 0x01;
            val != 0
        }
        #[doc = "Clear DMA Done on RX Event Channel Interrupt."]
        #[inline(always)]
        pub fn set_dma_done_rx(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
        }
        #[doc = "Clear DMA Done on TX Event Channel Interrupt."]
        #[inline(always)]
        pub const fn dma_done_tx(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "Clear DMA Done on TX Event Channel Interrupt."]
        #[inline(always)]
        pub fn set_dma_done_tx(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal."]
        #[inline(always)]
        pub const fn nerr(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "Noise Error on triple voting. Asserted when the 3 samples of majority voting are not equal."]
        #[inline(always)]
        pub fn set_nerr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
    }
    impl Default for CpuInt {
        #[inline(always)]
        fn default() -> CpuInt {
            CpuInt(0)
        }
    }
    #[doc = "Interrupt index."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct CpuIntIidx(pub u32);
    impl CpuIntIidx {
        #[doc = "UART Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in RIS and MIS registers. 15h-1Fh = Reserved."]
        #[inline(always)]
        pub const fn stat(&self) -> super::vals::CpuIntIidxStat {
            let val = (self.0 >> 0usize) & 0xff;
            super::vals::CpuIntIidxStat::from_bits(val as u8)
        }
        #[doc = "UART Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in RIS and MIS registers. 15h-1Fh = Reserved."]
        #[inline(always)]
        pub fn set_stat(&mut self, val: super::vals::CpuIntIidxStat) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
        }
    }
    impl Default for CpuIntIidx {
        #[inline(always)]
        fn default() -> CpuIntIidx {
            CpuIntIidx(0)
        }
    }
    #[doc = "UART Control Register 0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ctl0(pub u32);
    impl Ctl0 {
        #[doc = "UART Module Enable. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. If the ENABLE bit is not set, all registers can still be accessed and updated. It is recommended to setup and change the UART operation mode with having the ENABLE bit cleared to avoid unpredictable behavior during the setup or update. If disabled the UART module will not send or receive any data and the logic is held in reset state."]
        #[inline(always)]
        pub const fn enable(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "UART Module Enable. If the UART is disabled in the middle of transmission or reception, it completes the current character before stopping. If the ENABLE bit is not set, all registers can still be accessed and updated. It is recommended to setup and change the UART operation mode with having the ENABLE bit cleared to avoid unpredictable behavior during the setup or update. If disabled the UART module will not send or receive any data and the logic is held in reset state."]
        #[inline(always)]
        pub fn set_enable(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "UART Loop Back Enable."]
        #[inline(always)]
        pub const fn lbe(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "UART Loop Back Enable."]
        #[inline(always)]
        pub fn set_lbe(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "UART Receive Enable If the UART is disabled in the middle of a receive, it completes the current character before stopping. #b#NOTE:#/b# To enable reception, the UARTEN bit must be set."]
        #[inline(always)]
        pub const fn rxe(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "UART Receive Enable If the UART is disabled in the middle of a receive, it completes the current character before stopping. #b#NOTE:#/b# To enable reception, the UARTEN bit must be set."]
        #[inline(always)]
        pub fn set_rxe(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "UART Transmit Enable If the UART is disabled in the middle of a transmission, it completes the current character before stopping. #b#NOTE:#/b# To enable transmission, the UARTEN bit must be set."]
        #[inline(always)]
        pub const fn txe(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "UART Transmit Enable If the UART is disabled in the middle of a transmission, it completes the current character before stopping. #b#NOTE:#/b# To enable transmission, the UARTEN bit must be set."]
        #[inline(always)]
        pub fn set_txe(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "TXD Pin Control Enable. When the transmit section of the UART is disabled (TXE = 0), the TXD pin can be controlled by the TXD_OUT bit."]
        #[inline(always)]
        pub const fn txd_out_en(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "TXD Pin Control Enable. When the transmit section of the UART is disabled (TXE = 0), the TXD pin can be controlled by the TXD_OUT bit."]
        #[inline(always)]
        pub fn set_txd_out_en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "TXD Pin Control Controls the TXD pin when TXD_OUT_EN = 1 and TXE = 0."]
        #[inline(always)]
        pub const fn txd_out(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "TXD Pin Control Controls the TXD pin when TXD_OUT_EN = 1 and TXE = 0."]
        #[inline(always)]
        pub fn set_txd_out(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "Manchester Encode enable."]
        #[inline(always)]
        pub const fn menc(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "Manchester Encode enable."]
        #[inline(always)]
        pub fn set_menc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "Set the communication mode and protocol used. (Not defined settings uses the default setting: 0)."]
        #[inline(always)]
        pub const fn mode(&self) -> super::vals::Mode {
            let val = (self.0 >> 8usize) & 0x07;
            super::vals::Mode::from_bits(val as u8)
        }
        #[doc = "Set the communication mode and protocol used. (Not defined settings uses the default setting: 0)."]
        #[inline(always)]
        pub fn set_mode(&mut self, val: super::vals::Mode) {
            self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
        }
        #[doc = "Request to Send If RTSEN is set the RTS output signals is controlled by the hardware logic using the FIFO fill level or TXDATA buffer. If RTSEN is cleared the RTS output is controlled by the RTS bit. The bit is the complement of the UART request to send, RTS modem status output."]
        #[inline(always)]
        pub const fn rts(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "Request to Send If RTSEN is set the RTS output signals is controlled by the hardware logic using the FIFO fill level or TXDATA buffer. If RTSEN is cleared the RTS output is controlled by the RTS bit. The bit is the complement of the UART request to send, RTS modem status output."]
        #[inline(always)]
        pub fn set_rts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "Enable hardware controlled Request to Send."]
        #[inline(always)]
        pub const fn rtsen(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "Enable hardware controlled Request to Send."]
        #[inline(always)]
        pub fn set_rtsen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "Enable Clear To Send."]
        #[inline(always)]
        pub const fn ctsen(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "Enable Clear To Send."]
        #[inline(always)]
        pub fn set_ctsen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "High-Speed Bit Oversampling Enable #b#NOTE:#/b# The bit oversampling influences the UART baud-rate configuration. The state of this bit has no effect on clock generation in ISO7816 smart card mode (the SMART bit is set)."]
        #[inline(always)]
        pub const fn hse(&self) -> super::vals::Hse {
            let val = (self.0 >> 15usize) & 0x03;
            super::vals::Hse::from_bits(val as u8)
        }
        #[doc = "High-Speed Bit Oversampling Enable #b#NOTE:#/b# The bit oversampling influences the UART baud-rate configuration. The state of this bit has no effect on clock generation in ISO7816 smart card mode (the SMART bit is set)."]
        #[inline(always)]
        pub fn set_hse(&mut self, val: super::vals::Hse) {
            self.0 = (self.0 & !(0x03 << 15usize)) | (((val.to_bits() as u32) & 0x03) << 15usize);
        }
        #[doc = "UART Enable FIFOs."]
        #[inline(always)]
        pub const fn fen(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "UART Enable FIFOs."]
        #[inline(always)]
        pub fn set_fen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "When enabled with oversmapling of 16, samples samples 7, 8, and 9 are majority voted to decide the sampled bit value. The value correspond to al least 2 of the 3 samples is considered to be the received value. In case the 3 values do not match, RIS.NERR bit is set along with RDR.NERR When enabled with oversmapling of 8, samples samples 3, 4, and 5 are majority voted to decide the sampled bit value. The value correspond to al least 2 of the 3 samples is considered to be the received value. In case the 3 values donot match, RIS.NERR bit is set along with RDR.NERR When disabled, only a single sample of received bit is taken."]
        #[inline(always)]
        pub const fn majvote(&self) -> bool {
            let val = (self.0 >> 18usize) & 0x01;
            val != 0
        }
        #[doc = "When enabled with oversmapling of 16, samples samples 7, 8, and 9 are majority voted to decide the sampled bit value. The value correspond to al least 2 of the 3 samples is considered to be the received value. In case the 3 values do not match, RIS.NERR bit is set along with RDR.NERR When enabled with oversmapling of 8, samples samples 3, 4, and 5 are majority voted to decide the sampled bit value. The value correspond to al least 2 of the 3 samples is considered to be the received value. In case the 3 values donot match, RIS.NERR bit is set along with RDR.NERR When disabled, only a single sample of received bit is taken."]
        #[inline(always)]
        pub fn set_majvote(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
        }
        #[doc = "Most Significant Bit First This bit has effect both on the way protocol byte is transmitted and received. Notes: User needs to match the protocol to the correct value of this bit to send MSb or LSb first. The hardware engine will send the byte entirely based on this bit."]
        #[inline(always)]
        pub const fn msbfirst(&self) -> bool {
            let val = (self.0 >> 19usize) & 0x01;
            val != 0
        }
        #[doc = "Most Significant Bit First This bit has effect both on the way protocol byte is transmitted and received. Notes: User needs to match the protocol to the correct value of this bit to send MSb or LSb first. The hardware engine will send the byte entirely based on this bit."]
        #[inline(always)]
        pub fn set_msbfirst(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
        }
    }
    impl Default for Ctl0 {
        #[inline(always)]
        fn default() -> Ctl0 {
            Ctl0(0)
        }
    }
    #[doc = "Interrupt clear."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTrigRx(pub u32);
    impl DmaTrigRx {
        #[doc = "Clear UARTOUT Receive Time-Out Interrupt."]
        #[inline(always)]
        pub const fn rtout(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Clear UARTOUT Receive Time-Out Interrupt."]
        #[inline(always)]
        pub fn set_rtout(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Clear UART Receive Interrupt."]
        #[inline(always)]
        pub const fn rxint(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "Clear UART Receive Interrupt."]
        #[inline(always)]
        pub fn set_rxint(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
    }
    impl Default for DmaTrigRx {
        #[inline(always)]
        fn default() -> DmaTrigRx {
            DmaTrigRx(0)
        }
    }
    #[doc = "Interrupt index."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTrigRxIidx(pub u32);
    impl DmaTrigRxIidx {
        #[doc = "UART Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in UARTRIS and UARTMISC. 15h-1Fh = Reserved."]
        #[inline(always)]
        pub const fn stat(&self) -> super::vals::DmaTrigRxIidxStat {
            let val = (self.0 >> 0usize) & 0xff;
            super::vals::DmaTrigRxIidxStat::from_bits(val as u8)
        }
        #[doc = "UART Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in UARTRIS and UARTMISC. 15h-1Fh = Reserved."]
        #[inline(always)]
        pub fn set_stat(&mut self, val: super::vals::DmaTrigRxIidxStat) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
        }
    }
    impl Default for DmaTrigRxIidx {
        #[inline(always)]
        fn default() -> DmaTrigRxIidx {
            DmaTrigRxIidx(0)
        }
    }
    #[doc = "Interrupt clear."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTrigTx(pub u32);
    impl DmaTrigTx {
        #[doc = "Clear UART Transmit Interrupt."]
        #[inline(always)]
        pub const fn txint(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "Clear UART Transmit Interrupt."]
        #[inline(always)]
        pub fn set_txint(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
    }
    impl Default for DmaTrigTx {
        #[inline(always)]
        fn default() -> DmaTrigTx {
            DmaTrigTx(0)
        }
    }
    #[doc = "Interrupt index."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTrigTxIidx(pub u32);
    impl DmaTrigTxIidx {
        #[doc = "UART Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in UARTRIS and UARTMISC. 15h-1Fh = Reserved."]
        #[inline(always)]
        pub const fn stat(&self) -> super::vals::DmaTrigTxIidxStat {
            let val = (self.0 >> 0usize) & 0xff;
            super::vals::DmaTrigTxIidxStat::from_bits(val as u8)
        }
        #[doc = "UART Module Interrupt Vector Value. This register provides the highes priority interrupt index. A read clears the corresponding interrupt flag in UARTRIS and UARTMISC. 15h-1Fh = Reserved."]
        #[inline(always)]
        pub fn set_stat(&mut self, val: super::vals::DmaTrigTxIidxStat) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
        }
    }
    impl Default for DmaTrigTxIidx {
        #[inline(always)]
        fn default() -> DmaTrigTxIidx {
            DmaTrigTxIidx(0)
        }
    }
    #[doc = "Event Mode."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EvtMode(pub u32);
    impl EvtMode {
        #[doc = "Event line mode select for event corresponding to \\[IPSTANDARD.INT_EVENT0\\]."]
        #[inline(always)]
        pub const fn cpu(&self) -> super::vals::IntCfg {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::IntCfg::from_bits(val as u8)
        }
        #[doc = "Event line mode select for event corresponding to \\[IPSTANDARD.INT_EVENT0\\]."]
        #[inline(always)]
        pub fn set_cpu(&mut self, val: super::vals::IntCfg) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
        #[doc = "Event line mode select for event corresponding to \\[IPSTANDARD.INT_EVENT1\\]."]
        #[inline(always)]
        pub const fn dma_trig_rx(&self) -> super::vals::IntCfg {
            let val = (self.0 >> 2usize) & 0x03;
            super::vals::IntCfg::from_bits(val as u8)
        }
        #[doc = "Event line mode select for event corresponding to \\[IPSTANDARD.INT_EVENT1\\]."]
        #[inline(always)]
        pub fn set_dma_trig_rx(&mut self, val: super::vals::IntCfg) {
            self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
        }
        #[doc = "Event line mode select for event corresponding to \\[IPSTANDARD.INT_EVENT2\\]."]
        #[inline(always)]
        pub const fn dma_trig_tx(&self) -> super::vals::IntCfg {
            let val = (self.0 >> 4usize) & 0x03;
            super::vals::IntCfg::from_bits(val as u8)
        }
        #[doc = "Event line mode select for event corresponding to \\[IPSTANDARD.INT_EVENT2\\]."]
        #[inline(always)]
        pub fn set_dma_trig_tx(&mut self, val: super::vals::IntCfg) {
            self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
        }
    }
    impl Default for EvtMode {
        #[inline(always)]
        fn default() -> EvtMode {
            EvtMode(0)
        }
    }
    #[doc = "UART Fractional Baud-Rate Divisor Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Fbrd(pub u32);
    impl Fbrd {
        #[doc = "Fractional Baud-Rate Divisor."]
        #[inline(always)]
        pub const fn divfrac(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x3f;
            val as u8
        }
        #[doc = "Fractional Baud-Rate Divisor."]
        #[inline(always)]
        pub fn set_divfrac(&mut self, val: u8) {
            self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
        }
    }
    impl Default for Fbrd {
        #[inline(always)]
        fn default() -> Fbrd {
            Fbrd(0)
        }
    }
    #[doc = "Glitch Filter Control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gfctl(pub u32);
    impl Gfctl {
        #[doc = "Glitch Suppression Pulse Width This field controls the pulse width select for glitch suppression on the RX line. The value programmed in this field gives the number of cycles of fuctional clock up to which the glitch has to be suppressed on the RX line. In IRDA mode: The minimum pulse length for receive is given by: t(MIN) = (DGFSEL) / f(IRTXCLK)."]
        #[inline(always)]
        pub const fn dgfsel(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x3f;
            val as u8
        }
        #[doc = "Glitch Suppression Pulse Width This field controls the pulse width select for glitch suppression on the RX line. The value programmed in this field gives the number of cycles of fuctional clock up to which the glitch has to be suppressed on the RX line. In IRDA mode: The minimum pulse length for receive is given by: t(MIN) = (DGFSEL) / f(IRTXCLK)."]
        #[inline(always)]
        pub fn set_dgfsel(&mut self, val: u8) {
            self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
        }
        #[doc = "Analog Glitch Suppression Enable."]
        #[inline(always)]
        pub const fn agfen(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "Analog Glitch Suppression Enable."]
        #[inline(always)]
        pub fn set_agfen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "Analog Glitch Suppression Pulse Width This field controls the pulse width select for the analog glitch suppression on the RX line. See device datasheet for exact values."]
        #[inline(always)]
        pub const fn agfsel(&self) -> super::vals::Agfsel {
            let val = (self.0 >> 9usize) & 0x03;
            super::vals::Agfsel::from_bits(val as u8)
        }
        #[doc = "Analog Glitch Suppression Pulse Width This field controls the pulse width select for the analog glitch suppression on the RX line. See device datasheet for exact values."]
        #[inline(always)]
        pub fn set_agfsel(&mut self, val: super::vals::Agfsel) {
            self.0 = (self.0 & !(0x03 << 9usize)) | (((val.to_bits() as u32) & 0x03) << 9usize);
        }
        #[doc = "Analog and digital noise filters chaining enable. 0 DISABLE: When 0, chaining is disabled and only digital filter output is available to IP logic for sampling 1 ENABLE: When 1, analog and digital glitch filters are chained and the output of the combination is made available to IP logic for sampling."]
        #[inline(always)]
        pub const fn chain(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "Analog and digital noise filters chaining enable. 0 DISABLE: When 0, chaining is disabled and only digital filter output is available to IP logic for sampling 1 ENABLE: When 1, analog and digital glitch filters are chained and the output of the combination is made available to IP logic for sampling."]
        #[inline(always)]
        pub fn set_chain(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
    }
    impl Default for Gfctl {
        #[inline(always)]
        fn default() -> Gfctl {
            Gfctl(0)
        }
    }
    #[doc = "Status Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct GprcmStat(pub u32);
    impl GprcmStat {
        #[doc = "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register."]
        #[inline(always)]
        pub const fn resetstky(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register."]
        #[inline(always)]
        pub fn set_resetstky(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
    }
    impl Default for GprcmStat {
        #[inline(always)]
        fn default() -> GprcmStat {
            GprcmStat(0)
        }
    }
    #[doc = "UART Integer Baud-Rate Divisor Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ibrd(pub u32);
    impl Ibrd {
        #[doc = "Integer Baud-Rate Divisor."]
        #[inline(always)]
        pub const fn divint(&self) -> u16 {
            let val = (self.0 >> 0usize) & 0xffff;
            val as u16
        }
        #[doc = "Integer Baud-Rate Divisor."]
        #[inline(always)]
        pub fn set_divint(&mut self, val: u16) {
            self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
        }
    }
    impl Default for Ibrd {
        #[inline(always)]
        fn default() -> Ibrd {
            Ibrd(0)
        }
    }
    #[doc = "UART Interrupt FIFO Level Select Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ifls(pub u32);
    impl Ifls {
        #[doc = "UART Transmit Interrupt FIFO Level Select The trigger points for the transmit interrupt are as follows: Note: for undefined settings the default configuration is used."]
        #[inline(always)]
        pub const fn txiflsel(&self) -> super::vals::Iflssel {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::Iflssel::from_bits(val as u8)
        }
        #[doc = "UART Transmit Interrupt FIFO Level Select The trigger points for the transmit interrupt are as follows: Note: for undefined settings the default configuration is used."]
        #[inline(always)]
        pub fn set_txiflsel(&mut self, val: super::vals::Iflssel) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
        #[doc = "UART Receive Interrupt FIFO Level Select The trigger points for the receive interrupt are as follows: Note: In ULP domain the trigger levels are used for: 0: LVL_1_4 4: LVL_FULL For undefined settings the default configuration is used."]
        #[inline(always)]
        pub const fn rxiflsel(&self) -> super::vals::Iflssel {
            let val = (self.0 >> 4usize) & 0x07;
            super::vals::Iflssel::from_bits(val as u8)
        }
        #[doc = "UART Receive Interrupt FIFO Level Select The trigger points for the receive interrupt are as follows: Note: In ULP domain the trigger levels are used for: 0: LVL_1_4 4: LVL_FULL For undefined settings the default configuration is used."]
        #[inline(always)]
        pub fn set_rxiflsel(&mut self, val: super::vals::Iflssel) {
            self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u32) & 0x07) << 4usize);
        }
        #[doc = "UART Receive Interrupt Timeout Select. When receiving no start edge for an additional character within the set bittimes a RX interrupt is set even if the FIFO level is not reached. A value of 0 disables this function."]
        #[inline(always)]
        pub const fn rxtosel(&self) -> u8 {
            let val = (self.0 >> 8usize) & 0x0f;
            val as u8
        }
        #[doc = "UART Receive Interrupt Timeout Select. When receiving no start edge for an additional character within the set bittimes a RX interrupt is set even if the FIFO level is not reached. A value of 0 disables this function."]
        #[inline(always)]
        pub fn set_rxtosel(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
        }
    }
    impl Default for Ifls {
        #[inline(always)]
        fn default() -> Ifls {
            Ifls(0)
        }
    }
    #[doc = "Interrupt control register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Intctl(pub u32);
    impl Intctl {
        #[doc = "Writing a 1 to this field re-evaluates the interrupt sources."]
        #[inline(always)]
        pub const fn inteval(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Writing a 1 to this field re-evaluates the interrupt sources."]
        #[inline(always)]
        pub fn set_inteval(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Intctl {
        #[inline(always)]
        fn default() -> Intctl {
            Intctl(0)
        }
    }
    #[doc = "eUSCI_Ax IrDA Control Word Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Irctl(pub u32);
    impl Irctl {
        #[doc = "IrDA encoder/decoder enable."]
        #[inline(always)]
        pub const fn iren(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "IrDA encoder/decoder enable."]
        #[inline(always)]
        pub fn set_iren(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "IrDA transmit pulse clock select."]
        #[inline(always)]
        pub const fn irtxclk(&self) -> super::vals::Irtxclk {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Irtxclk::from_bits(val as u8)
        }
        #[doc = "IrDA transmit pulse clock select."]
        #[inline(always)]
        pub fn set_irtxclk(&mut self, val: super::vals::Irtxclk) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "Transmit pulse length. Pulse length t(PULSE) = (IRTXPLx + 1) / \\[2 * f(IRTXCLK)\\]
(IRTXCLK = functional clock of the UART)."]
        #[inline(always)]
        pub const fn irtxpl(&self) -> u8 {
            let val = (self.0 >> 2usize) & 0x3f;
            val as u8
        }
        #[doc = "Transmit pulse length. Pulse length t(PULSE) = (IRTXPLx + 1) / \\[2 * f(IRTXCLK)\\]
(IRTXCLK = functional clock of the UART)."]
        #[inline(always)]
        pub fn set_irtxpl(&mut self, val: u8) {
            self.0 = (self.0 & !(0x3f << 2usize)) | (((val as u32) & 0x3f) << 2usize);
        }
        #[doc = "IrDA receive input UCAxRXD polarity."]
        #[inline(always)]
        pub const fn irrxpl(&self) -> super::vals::Irrxpl {
            let val = (self.0 >> 9usize) & 0x01;
            super::vals::Irrxpl::from_bits(val as u8)
        }
        #[doc = "IrDA receive input UCAxRXD polarity."]
        #[inline(always)]
        pub fn set_irrxpl(&mut self, val: super::vals::Irrxpl) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
        }
    }
    impl Default for Irctl {
        #[inline(always)]
        fn default() -> Irctl {
            Irctl(0)
        }
    }
    #[doc = "UART Line Control Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Lcrh(pub u32);
    impl Lcrh {
        #[doc = "UART Send Break (for LIN Protocol)."]
        #[inline(always)]
        pub const fn brk(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "UART Send Break (for LIN Protocol)."]
        #[inline(always)]
        pub fn set_brk(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "UART Parity Enable."]
        #[inline(always)]
        pub const fn pen(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "UART Parity Enable."]
        #[inline(always)]
        pub fn set_pen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "UART Even Parity Select This bit has no effect when parity is disabled by the PEN bit. For 9-Bit UART Mode transmissions, this bit controls the address byte and data byte indication (9th bit). 0 = The transferred byte is a data byte 1 = The transferred byte is an address byte."]
        #[inline(always)]
        pub const fn eps(&self) -> super::vals::Eps {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Eps::from_bits(val as u8)
        }
        #[doc = "UART Even Parity Select This bit has no effect when parity is disabled by the PEN bit. For 9-Bit UART Mode transmissions, this bit controls the address byte and data byte indication (9th bit). 0 = The transferred byte is a data byte 1 = The transferred byte is an address byte."]
        #[inline(always)]
        pub fn set_eps(&mut self, val: super::vals::Eps) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
        #[doc = "UART Two Stop Bits Select When in 7816 smart card mode (the SMART bit is set in the UARTCTL register), the number of stop bits is forced to 2."]
        #[inline(always)]
        pub const fn stp2(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "UART Two Stop Bits Select When in 7816 smart card mode (the SMART bit is set in the UARTCTL register), the number of stop bits is forced to 2."]
        #[inline(always)]
        pub fn set_stp2(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "UART Word Length The bits indicate the number of data bits transmitted or received in a frame as follows:."]
        #[inline(always)]
        pub const fn wlen(&self) -> super::vals::Wlen {
            let val = (self.0 >> 4usize) & 0x03;
            super::vals::Wlen::from_bits(val as u8)
        }
        #[doc = "UART Word Length The bits indicate the number of data bits transmitted or received in a frame as follows:."]
        #[inline(always)]
        pub fn set_wlen(&mut self, val: super::vals::Wlen) {
            self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
        }
        #[doc = "UART Stick Parity Select The Stick Parity Select (SPS) bit is used to set either a permanent '1' or a permanent '0' as parity when transmitting or receiving data. Its purpose is to typically indicate the first byte of a package or to mark an address byte, for example in a multi-drop RS-485 network. When bits PEN, EPS, and SPS of UARTLCRH are set, the parity bit is transmitted and checked as a 0. When bits PEN and SPS are set and EPS is cleared, the parity bit is transmitted and checked as a 1."]
        #[inline(always)]
        pub const fn sps(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "UART Stick Parity Select The Stick Parity Select (SPS) bit is used to set either a permanent '1' or a permanent '0' as parity when transmitting or receiving data. Its purpose is to typically indicate the first byte of a package or to mark an address byte, for example in a multi-drop RS-485 network. When bits PEN, EPS, and SPS of UARTLCRH are set, the parity bit is transmitted and checked as a 0. When bits PEN and SPS are set and EPS is cleared, the parity bit is transmitted and checked as a 1."]
        #[inline(always)]
        pub fn set_sps(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "UART send IDLE pattern. When this bit is set an SENDIDLE period of 11 bit times will be sent on the TX line. The bit is cleared by hardware afterwards."]
        #[inline(always)]
        pub const fn sendidle(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "UART send IDLE pattern. When this bit is set an SENDIDLE period of 11 bit times will be sent on the TX line. The bit is cleared by hardware afterwards."]
        #[inline(always)]
        pub fn set_sendidle(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "Defines the number of UARTclk ticks the signal to control the external driver for the RS485 will be set before the START bit is send."]
        #[inline(always)]
        pub const fn extdir_setup(&self) -> u8 {
            let val = (self.0 >> 16usize) & 0x1f;
            val as u8
        }
        #[doc = "Defines the number of UARTclk ticks the signal to control the external driver for the RS485 will be set before the START bit is send."]
        #[inline(always)]
        pub fn set_extdir_setup(&mut self, val: u8) {
            self.0 = (self.0 & !(0x1f << 16usize)) | (((val as u32) & 0x1f) << 16usize);
        }
        #[doc = "Defines the number of UARTclk ticks the signal to control the external driver for the RS485 will be reset after the beginning of the stop bit. (If 2 STOP bits are enabled the beginning of the 2nd STOP bit.)."]
        #[inline(always)]
        pub const fn extdir_hold(&self) -> u8 {
            let val = (self.0 >> 21usize) & 0x1f;
            val as u8
        }
        #[doc = "Defines the number of UARTclk ticks the signal to control the external driver for the RS485 will be reset after the beginning of the stop bit. (If 2 STOP bits are enabled the beginning of the 2nd STOP bit.)."]
        #[inline(always)]
        pub fn set_extdir_hold(&mut self, val: u8) {
            self.0 = (self.0 & !(0x1f << 21usize)) | (((val as u32) & 0x1f) << 21usize);
        }
    }
    impl Default for Lcrh {
        #[inline(always)]
        fn default() -> Lcrh {
            Lcrh(0)
        }
    }
    #[doc = "UART LIN Mode Capture 0 Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Linc(pub u32);
    impl Linc {
        #[doc = "16 Bit Capture / Compare Register Captures current LINCTR value on RXD falling edge and can generate a LINC0 interrupt when capture is enabled (LINC0CAP = 1). If compare mode is enabled (LINC0_MATCH = 1), a counter match can generate a LINC0 interrupt."]
        #[inline(always)]
        pub const fn data(&self) -> u16 {
            let val = (self.0 >> 0usize) & 0xffff;
            val as u16
        }
        #[doc = "16 Bit Capture / Compare Register Captures current LINCTR value on RXD falling edge and can generate a LINC0 interrupt when capture is enabled (LINC0CAP = 1). If compare mode is enabled (LINC0_MATCH = 1), a counter match can generate a LINC0 interrupt."]
        #[inline(always)]
        pub fn set_data(&mut self, val: u16) {
            self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
        }
    }
    impl Default for Linc {
        #[inline(always)]
        fn default() -> Linc {
            Linc(0)
        }
    }
    #[doc = "UART LIN Mode Counter Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Lincnt(pub u32);
    impl Lincnt {
        #[doc = "16 bit up counter clocked by the functional clock of the UART."]
        #[inline(always)]
        pub const fn lincnt(&self) -> u16 {
            let val = (self.0 >> 0usize) & 0xffff;
            val as u16
        }
        #[doc = "16 bit up counter clocked by the functional clock of the UART."]
        #[inline(always)]
        pub fn set_lincnt(&mut self, val: u16) {
            self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
        }
    }
    impl Default for Lincnt {
        #[inline(always)]
        fn default() -> Lincnt {
            Lincnt(0)
        }
    }
    #[doc = "UART LIN Mode Control Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Linctl(pub u32);
    impl Linctl {
        #[doc = "LIN Counter Enable. LIN counter will only count when enabled."]
        #[inline(always)]
        pub const fn ctrena(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "LIN Counter Enable. LIN counter will only count when enabled."]
        #[inline(always)]
        pub fn set_ctrena(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Zero on negative Edge of RXD. When enabled the counter is set to 0 and starts counting on a negative edge of RXD."]
        #[inline(always)]
        pub const fn zerone(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Zero on negative Edge of RXD. When enabled the counter is set to 0 and starts counting on a negative edge of RXD."]
        #[inline(always)]
        pub fn set_zerone(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Count while low Signal on RXD When counter is enabled and the signal on RXD is low, the counter increments."]
        #[inline(always)]
        pub const fn cntrxlow(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Count while low Signal on RXD When counter is enabled and the signal on RXD is low, the counter increments."]
        #[inline(always)]
        pub fn set_cntrxlow(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Capture Counter on negative RXD Edge. When enabled the counter value is captured to LINC0 register on each negative RXD edge. A LINC0 interrupt is triggered when enabled."]
        #[inline(always)]
        pub const fn linc0cap(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Capture Counter on negative RXD Edge. When enabled the counter value is captured to LINC0 register on each negative RXD edge. A LINC0 interrupt is triggered when enabled."]
        #[inline(always)]
        pub fn set_linc0cap(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Capture Counter on positive RXD Edge. When enabled the counter value is captured to LINC1 register on each positive RXD edge. A LINC1 interrupt is triggered when enabled."]
        #[inline(always)]
        pub const fn linc1cap(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Capture Counter on positive RXD Edge. When enabled the counter value is captured to LINC1 register on each positive RXD edge. A LINC1 interrupt is triggered when enabled."]
        #[inline(always)]
        pub fn set_linc1cap(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "Counter Compare Match Mode When this bit is set to 1 a counter compare match with LINC0 register triggers an LINC0 interrupt when enabled."]
        #[inline(always)]
        pub const fn linc0_match(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "Counter Compare Match Mode When this bit is set to 1 a counter compare match with LINC0 register triggers an LINC0 interrupt when enabled."]
        #[inline(always)]
        pub fn set_linc0_match(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Linctl {
        #[inline(always)]
        fn default() -> Linctl {
            Linctl(0)
        }
    }
    #[doc = "Peripheral Debug Control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pdbgctl(pub u32);
    impl Pdbgctl {
        #[doc = "Free run control."]
        #[inline(always)]
        pub const fn free(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Free run control."]
        #[inline(always)]
        pub fn set_free(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Soft halt boundary control. This function is only available, if \\[FREE\\]
is set to 'STOP'."]
        #[inline(always)]
        pub const fn soft(&self) -> super::vals::Soft {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Soft::from_bits(val as u8)
        }
        #[doc = "Soft halt boundary control. This function is only available, if \\[FREE\\]
is set to 'STOP'."]
        #[inline(always)]
        pub fn set_soft(&mut self, val: super::vals::Soft) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
    }
    impl Default for Pdbgctl {
        #[inline(always)]
        fn default() -> Pdbgctl {
            Pdbgctl(0)
        }
    }
    #[doc = "Power enable."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pwren(pub u32);
    impl Pwren {
        #[doc = "Enable the power."]
        #[inline(always)]
        pub const fn enable(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Enable the power."]
        #[inline(always)]
        pub fn set_enable(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "KEY to allow Power State Change 26h = KEY to allow write access to this register"]
        #[inline(always)]
        pub const fn key(&self) -> super::vals::PwrenKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::PwrenKey::from_bits(val as u8)
        }
        #[doc = "KEY to allow Power State Change 26h = KEY to allow write access to this register"]
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::PwrenKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Pwren {
        #[inline(always)]
        fn default() -> Pwren {
            Pwren(0)
        }
    }
    #[doc = "Reset Control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rstctl(pub u32);
    impl Rstctl {
        #[doc = "Assert reset to the peripheral."]
        #[inline(always)]
        pub const fn resetassert(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Assert reset to the peripheral."]
        #[inline(always)]
        pub fn set_resetassert(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Clear the RESETSTKY bit in the STAT register."]
        #[inline(always)]
        pub const fn resetstkyclr(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Clear the RESETSTKY bit in the STAT register."]
        #[inline(always)]
        pub fn set_resetstkyclr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Unlock key B1h = KEY to allow write access to this register"]
        #[inline(always)]
        pub const fn key(&self) -> super::vals::ResetKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::ResetKey::from_bits(val as u8)
        }
        #[doc = "Unlock key B1h = KEY to allow write access to this register"]
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::ResetKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Rstctl {
        #[inline(always)]
        fn default() -> Rstctl {
            Rstctl(0)
        }
    }
    #[doc = "UART Receive Data Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rxdata(pub u32);
    impl Rxdata {
        #[doc = "Received Data. When read, this field contains the data that was received by the UART."]
        #[inline(always)]
        pub const fn data(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0xff;
            val as u8
        }
        #[doc = "Received Data. When read, this field contains the data that was received by the UART."]
        #[inline(always)]
        pub fn set_data(&mut self, val: u8) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
        }
        #[doc = "UART Framing Error Writing to this bit has no effect. The flag is cleared by writing 1 to the FRMERR bit in the UART EVENT ICLR register. This error is associated with the character at the top of the FIFO."]
        #[inline(always)]
        pub const fn frmerr(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "UART Framing Error Writing to this bit has no effect. The flag is cleared by writing 1 to the FRMERR bit in the UART EVENT ICLR register. This error is associated with the character at the top of the FIFO."]
        #[inline(always)]
        pub fn set_frmerr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "UART Parity Error Writing to this bit has no effect. The flag is cleared by writing 1 to the PARERR bit in the UART EVENT ICLR register."]
        #[inline(always)]
        pub const fn parerr(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "UART Parity Error Writing to this bit has no effect. The flag is cleared by writing 1 to the PARERR bit in the UART EVENT ICLR register."]
        #[inline(always)]
        pub fn set_parerr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "UART Break Error Writing to this bit has no effect. The flag is cleared by writing 1 to the BRKERR bit in the UART EVENT ICLR register. This error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received."]
        #[inline(always)]
        pub const fn brkerr(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "UART Break Error Writing to this bit has no effect. The flag is cleared by writing 1 to the BRKERR bit in the UART EVENT ICLR register. This error is associated with the character at the top of the FIFO. When a break occurs, only one 0 character is loaded into the FIFO. The next character is only enabled after the receive data input goes to a 1 (marking state) and the next valid start bit is received."]
        #[inline(always)]
        pub fn set_brkerr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "UART Receive Overrun Error Writing to this bit has no effect. The flag is cleared by writing 1 to the OVRERR bit in the UART EVENT ICLR register. In case of a receive FIFO overflow, the FIFO contents remain valid because no further data is written when the FIFO is full. Only the contents of the shift register are overwritten. The CPU must read the data in order to empty the FIFO."]
        #[inline(always)]
        pub const fn ovrerr(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "UART Receive Overrun Error Writing to this bit has no effect. The flag is cleared by writing 1 to the OVRERR bit in the UART EVENT ICLR register. In case of a receive FIFO overflow, the FIFO contents remain valid because no further data is written when the FIFO is full. Only the contents of the shift register are overwritten. The CPU must read the data in order to empty the FIFO."]
        #[inline(always)]
        pub fn set_ovrerr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "Noise Error. Writing to this bit has no effect. The flag is cleared by writing 1 to the NERR bit in the UART EVENT ICLR register."]
        #[inline(always)]
        pub const fn nerr(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "Noise Error. Writing to this bit has no effect. The flag is cleared by writing 1 to the NERR bit in the UART EVENT ICLR register."]
        #[inline(always)]
        pub fn set_nerr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
    }
    impl Default for Rxdata {
        #[inline(always)]
        fn default() -> Rxdata {
            Rxdata(0)
        }
    }
    #[doc = "UART Status Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Stat(pub u32);
    impl Stat {
        #[doc = "UART Busy This bit is set as soon as the transmit FIFO or TXDATA register becomes non-empty (regardless of whether UART is enabled) or if a receive data is currently ongoing (after the start edge have been detected until a complete byte, including all stop bits, has been received by the shift register). In IDLE_Line mode the Busy signal also stays set during the idle time generation."]
        #[inline(always)]
        pub const fn busy(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "UART Busy This bit is set as soon as the transmit FIFO or TXDATA register becomes non-empty (regardless of whether UART is enabled) or if a receive data is currently ongoing (after the start edge have been detected until a complete byte, including all stop bits, has been received by the shift register). In IDLE_Line mode the Busy signal also stays set during the idle time generation."]
        #[inline(always)]
        pub fn set_busy(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "UART Receive FIFO Empty The meaning of this bit depends on the state of the FEN bit in the CTL0 register."]
        #[inline(always)]
        pub const fn rxfe(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "UART Receive FIFO Empty The meaning of this bit depends on the state of the FEN bit in the CTL0 register."]
        #[inline(always)]
        pub fn set_rxfe(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "UART Receive FIFO Full The meaning of this bit depends on the state of the FEN bit in the CTL0 register."]
        #[inline(always)]
        pub const fn rxff(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "UART Receive FIFO Full The meaning of this bit depends on the state of the FEN bit in the CTL0 register."]
        #[inline(always)]
        pub fn set_rxff(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "UART Transmit FIFO Empty The meaning of this bit depends on the state of the FEN bit in the CTL0 register."]
        #[inline(always)]
        pub const fn txfe(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "UART Transmit FIFO Empty The meaning of this bit depends on the state of the FEN bit in the CTL0 register."]
        #[inline(always)]
        pub fn set_txfe(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "UART Transmit FIFO Full The meaning of this bit depends on the state of the FEN bit in the CTL0 register."]
        #[inline(always)]
        pub const fn txff(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "UART Transmit FIFO Full The meaning of this bit depends on the state of the FEN bit in the CTL0 register."]
        #[inline(always)]
        pub fn set_txff(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "Clear To Send."]
        #[inline(always)]
        pub const fn cts(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "Clear To Send."]
        #[inline(always)]
        pub fn set_cts(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "IDLE mode has been detected in Idleline-Mulitprocessor-Mode. The IDLE bit is used as an address tag for each block of characters. In idle-line multiprocessor format, this bit is set when a received character is an address."]
        #[inline(always)]
        pub const fn idle(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "IDLE mode has been detected in Idleline-Mulitprocessor-Mode. The IDLE bit is used as an address tag for each block of characters. In idle-line multiprocessor format, this bit is set when a received character is an address."]
        #[inline(always)]
        pub fn set_idle(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
    }
    impl Default for Stat {
        #[inline(always)]
        fn default() -> Stat {
            Stat(0)
        }
    }
    #[doc = "UART Transmit Data Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Txdata(pub u32);
    impl Txdata {
        #[doc = "Data Transmitted or Received Data that is to be transmitted via the UART is written to this field. When read, this field contains the data that was received by the UART."]
        #[inline(always)]
        pub const fn data(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0xff;
            val as u8
        }
        #[doc = "Data Transmitted or Received Data that is to be transmitted via the UART is written to this field. When read, this field contains the data that was received by the UART."]
        #[inline(always)]
        pub fn set_data(&mut self, val: u8) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
        }
    }
    impl Default for Txdata {
        #[inline(always)]
        fn default() -> Txdata {
            Txdata(0)
        }
    }
}
pub mod vals {
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Agfsel {
        #[doc = "Pulses shorter then 5ns length are filtered."]
        AGLIT_5 = 0x0,
        #[doc = "Pulses shorter then 10ns length are filtered."]
        AGLIT_10 = 0x01,
        #[doc = "Pulses shorter then 25ns length are filtered."]
        AGLIT_25 = 0x02,
        #[doc = "Pulses shorter then 50ns length are filtered."]
        AGLIT_50 = 0x03,
    }
    impl Agfsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Agfsel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Agfsel {
        #[inline(always)]
        fn from(val: u8) -> Agfsel {
            Agfsel::from_bits(val)
        }
    }
    impl From<Agfsel> for u8 {
        #[inline(always)]
        fn from(val: Agfsel) -> u8 {
            Agfsel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct ClkcfgKey(pub u8);
    impl ClkcfgKey {
        pub const KEY: Self = Self(0xa9);
    }
    impl ClkcfgKey {
        pub const fn from_bits(val: u8) -> ClkcfgKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for ClkcfgKey {
        #[inline(always)]
        fn from(val: u8) -> ClkcfgKey {
            ClkcfgKey::from_bits(val)
        }
    }
    impl From<ClkcfgKey> for u8 {
        #[inline(always)]
        fn from(val: ClkcfgKey) -> u8 {
            ClkcfgKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Clkdiv {
        #[doc = "Do not divide clock source."]
        DIV_BY_1 = 0x0,
        #[doc = "Divide clock source by 2."]
        DIV_BY_2 = 0x01,
        #[doc = "Divide clock source by 3."]
        DIV_BY_3 = 0x02,
        #[doc = "Divide clock source by 4."]
        DIV_BY_4 = 0x03,
        #[doc = "Divide clock source by 5."]
        DIV_BY_5 = 0x04,
        #[doc = "Divide clock source by 6."]
        DIV_BY_6 = 0x05,
        #[doc = "Divide clock source by 7."]
        DIV_BY_7 = 0x06,
        #[doc = "Divide clock source by 8."]
        DIV_BY_8 = 0x07,
    }
    impl Clkdiv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Clkdiv {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Clkdiv {
        #[inline(always)]
        fn from(val: u8) -> Clkdiv {
            Clkdiv::from_bits(val)
        }
    }
    impl From<Clkdiv> for u8 {
        #[inline(always)]
        fn from(val: Clkdiv) -> u8 {
            Clkdiv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum CpuIntIidxStat {
        #[doc = "No interrupt pending."]
        NO_INTR = 0x0,
        #[doc = "UART receive time-out interrupt; Interrupt Flag: RT; Interrupt Priority: Highest."]
        RTFG = 0x01,
        #[doc = "UART framing error interrupt; Interrupt Flag: FE."]
        FEFG = 0x02,
        #[doc = "UART parity error interrupt; Interrupt Flag: PE."]
        PEFG = 0x03,
        #[doc = "UART break error interrupt; Interrupt Flag: BE."]
        BEFG = 0x04,
        #[doc = "UART receive overrun error interrupt; Interrupt Flag: OE."]
        OEFG = 0x05,
        #[doc = "Negative edge on UARTxRXD interrupt; Interrupt Flag: RXNE."]
        RXNE = 0x06,
        #[doc = "Positive edge on UARTxRXD interrupt; Interrupt Flag: RXPE."]
        RXPE = 0x07,
        #[doc = "LIN capture 0 / match interrupt; Interrupt Flag: LINC0."]
        LINC0 = 0x08,
        #[doc = "LIN capture 1 interrupt; Interrupt Flag: LINC1."]
        LINC1 = 0x09,
        #[doc = "LIN hardware counter overflow interrupt; Interrupt Flag: LINOVF."]
        LINOVF = 0x0a,
        #[doc = "UART receive interrupt; Interrupt Flag: RX."]
        RXIFG = 0x0b,
        #[doc = "UART transmit interrupt; Interrupt Flag: TX."]
        TXIFG = 0x0c,
        #[doc = "UART end of transmission interrupt (transmit serializer empty); Interrupt Flag: EOT."]
        EOT = 0x0d,
        #[doc = "9-bit mode address match interrupt; Interrupt Flag: MODE_9B."]
        MODE_9B = 0x0e,
        #[doc = "UART Clear to Send Modem interrupt; Interrupt Flag: CTS."]
        CTS = 0x0f,
        #[doc = "DMA DONE on RX."]
        DMA_DONE_RX = 0x10,
        #[doc = "DMA DONE on TX."]
        DMA_DONE_TX = 0x11,
        #[doc = "Noise Error Event."]
        NERR_EVT = 0x12,
        _RESERVED_13 = 0x13,
        _RESERVED_14 = 0x14,
        _RESERVED_15 = 0x15,
        _RESERVED_16 = 0x16,
        _RESERVED_17 = 0x17,
        _RESERVED_18 = 0x18,
        _RESERVED_19 = 0x19,
        _RESERVED_1a = 0x1a,
        _RESERVED_1b = 0x1b,
        _RESERVED_1c = 0x1c,
        _RESERVED_1d = 0x1d,
        _RESERVED_1e = 0x1e,
        _RESERVED_1f = 0x1f,
        _RESERVED_20 = 0x20,
        _RESERVED_21 = 0x21,
        _RESERVED_22 = 0x22,
        _RESERVED_23 = 0x23,
        _RESERVED_24 = 0x24,
        _RESERVED_25 = 0x25,
        _RESERVED_26 = 0x26,
        _RESERVED_27 = 0x27,
        _RESERVED_28 = 0x28,
        _RESERVED_29 = 0x29,
        _RESERVED_2a = 0x2a,
        _RESERVED_2b = 0x2b,
        _RESERVED_2c = 0x2c,
        _RESERVED_2d = 0x2d,
        _RESERVED_2e = 0x2e,
        _RESERVED_2f = 0x2f,
        _RESERVED_30 = 0x30,
        _RESERVED_31 = 0x31,
        _RESERVED_32 = 0x32,
        _RESERVED_33 = 0x33,
        _RESERVED_34 = 0x34,
        _RESERVED_35 = 0x35,
        _RESERVED_36 = 0x36,
        _RESERVED_37 = 0x37,
        _RESERVED_38 = 0x38,
        _RESERVED_39 = 0x39,
        _RESERVED_3a = 0x3a,
        _RESERVED_3b = 0x3b,
        _RESERVED_3c = 0x3c,
        _RESERVED_3d = 0x3d,
        _RESERVED_3e = 0x3e,
        _RESERVED_3f = 0x3f,
        _RESERVED_40 = 0x40,
        _RESERVED_41 = 0x41,
        _RESERVED_42 = 0x42,
        _RESERVED_43 = 0x43,
        _RESERVED_44 = 0x44,
        _RESERVED_45 = 0x45,
        _RESERVED_46 = 0x46,
        _RESERVED_47 = 0x47,
        _RESERVED_48 = 0x48,
        _RESERVED_49 = 0x49,
        _RESERVED_4a = 0x4a,
        _RESERVED_4b = 0x4b,
        _RESERVED_4c = 0x4c,
        _RESERVED_4d = 0x4d,
        _RESERVED_4e = 0x4e,
        _RESERVED_4f = 0x4f,
        _RESERVED_50 = 0x50,
        _RESERVED_51 = 0x51,
        _RESERVED_52 = 0x52,
        _RESERVED_53 = 0x53,
        _RESERVED_54 = 0x54,
        _RESERVED_55 = 0x55,
        _RESERVED_56 = 0x56,
        _RESERVED_57 = 0x57,
        _RESERVED_58 = 0x58,
        _RESERVED_59 = 0x59,
        _RESERVED_5a = 0x5a,
        _RESERVED_5b = 0x5b,
        _RESERVED_5c = 0x5c,
        _RESERVED_5d = 0x5d,
        _RESERVED_5e = 0x5e,
        _RESERVED_5f = 0x5f,
        _RESERVED_60 = 0x60,
        _RESERVED_61 = 0x61,
        _RESERVED_62 = 0x62,
        _RESERVED_63 = 0x63,
        _RESERVED_64 = 0x64,
        _RESERVED_65 = 0x65,
        _RESERVED_66 = 0x66,
        _RESERVED_67 = 0x67,
        _RESERVED_68 = 0x68,
        _RESERVED_69 = 0x69,
        _RESERVED_6a = 0x6a,
        _RESERVED_6b = 0x6b,
        _RESERVED_6c = 0x6c,
        _RESERVED_6d = 0x6d,
        _RESERVED_6e = 0x6e,
        _RESERVED_6f = 0x6f,
        _RESERVED_70 = 0x70,
        _RESERVED_71 = 0x71,
        _RESERVED_72 = 0x72,
        _RESERVED_73 = 0x73,
        _RESERVED_74 = 0x74,
        _RESERVED_75 = 0x75,
        _RESERVED_76 = 0x76,
        _RESERVED_77 = 0x77,
        _RESERVED_78 = 0x78,
        _RESERVED_79 = 0x79,
        _RESERVED_7a = 0x7a,
        _RESERVED_7b = 0x7b,
        _RESERVED_7c = 0x7c,
        _RESERVED_7d = 0x7d,
        _RESERVED_7e = 0x7e,
        _RESERVED_7f = 0x7f,
        _RESERVED_80 = 0x80,
        _RESERVED_81 = 0x81,
        _RESERVED_82 = 0x82,
        _RESERVED_83 = 0x83,
        _RESERVED_84 = 0x84,
        _RESERVED_85 = 0x85,
        _RESERVED_86 = 0x86,
        _RESERVED_87 = 0x87,
        _RESERVED_88 = 0x88,
        _RESERVED_89 = 0x89,
        _RESERVED_8a = 0x8a,
        _RESERVED_8b = 0x8b,
        _RESERVED_8c = 0x8c,
        _RESERVED_8d = 0x8d,
        _RESERVED_8e = 0x8e,
        _RESERVED_8f = 0x8f,
        _RESERVED_90 = 0x90,
        _RESERVED_91 = 0x91,
        _RESERVED_92 = 0x92,
        _RESERVED_93 = 0x93,
        _RESERVED_94 = 0x94,
        _RESERVED_95 = 0x95,
        _RESERVED_96 = 0x96,
        _RESERVED_97 = 0x97,
        _RESERVED_98 = 0x98,
        _RESERVED_99 = 0x99,
        _RESERVED_9a = 0x9a,
        _RESERVED_9b = 0x9b,
        _RESERVED_9c = 0x9c,
        _RESERVED_9d = 0x9d,
        _RESERVED_9e = 0x9e,
        _RESERVED_9f = 0x9f,
        _RESERVED_a0 = 0xa0,
        _RESERVED_a1 = 0xa1,
        _RESERVED_a2 = 0xa2,
        _RESERVED_a3 = 0xa3,
        _RESERVED_a4 = 0xa4,
        _RESERVED_a5 = 0xa5,
        _RESERVED_a6 = 0xa6,
        _RESERVED_a7 = 0xa7,
        _RESERVED_a8 = 0xa8,
        _RESERVED_a9 = 0xa9,
        _RESERVED_aa = 0xaa,
        _RESERVED_ab = 0xab,
        _RESERVED_ac = 0xac,
        _RESERVED_ad = 0xad,
        _RESERVED_ae = 0xae,
        _RESERVED_af = 0xaf,
        _RESERVED_b0 = 0xb0,
        _RESERVED_b1 = 0xb1,
        _RESERVED_b2 = 0xb2,
        _RESERVED_b3 = 0xb3,
        _RESERVED_b4 = 0xb4,
        _RESERVED_b5 = 0xb5,
        _RESERVED_b6 = 0xb6,
        _RESERVED_b7 = 0xb7,
        _RESERVED_b8 = 0xb8,
        _RESERVED_b9 = 0xb9,
        _RESERVED_ba = 0xba,
        _RESERVED_bb = 0xbb,
        _RESERVED_bc = 0xbc,
        _RESERVED_bd = 0xbd,
        _RESERVED_be = 0xbe,
        _RESERVED_bf = 0xbf,
        _RESERVED_c0 = 0xc0,
        _RESERVED_c1 = 0xc1,
        _RESERVED_c2 = 0xc2,
        _RESERVED_c3 = 0xc3,
        _RESERVED_c4 = 0xc4,
        _RESERVED_c5 = 0xc5,
        _RESERVED_c6 = 0xc6,
        _RESERVED_c7 = 0xc7,
        _RESERVED_c8 = 0xc8,
        _RESERVED_c9 = 0xc9,
        _RESERVED_ca = 0xca,
        _RESERVED_cb = 0xcb,
        _RESERVED_cc = 0xcc,
        _RESERVED_cd = 0xcd,
        _RESERVED_ce = 0xce,
        _RESERVED_cf = 0xcf,
        _RESERVED_d0 = 0xd0,
        _RESERVED_d1 = 0xd1,
        _RESERVED_d2 = 0xd2,
        _RESERVED_d3 = 0xd3,
        _RESERVED_d4 = 0xd4,
        _RESERVED_d5 = 0xd5,
        _RESERVED_d6 = 0xd6,
        _RESERVED_d7 = 0xd7,
        _RESERVED_d8 = 0xd8,
        _RESERVED_d9 = 0xd9,
        _RESERVED_da = 0xda,
        _RESERVED_db = 0xdb,
        _RESERVED_dc = 0xdc,
        _RESERVED_dd = 0xdd,
        _RESERVED_de = 0xde,
        _RESERVED_df = 0xdf,
        _RESERVED_e0 = 0xe0,
        _RESERVED_e1 = 0xe1,
        _RESERVED_e2 = 0xe2,
        _RESERVED_e3 = 0xe3,
        _RESERVED_e4 = 0xe4,
        _RESERVED_e5 = 0xe5,
        _RESERVED_e6 = 0xe6,
        _RESERVED_e7 = 0xe7,
        _RESERVED_e8 = 0xe8,
        _RESERVED_e9 = 0xe9,
        _RESERVED_ea = 0xea,
        _RESERVED_eb = 0xeb,
        _RESERVED_ec = 0xec,
        _RESERVED_ed = 0xed,
        _RESERVED_ee = 0xee,
        _RESERVED_ef = 0xef,
        _RESERVED_f0 = 0xf0,
        _RESERVED_f1 = 0xf1,
        _RESERVED_f2 = 0xf2,
        _RESERVED_f3 = 0xf3,
        _RESERVED_f4 = 0xf4,
        _RESERVED_f5 = 0xf5,
        _RESERVED_f6 = 0xf6,
        _RESERVED_f7 = 0xf7,
        _RESERVED_f8 = 0xf8,
        _RESERVED_f9 = 0xf9,
        _RESERVED_fa = 0xfa,
        _RESERVED_fb = 0xfb,
        _RESERVED_fc = 0xfc,
        _RESERVED_fd = 0xfd,
        _RESERVED_fe = 0xfe,
        _RESERVED_ff = 0xff,
    }
    impl CpuIntIidxStat {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> CpuIntIidxStat {
            unsafe { core::mem::transmute(val & 0xff) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for CpuIntIidxStat {
        #[inline(always)]
        fn from(val: u8) -> CpuIntIidxStat {
            CpuIntIidxStat::from_bits(val)
        }
    }
    impl From<CpuIntIidxStat> for u8 {
        #[inline(always)]
        fn from(val: CpuIntIidxStat) -> u8 {
            CpuIntIidxStat::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct DmaTrigRxIidxStat(pub u8);
    impl DmaTrigRxIidxStat {
        #[doc = "No interrupt pending."]
        pub const NO_INTR: Self = Self(0x0);
        #[doc = "UART receive time-out interrupt; Interrupt Flag: RT; Interrupt Priority: Highest."]
        pub const RTFG: Self = Self(0x01);
        #[doc = "UART receive interrupt; Interrupt Flag: RX."]
        pub const RXIFG: Self = Self(0x0b);
    }
    impl DmaTrigRxIidxStat {
        pub const fn from_bits(val: u8) -> DmaTrigRxIidxStat {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for DmaTrigRxIidxStat {
        #[inline(always)]
        fn from(val: u8) -> DmaTrigRxIidxStat {
            DmaTrigRxIidxStat::from_bits(val)
        }
    }
    impl From<DmaTrigRxIidxStat> for u8 {
        #[inline(always)]
        fn from(val: DmaTrigRxIidxStat) -> u8 {
            DmaTrigRxIidxStat::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct DmaTrigTxIidxStat(pub u8);
    impl DmaTrigTxIidxStat {
        #[doc = "No interrupt pending."]
        pub const NO_INTR: Self = Self(0x0);
        #[doc = "UART transmit interrupt; Interrupt Flag: TX."]
        pub const TXIFG: Self = Self(0x0c);
    }
    impl DmaTrigTxIidxStat {
        pub const fn from_bits(val: u8) -> DmaTrigTxIidxStat {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for DmaTrigTxIidxStat {
        #[inline(always)]
        fn from(val: u8) -> DmaTrigTxIidxStat {
            DmaTrigTxIidxStat::from_bits(val)
        }
    }
    impl From<DmaTrigTxIidxStat> for u8 {
        #[inline(always)]
        fn from(val: DmaTrigTxIidxStat) -> u8 {
            DmaTrigTxIidxStat::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Eps {
        #[doc = "Odd parity is performed, which checks for an odd number of 1s."]
        ODD = 0x0,
        #[doc = "Even parity generation and checking is performed during transmission and reception, which checks for an even number of 1s in data and parity bits."]
        EVEN = 0x01,
    }
    impl Eps {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Eps {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Eps {
        #[inline(always)]
        fn from(val: u8) -> Eps {
            Eps::from_bits(val)
        }
    }
    impl From<Eps> for u8 {
        #[inline(always)]
        fn from(val: Eps) -> u8 {
            Eps::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Hse {
        #[doc = "16x oversampling."]
        OVS16 = 0x0,
        #[doc = "8x oversampling."]
        OVS8 = 0x01,
        #[doc = "3x oversampling. It is intended to support 9600 Baud Rate when clock is 32K. IrDA, Manchester and DALI couldnt support when 3x oversampling is enabled."]
        OVS3 = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl Hse {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hse {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hse {
        #[inline(always)]
        fn from(val: u8) -> Hse {
            Hse::from_bits(val)
        }
    }
    impl From<Hse> for u8 {
        #[inline(always)]
        fn from(val: Hse) -> u8 {
            Hse::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Iflssel {
        #[doc = "RX FIFO >= 1/4 full, for ULP domain"]
        ONE_FOURTH_ULP = 0x0,
        #[doc = "RX FIFO >= 1/4 full or TX FIFO <= 1/4 full"]
        ONE_FOURTH = 0x01,
        #[doc = "RX FIFO >= 1/2 full or TX FIFO <= 1/2 full"]
        HALF = 0x02,
        #[doc = "RX FIFO >= 3/4 full or TX FIFO <= 3/4 full"]
        THREE_FOURTH = 0x03,
        #[doc = "RX FIFO is full, for ULP domain"]
        FULL_ULP = 0x04,
        #[doc = "RX or TX FIFO is full"]
        FULL = 0x05,
        _RESERVED_6 = 0x06,
        #[doc = "RX or TX FIFO >= 1 entry available/free"]
        AT_LEAST_ONE = 0x07,
    }
    impl Iflssel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Iflssel {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Iflssel {
        #[inline(always)]
        fn from(val: u8) -> Iflssel {
            Iflssel::from_bits(val)
        }
    }
    impl From<Iflssel> for u8 {
        #[inline(always)]
        fn from(val: Iflssel) -> u8 {
            Iflssel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum IntCfg {
        #[doc = "The interrupt or event line is disabled."]
        DISABLE = 0x0,
        #[doc = "The interrupt or event line is in software mode. Software must clear the RIS."]
        SOFTWARE = 0x01,
        #[doc = "The interrupt or event line is in hardware mode. The hardware (another module) clears automatically the associated RIS flag."]
        HARDWARE = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl IntCfg {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> IntCfg {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for IntCfg {
        #[inline(always)]
        fn from(val: u8) -> IntCfg {
            IntCfg::from_bits(val)
        }
    }
    impl From<IntCfg> for u8 {
        #[inline(always)]
        fn from(val: IntCfg) -> u8 {
            IntCfg::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Irrxpl {
        #[doc = "IrDA transceiver delivers a high pulse when a light pulse is seen."]
        HIGH = 0x0,
        #[doc = "IrDA transceiver delivers a low pulse when a light pulse is seen."]
        LOW = 0x01,
    }
    impl Irrxpl {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Irrxpl {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Irrxpl {
        #[inline(always)]
        fn from(val: u8) -> Irrxpl {
            Irrxpl::from_bits(val)
        }
    }
    impl From<Irrxpl> for u8 {
        #[inline(always)]
        fn from(val: Irrxpl) -> u8 {
            Irrxpl::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Irtxclk {
        #[doc = "IrDA encode data is based on the functional clock."]
        BITCLK = 0x0,
        #[doc = "IrDA encode data is based on the Baud Rate clock< when select 8x oversampling, the IRTXPL cycle should less 8; when select 16x oversampling, the IRTXPL cycle should less 16."]
        BRCLK = 0x01,
    }
    impl Irtxclk {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Irtxclk {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Irtxclk {
        #[inline(always)]
        fn from(val: u8) -> Irtxclk {
            Irtxclk::from_bits(val)
        }
    }
    impl From<Irtxclk> for u8 {
        #[inline(always)]
        fn from(val: Irtxclk) -> u8 {
            Irtxclk::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Mode {
        #[doc = "Normal operation."]
        UART = 0x0,
        #[doc = "RS485 mode: UART needs to be IDLE with receiving data for the in EXTDIR_HOLD set time. EXTDIR_SETUP defines the time the RTS line is set to high before sending. When the buffer is empty the RTS line is set low again. A transmit will be delayed as long the UART is receiving data."]
        RS485 = 0x01,
        #[doc = "The UART operates in IDLE Line Mode."]
        IDLELINE = 0x02,
        #[doc = "The UART operates in 9 Bit Address mode."]
        ADDR9BIT = 0x03,
        #[doc = "ISO7816 Smart Card Support The application must ensure that it sets 8-bit word length (WLEN set to 3h) and even parity (PEN set to 1, EPS set to 1, SPS set to 0) in UARTLCRH when using ISO7816 mode. The value of the STP2 bit in UARTLCRH is ignored and the number of stop bits is forced to 2."]
        SMART = 0x04,
        #[doc = "DALI Mode:."]
        DALI = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl Mode {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Mode {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Mode {
        #[inline(always)]
        fn from(val: u8) -> Mode {
            Mode::from_bits(val)
        }
    }
    impl From<Mode> for u8 {
        #[inline(always)]
        fn from(val: Mode) -> u8 {
            Mode::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct PwrenKey(pub u8);
    impl PwrenKey {
        pub const KEY: Self = Self(0x26);
    }
    impl PwrenKey {
        pub const fn from_bits(val: u8) -> PwrenKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for PwrenKey {
        #[inline(always)]
        fn from(val: u8) -> PwrenKey {
            PwrenKey::from_bits(val)
        }
    }
    impl From<PwrenKey> for u8 {
        #[inline(always)]
        fn from(val: PwrenKey) -> u8 {
            PwrenKey::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct ResetKey(pub u8);
    impl ResetKey {
        pub const KEY: Self = Self(0xb1);
    }
    impl ResetKey {
        pub const fn from_bits(val: u8) -> ResetKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for ResetKey {
        #[inline(always)]
        fn from(val: u8) -> ResetKey {
            ResetKey::from_bits(val)
        }
    }
    impl From<ResetKey> for u8 {
        #[inline(always)]
        fn from(val: ResetKey) -> u8 {
            ResetKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Soft {
        #[doc = "The peripheral will halt immediately, even if the resultant state will result in corruption if the system is restarted."]
        IMMEDIATE = 0x0,
        #[doc = "The peripheral blocks the debug freeze until it has reached a boundary where it can resume without corruption."]
        DELAYED = 0x01,
    }
    impl Soft {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Soft {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Soft {
        #[inline(always)]
        fn from(val: u8) -> Soft {
            Soft::from_bits(val)
        }
    }
    impl From<Soft> for u8 {
        #[inline(always)]
        fn from(val: Soft) -> u8 {
            Soft::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Wlen {
        #[doc = "5 bits (default)."]
        DATABIT5 = 0x0,
        #[doc = "6 bits."]
        DATABIT6 = 0x01,
        #[doc = "7 bits."]
        DATABIT7 = 0x02,
        #[doc = "8 bits."]
        DATABIT8 = 0x03,
    }
    impl Wlen {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Wlen {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Wlen {
        #[inline(always)]
        fn from(val: u8) -> Wlen {
            Wlen::from_bits(val)
        }
    }
    impl From<Wlen> for u8 {
        #[inline(always)]
        fn from(val: Wlen) -> u8 {
            Wlen::to_bits(val)
        }
    }
}
