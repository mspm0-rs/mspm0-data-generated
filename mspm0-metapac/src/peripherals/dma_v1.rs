// This file is autogenerated by mspm0-metapac-gen: do not edit by hand.
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::identity_op)]
#![allow(clippy::unnecessary_cast)]
#![allow(clippy::erasing_op)]

#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Chan {
    ptr: *mut u8,
}
unsafe impl Send for Chan {}
unsafe impl Sync for Chan {}
impl Chan {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "DMA Channel Control."]
    #[inline(always)]
    pub const fn ctl(self) -> crate::common::Reg<regs::Ctl, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "DMA Channel Source Address."]
    #[inline(always)]
    pub const fn sa(self) -> crate::common::Reg<u32, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
    }
    #[doc = "DMA Channel Destination Address."]
    #[inline(always)]
    pub const fn da(self) -> crate::common::Reg<u32, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
    }
    #[doc = "DMA Channel Size."]
    #[inline(always)]
    pub const fn sz(self) -> crate::common::Reg<regs::Sz, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
    }
}
#[doc = "PERIPHERALREGION."]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Dma {
    ptr: *mut u8,
}
unsafe impl Send for Dma {}
unsafe impl Sync for Dma {}
impl Dma {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Subscriber Port 0."]
    #[inline(always)]
    pub const fn fsub(self, n: usize) -> crate::common::Reg<regs::Fport, crate::common::RW> {
        assert!(n < 2usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize + n * 4usize) as _) }
    }
    #[doc = "Publisher Port 0."]
    #[inline(always)]
    pub const fn fpub(self, n: usize) -> crate::common::Reg<regs::Fport, crate::common::RW> {
        assert!(n < 1usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0444usize + n * 0usize) as _) }
    }
    #[doc = "Peripheral Debug Control."]
    #[inline(always)]
    pub const fn pdbgctl(self) -> crate::common::Reg<regs::Pdbgctl, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1018usize) as _) }
    }
    #[inline(always)]
    pub const fn int_event(self, n: usize) -> IntEvent {
        assert!(n < 2usize);
        unsafe { IntEvent::from_ptr(self.ptr.add(0x1020usize + n * 44usize) as _) }
    }
    #[doc = "Event Mode."]
    #[inline(always)]
    pub const fn evt_mode(self) -> crate::common::Reg<regs::EvtMode, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10e0usize) as _) }
    }
    #[doc = "Module Description."]
    #[inline(always)]
    pub const fn desc(self) -> crate::common::Reg<regs::Desc, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10fcusize) as _) }
    }
    #[doc = "DMA Channel Priority Control."]
    #[inline(always)]
    pub const fn prio(self) -> crate::common::Reg<regs::Prio, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1100usize) as _) }
    }
    #[inline(always)]
    pub const fn trig(self, n: usize) -> Trig {
        assert!(n < 7usize);
        unsafe { Trig::from_ptr(self.ptr.add(0x1110usize + n * 4usize) as _) }
    }
    #[inline(always)]
    pub const fn chan(self, n: usize) -> Chan {
        assert!(n < 7usize);
        unsafe { Chan::from_ptr(self.ptr.add(0x1200usize + n * 16usize) as _) }
    }
}
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct IntEvent {
    ptr: *mut u8,
}
unsafe impl Send for IntEvent {}
unsafe impl Sync for IntEvent {}
impl IntEvent {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Interrupt index."]
    #[inline(always)]
    pub const fn iidx(self) -> crate::common::Reg<regs::Iidx, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "Interrupt mask."]
    #[inline(always)]
    pub const fn imask(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
    }
    #[doc = "Raw interrupt status."]
    #[inline(always)]
    pub const fn ris(self) -> crate::common::Reg<regs::Int, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
    }
    #[doc = "Masked interrupt status."]
    #[inline(always)]
    pub const fn mis(self) -> crate::common::Reg<regs::Int, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
    }
    #[doc = "Interrupt set."]
    #[inline(always)]
    pub const fn iset(self) -> crate::common::Reg<regs::Int, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
    }
    #[doc = "Interrupt clear."]
    #[inline(always)]
    pub const fn iclr(self) -> crate::common::Reg<regs::Int, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
    }
}
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Trig {
    ptr: *mut u8,
}
unsafe impl Send for Trig {}
unsafe impl Sync for Trig {}
impl Trig {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "DMA Trigger Select."]
    #[inline(always)]
    pub const fn tctl(self) -> crate::common::Reg<regs::Tctl, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
}
pub mod regs {
    #[doc = "DMA Channel Control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ctl(pub u32);
    impl Ctl {
        #[doc = "DMA request. Software-controlled DMA start. DMAREQ is reset automatically."]
        #[inline(always)]
        pub const fn req(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "DMA request. Software-controlled DMA start. DMAREQ is reset automatically."]
        #[inline(always)]
        pub fn set_req(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "DMA enable."]
        #[inline(always)]
        pub const fn en(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "DMA enable."]
        #[inline(always)]
        pub fn set_en(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Automatic DMA channel enable on SA, DA, SZ register write. If channel is configured as SW trigger (TCTL=0), the AUTOEN will set the EN and REQ. If channel is configured as HW trigger (CTL!=0), the AUTOEN will only set the EN. Note: This feature is not present in all devices. Consult the device specific datasheet."]
        #[inline(always)]
        pub const fn autoen(&self) -> super::vals::Autoen {
            let val = (self.0 >> 2usize) & 0x03;
            super::vals::Autoen::from_bits(val as u8)
        }
        #[doc = "Automatic DMA channel enable on SA, DA, SZ register write. If channel is configured as SW trigger (TCTL=0), the AUTOEN will set the EN and REQ. If channel is configured as HW trigger (CTL!=0), the AUTOEN will only set the EN. Note: This feature is not present in all devices. Consult the device specific datasheet."]
        #[inline(always)]
        pub fn set_autoen(&mut self, val: super::vals::Autoen) {
            self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
        }
        #[doc = "Enable an early IRQ event. This can help software to react quicker to and DMA done event or allows some additional configuration before the channel is complete. Note: This register is only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC configuration this register is a read only value and always reads as 0x0."]
        #[inline(always)]
        pub const fn preirq(&self) -> super::vals::Preirq {
            let val = (self.0 >> 4usize) & 0x07;
            super::vals::Preirq::from_bits(val as u8)
        }
        #[doc = "Enable an early IRQ event. This can help software to react quicker to and DMA done event or allows some additional configuration before the channel is complete. Note: This register is only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC configuration this register is a read only value and always reads as 0x0."]
        #[inline(always)]
        pub fn set_preirq(&mut self, val: super::vals::Preirq) {
            self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u32) & 0x07) << 4usize);
        }
        #[doc = "DMA source width. This bit selects the source data width as a byte, half word, word or long word."]
        #[inline(always)]
        pub const fn srcwdth(&self) -> super::vals::Wdth {
            let val = (self.0 >> 8usize) & 0x03;
            super::vals::Wdth::from_bits(val as u8)
        }
        #[doc = "DMA source width. This bit selects the source data width as a byte, half word, word or long word."]
        #[inline(always)]
        pub fn set_srcwdth(&mut self, val: super::vals::Wdth) {
            self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
        }
        #[doc = "DMA destination width. This bit selects the destination as a byte, half word, word or long word."]
        #[inline(always)]
        pub const fn dstwdth(&self) -> super::vals::Wdth {
            let val = (self.0 >> 12usize) & 0x03;
            super::vals::Wdth::from_bits(val as u8)
        }
        #[doc = "DMA destination width. This bit selects the destination as a byte, half word, word or long word."]
        #[inline(always)]
        pub fn set_dstwdth(&mut self, val: super::vals::Wdth) {
            self.0 = (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
        }
        #[doc = "DMA source increment. This bit selects automatic incrementing or decrementing of the source address DMASA for each transfer. The amount of change to the DMASA is based on the definitin in the DMASRCWDTH. For example an increment of 1 (+1) on a WORD transfer will increment the DMASA by 4."]
        #[inline(always)]
        pub const fn srcincr(&self) -> super::vals::Incr {
            let val = (self.0 >> 16usize) & 0x0f;
            super::vals::Incr::from_bits(val as u8)
        }
        #[doc = "DMA source increment. This bit selects automatic incrementing or decrementing of the source address DMASA for each transfer. The amount of change to the DMASA is based on the definitin in the DMASRCWDTH. For example an increment of 1 (+1) on a WORD transfer will increment the DMASA by 4."]
        #[inline(always)]
        pub fn set_srcincr(&mut self, val: super::vals::Incr) {
            self.0 = (self.0 & !(0x0f << 16usize)) | (((val.to_bits() as u32) & 0x0f) << 16usize);
        }
        #[doc = "DMA destination increment. This bit selects automatic incrementing or decrementing of the destination address DMADA for each transfer. The amount of change to the DMADA is based on the definitin in the DMADSTWDTH. For example an increment of 1 (+1) on a WORD transfer will increment the DMADA by 4."]
        #[inline(always)]
        pub const fn dstincr(&self) -> super::vals::Incr {
            let val = (self.0 >> 20usize) & 0x0f;
            super::vals::Incr::from_bits(val as u8)
        }
        #[doc = "DMA destination increment. This bit selects automatic incrementing or decrementing of the destination address DMADA for each transfer. The amount of change to the DMADA is based on the definitin in the DMADSTWDTH. For example an increment of 1 (+1) on a WORD transfer will increment the DMADA by 4."]
        #[inline(always)]
        pub fn set_dstincr(&mut self, val: super::vals::Incr) {
            self.0 = (self.0 & !(0x0f << 20usize)) | (((val.to_bits() as u32) & 0x0f) << 20usize);
        }
        #[doc = "DMA extended mode Note: The extended transfer modes are only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC channel configuration this register is a read-only register and reads 0x0."]
        #[inline(always)]
        pub const fn em(&self) -> super::vals::Em {
            let val = (self.0 >> 24usize) & 0x03;
            super::vals::Em::from_bits(val as u8)
        }
        #[doc = "DMA extended mode Note: The extended transfer modes are only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC channel configuration this register is a read-only register and reads 0x0."]
        #[inline(always)]
        pub fn set_em(&mut self, val: super::vals::Em) {
            self.0 = (self.0 & !(0x03 << 24usize)) | (((val.to_bits() as u32) & 0x03) << 24usize);
        }
        #[doc = "DMA transfer mode register Note: The repeat-single (2h) and repeat-block (3h) transfer are only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC channel configuration only the values for single (0h) and block (1h) transfer can be set."]
        #[inline(always)]
        pub const fn tm(&self) -> super::vals::Tm {
            let val = (self.0 >> 28usize) & 0x03;
            super::vals::Tm::from_bits(val as u8)
        }
        #[doc = "DMA transfer mode register Note: The repeat-single (2h) and repeat-block (3h) transfer are only available in a FULL-channel configuration. Please consult the datasheet of the specific device to map which channel number has FULL or BASIC capability. In a BASIC channel configuration only the values for single (0h) and block (1h) transfer can be set."]
        #[inline(always)]
        pub fn set_tm(&mut self, val: super::vals::Tm) {
            self.0 = (self.0 & !(0x03 << 28usize)) | (((val.to_bits() as u32) & 0x03) << 28usize);
        }
    }
    impl Default for Ctl {
        #[inline(always)]
        fn default() -> Ctl {
            Ctl(0)
        }
    }
    #[doc = "Module Description."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Desc(pub u32);
    impl Desc {
        #[doc = "Minor rev of the IP."]
        #[inline(always)]
        pub const fn minrev(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x0f;
            val as u8
        }
        #[doc = "Minor rev of the IP."]
        #[inline(always)]
        pub fn set_minrev(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
        }
        #[doc = "Major rev of the IP."]
        #[inline(always)]
        pub const fn majrev(&self) -> u8 {
            let val = (self.0 >> 4usize) & 0x0f;
            val as u8
        }
        #[doc = "Major rev of the IP."]
        #[inline(always)]
        pub fn set_majrev(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
        }
        #[doc = "Feature Set for the DMA: number of DMA channel minus one (e.g. 0->1ch, 2->3ch, 15->16ch)."]
        #[inline(always)]
        pub const fn featurever(&self) -> u8 {
            let val = (self.0 >> 12usize) & 0x0f;
            val as u8
        }
        #[doc = "Feature Set for the DMA: number of DMA channel minus one (e.g. 0->1ch, 2->3ch, 15->16ch)."]
        #[inline(always)]
        pub fn set_featurever(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
        }
        #[doc = "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness."]
        #[inline(always)]
        pub const fn moduleid(&self) -> u16 {
            let val = (self.0 >> 16usize) & 0xffff;
            val as u16
        }
        #[doc = "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness."]
        #[inline(always)]
        pub fn set_moduleid(&mut self, val: u16) {
            self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
        }
    }
    impl Default for Desc {
        #[inline(always)]
        fn default() -> Desc {
            Desc(0)
        }
    }
    #[doc = "Event Mode."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EvtMode(pub u32);
    impl EvtMode {
        #[doc = "Event line mode select for event corresponding to interrupt event INT_EVENT\\[0\\]."]
        #[inline(always)]
        pub const fn cpu(&self) -> super::vals::EvtCfg {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::EvtCfg::from_bits(val as u8)
        }
        #[doc = "Event line mode select for event corresponding to interrupt event INT_EVENT\\[0\\]."]
        #[inline(always)]
        pub fn set_cpu(&mut self, val: super::vals::EvtCfg) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
        #[doc = "Event line mode select for event corresponding to generic event INT_EVENT\\[1\\]."]
        #[inline(always)]
        pub const fn event(&self) -> super::vals::EvtCfg {
            let val = (self.0 >> 2usize) & 0x03;
            super::vals::EvtCfg::from_bits(val as u8)
        }
        #[doc = "Event line mode select for event corresponding to generic event INT_EVENT\\[1\\]."]
        #[inline(always)]
        pub fn set_event(&mut self, val: super::vals::EvtCfg) {
            self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
        }
    }
    impl Default for EvtMode {
        #[inline(always)]
        fn default() -> EvtMode {
            EvtMode(0)
        }
    }
    #[doc = "Publisher Port 0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Fport(pub u32);
    impl Fport {
        #[doc = "0 = disconnected. 1-255 = connected to channelID = CHANID."]
        #[inline(always)]
        pub const fn chanid(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x0f;
            val as u8
        }
        #[doc = "0 = disconnected. 1-255 = connected to channelID = CHANID."]
        #[inline(always)]
        pub fn set_chanid(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
        }
    }
    impl Default for Fport {
        #[inline(always)]
        fn default() -> Fport {
            Fport(0)
        }
    }
    #[doc = "Interrupt index."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iidx(pub u32);
    impl Iidx {
        #[doc = "Interrupt index status."]
        #[inline(always)]
        pub const fn stat(&self) -> super::vals::Stat {
            let val = (self.0 >> 0usize) & 0xff;
            super::vals::Stat::from_bits(val as u8)
        }
        #[doc = "Interrupt index status."]
        #[inline(always)]
        pub fn set_stat(&mut self, val: super::vals::Stat) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
        }
    }
    impl Default for Iidx {
        #[inline(always)]
        fn default() -> Iidx {
            Iidx(0)
        }
    }
    #[doc = "Interrupt clear."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Int(pub u32);
    impl Int {
        #[doc = "DMA Channel 0 interrupt signals that size counter reached zero (DMASZ=0)."]
        #[inline(always)]
        pub const fn ch(&self, n: usize) -> bool {
            assert!(n < 16usize);
            let offs = 0usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "DMA Channel 0 interrupt signals that size counter reached zero (DMASZ=0)."]
        #[inline(always)]
        pub fn set_ch(&mut self, n: usize, val: bool) {
            assert!(n < 16usize);
            let offs = 0usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
        #[doc = "Pre-IRQ for Channel 0. Size counter reached Pre-IRQ threshold."]
        #[inline(always)]
        pub const fn preirqch(&self, n: usize) -> bool {
            assert!(n < 8usize);
            let offs = 16usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "Pre-IRQ for Channel 0. Size counter reached Pre-IRQ threshold."]
        #[inline(always)]
        pub fn set_preirqch(&mut self, n: usize, val: bool) {
            assert!(n < 8usize);
            let offs = 16usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
        #[doc = "DMA address error, SRC address not reachable."]
        #[inline(always)]
        pub const fn addrerr(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "DMA address error, SRC address not reachable."]
        #[inline(always)]
        pub fn set_addrerr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
        #[doc = "DMA data error, SRC data might be corrupted (PAR or ECC error)."]
        #[inline(always)]
        pub const fn dataerr(&self) -> bool {
            let val = (self.0 >> 25usize) & 0x01;
            val != 0
        }
        #[doc = "DMA data error, SRC data might be corrupted (PAR or ECC error)."]
        #[inline(always)]
        pub fn set_dataerr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
        }
    }
    impl Default for Int {
        #[inline(always)]
        fn default() -> Int {
            Int(0)
        }
    }
    #[doc = "Peripheral Debug Control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pdbgctl(pub u32);
    impl Pdbgctl {
        #[doc = "Free run control."]
        #[inline(always)]
        pub const fn free(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Free run control."]
        #[inline(always)]
        pub fn set_free(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Soft halt boundary control. This function is only available, if \\[FREE\\]
is set to 'STOP'."]
        #[inline(always)]
        pub const fn soft(&self) -> super::vals::Soft {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Soft::from_bits(val as u8)
        }
        #[doc = "Soft halt boundary control. This function is only available, if \\[FREE\\]
is set to 'STOP'."]
        #[inline(always)]
        pub fn set_soft(&mut self, val: super::vals::Soft) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
    }
    impl Default for Pdbgctl {
        #[inline(always)]
        fn default() -> Pdbgctl {
            Pdbgctl(0)
        }
    }
    #[doc = "DMA Channel Priority Control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Prio(pub u32);
    impl Prio {
        #[doc = "Round robin. This bit enables the round-robin DMA channel priorities."]
        #[inline(always)]
        pub const fn roundrobin(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Round robin. This bit enables the round-robin DMA channel priorities."]
        #[inline(always)]
        pub fn set_roundrobin(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Define the burst size of a block transfer, before the priority is re-evaluated."]
        #[inline(always)]
        pub const fn burstsz(&self) -> super::vals::Burstsz {
            let val = (self.0 >> 16usize) & 0x03;
            super::vals::Burstsz::from_bits(val as u8)
        }
        #[doc = "Define the burst size of a block transfer, before the priority is re-evaluated."]
        #[inline(always)]
        pub fn set_burstsz(&mut self, val: super::vals::Burstsz) {
            self.0 = (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
        }
    }
    impl Default for Prio {
        #[inline(always)]
        fn default() -> Prio {
            Prio(0)
        }
    }
    #[doc = "DMA Channel Size."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sz(pub u32);
    impl Sz {
        #[doc = "DMA Channel Size in number of transfers."]
        #[inline(always)]
        pub const fn size(&self) -> u16 {
            let val = (self.0 >> 0usize) & 0xffff;
            val as u16
        }
        #[doc = "DMA Channel Size in number of transfers."]
        #[inline(always)]
        pub fn set_size(&mut self, val: u16) {
            self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
        }
    }
    impl Default for Sz {
        #[inline(always)]
        fn default() -> Sz {
            Sz(0)
        }
    }
    #[doc = "DMA Trigger Select."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tctl(pub u32);
    impl Tctl {
        #[doc = "DMA Trigger Select Note: Reference the datasheet of the device to see the specific trigger mapping."]
        #[inline(always)]
        pub const fn tsel(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x3f;
            val as u8
        }
        #[doc = "DMA Trigger Select Note: Reference the datasheet of the device to see the specific trigger mapping."]
        #[inline(always)]
        pub fn set_tsel(&mut self, val: u8) {
            self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
        }
        #[doc = "DMA Trigger by Internal Channel."]
        #[inline(always)]
        pub const fn tint(&self) -> super::vals::Tint {
            let val = (self.0 >> 7usize) & 0x01;
            super::vals::Tint::from_bits(val as u8)
        }
        #[doc = "DMA Trigger by Internal Channel."]
        #[inline(always)]
        pub fn set_tint(&mut self, val: super::vals::Tint) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
        }
    }
    impl Default for Tctl {
        #[inline(always)]
        fn default() -> Tctl {
            Tctl(0)
        }
    }
}
pub mod vals {
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Autoen {
        #[doc = "No automatic DMA enable"]
        NONE = 0x0,
        #[doc = "Automatic DMA channel enable on SA register write."]
        SA = 0x01,
        #[doc = "Automatic DMA channel enable on DA register write."]
        DA = 0x02,
        #[doc = "Automatic DMA channel enable on SZ register write."]
        SZ = 0x03,
    }
    impl Autoen {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Autoen {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Autoen {
        #[inline(always)]
        fn from(val: u8) -> Autoen {
            Autoen::from_bits(val)
        }
    }
    impl From<Autoen> for u8 {
        #[inline(always)]
        fn from(val: Autoen) -> u8 {
            Autoen::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Burstsz {
        #[doc = "There is no burst size, the whole block transfer is completed on one transfer without interruption."]
        INFINITI = 0x0,
        #[doc = "The burst size is 8, after 8 transfers the block transfer is interrupted and the priority is reevaluated."]
        BURST_8 = 0x01,
        #[doc = "The burst size is 16, after 16 transfers the block transfer is interrupted and the priority is reevaluated."]
        BURST_16 = 0x02,
        #[doc = "The burst size is 32, after 32 transfers the block transfer is interrupted and the priority is reevaluated."]
        BURST_32 = 0x03,
    }
    impl Burstsz {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Burstsz {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Burstsz {
        #[inline(always)]
        fn from(val: u8) -> Burstsz {
            Burstsz::from_bits(val)
        }
    }
    impl From<Burstsz> for u8 {
        #[inline(always)]
        fn from(val: Burstsz) -> u8 {
            Burstsz::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Em {
        #[doc = "Normal mode is related to transfers from SRC to DST."]
        NORMAL = 0x0,
        _RESERVED_1 = 0x01,
        #[doc = "Fill mode will copy the SA register content as data to DA."]
        FILLMODE = 0x02,
        #[doc = "Table mode will read an address and data value from SA and write the data to address."]
        TABLEMODE = 0x03,
    }
    impl Em {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Em {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Em {
        #[inline(always)]
        fn from(val: u8) -> Em {
            Em::from_bits(val)
        }
    }
    impl From<Em> for u8 {
        #[inline(always)]
        fn from(val: Em) -> u8 {
            Em::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum EvtCfg {
        #[doc = "The interrupt or event line is disabled."]
        DISABLE = 0x0,
        #[doc = "The interrupt or event line is in software mode. Software must clear the RIS."]
        SOFTWARE = 0x01,
        #[doc = "The interrupt or event line is in hardware mode. The hardware (another module) clears automatically the associated RIS flag."]
        HARDWARE = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl EvtCfg {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> EvtCfg {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for EvtCfg {
        #[inline(always)]
        fn from(val: u8) -> EvtCfg {
            EvtCfg::from_bits(val)
        }
    }
    impl From<EvtCfg> for u8 {
        #[inline(always)]
        fn from(val: EvtCfg) -> u8 {
            EvtCfg::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Incr {
        #[doc = "Address is unchanged (+0)."]
        UNCHANGED = 0x0,
        _RESERVED_1 = 0x01,
        #[doc = "Decremented by 1 (-1 * DMADSTWDTH)."]
        DECREMENT = 0x02,
        #[doc = "Incremented by 1 (+1 * DMADSTWDTH)."]
        INCREMENT = 0x03,
        _RESERVED_4 = 0x04,
        _RESERVED_5 = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
        #[doc = "Stride size 2 (+2 * DMADSTWDTH)."]
        STRIDE_2 = 0x08,
        #[doc = "Stride size 3 (+3 * DMADSTWDTH)."]
        STRIDE_3 = 0x09,
        #[doc = "Stride size 4 (+4 * DMADSTWDTH)."]
        STRIDE_4 = 0x0a,
        #[doc = "Stride size 5 (+5 * DMADSTWDTH)."]
        STRIDE_5 = 0x0b,
        #[doc = "Stride size 6 (+6 * DMADSTWDTH)."]
        STRIDE_6 = 0x0c,
        #[doc = "Stride size 7 (+7 * DMADSTWDTH)."]
        STRIDE_7 = 0x0d,
        #[doc = "Stride size 8 (+8 * DMADSTWDTH)."]
        STRIDE_8 = 0x0e,
        #[doc = "Stride size 9 (+9 * DMADSTWDTH)."]
        STRIDE_9 = 0x0f,
    }
    impl Incr {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Incr {
            unsafe { core::mem::transmute(val & 0x0f) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Incr {
        #[inline(always)]
        fn from(val: u8) -> Incr {
            Incr::from_bits(val)
        }
    }
    impl From<Incr> for u8 {
        #[inline(always)]
        fn from(val: Incr) -> u8 {
            Incr::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Preirq {
        #[doc = "Pre-IRQ event disabled."]
        PREIRQ_DISABLE = 0x0,
        #[doc = "Issure Pre-IRQ event when DMASZ=1."]
        PREIRQ_1 = 0x01,
        #[doc = "Issure Pre-IRQ event when DMASZ=2."]
        PREIRQ_2 = 0x02,
        #[doc = "Issure Pre-IRQ event when DMASZ=4."]
        PREIRQ_4 = 0x03,
        #[doc = "Issure Pre-IRQ event when DMASZ=8."]
        PREIRQ_8 = 0x04,
        #[doc = "Issure Pre-IRQ event when DMASZ=32."]
        PREIRQ_32 = 0x05,
        #[doc = "Issure Pre-IRQ event when DMASZ=64."]
        PREIRQ_64 = 0x06,
        #[doc = "Issure Pre-IRQ event when DMASZ reached the half size point of the original transfer size."]
        PREIRQ_HALF = 0x07,
    }
    impl Preirq {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Preirq {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Preirq {
        #[inline(always)]
        fn from(val: u8) -> Preirq {
            Preirq::from_bits(val)
        }
    }
    impl From<Preirq> for u8 {
        #[inline(always)]
        fn from(val: Preirq) -> u8 {
            Preirq::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Soft {
        #[doc = "The peripheral will halt immediately, even if the resultant state will result in corruption if the system is restarted."]
        IMMEDIATE = 0x0,
        #[doc = "The peripheral blocks the debug freeze until it has reached a boundary where it can resume without corruption."]
        DELAYED = 0x01,
    }
    impl Soft {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Soft {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Soft {
        #[inline(always)]
        fn from(val: u8) -> Soft {
            Soft::from_bits(val)
        }
    }
    impl From<Soft> for u8 {
        #[inline(always)]
        fn from(val: Soft) -> u8 {
            Soft::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Stat {
        #[doc = "No bit is set means there is no pending interrupt request."]
        NO_INTR = 0x0,
        #[doc = "DMA Channel 0 size counter reached zero (DMASZ=0)."]
        CH0 = 0x01,
        #[doc = "DMA Channel 2 size counter reached zero (DMASZ=0)."]
        CH1 = 0x02,
        #[doc = "DMA Channel 2 size counter reached zero (DMASZ=0)."]
        CH2 = 0x03,
        #[doc = "DMA Channel 3 size counter reached zero (DMASZ=0)."]
        CH3 = 0x04,
        #[doc = "DMA Channel 4 size counter reached zero (DMASZ=0)."]
        CH4 = 0x05,
        #[doc = "DMA Channel 5 size counter reached zero (DMASZ=0)."]
        CH5 = 0x06,
        #[doc = "DMA Channel 6 size counter reached zero (DMASZ=0)."]
        CH6 = 0x07,
        #[doc = "DMA Channel 7 size counter reached zero (DMASZ=0)."]
        CH7 = 0x08,
        #[doc = "DMA Channel 8 size counter reached zero (DMASZ=0)."]
        CH8 = 0x09,
        #[doc = "DMA Channel 9 size counter reached zero (DMASZ=0)."]
        CH9 = 0x0a,
        #[doc = "DMA Channel 10 size counter reached zero (DMASZ=0)."]
        CH10 = 0x0b,
        #[doc = "DMA Channel 11 size counter reached zero (DMASZ=0)."]
        CH11 = 0x0c,
        #[doc = "DMA Channel 12 size counter reached zero (DMASZ=0)."]
        CH12 = 0x0d,
        #[doc = "DMA Channel 13 size counter reached zero (DMASZ=0)."]
        CH13 = 0x0e,
        #[doc = "DMA Channel 14 size counter reached zero (DMASZ=0)."]
        CH14 = 0x0f,
        #[doc = "DMA Channel 15 size counter reached zero (DMASZ=0)."]
        CH15 = 0x10,
        #[doc = "PRE-IRQ event for DMA Channel 0."]
        PREIRQCH0 = 0x11,
        #[doc = "PRE-IRQ event for DMA Channel 1."]
        PREIRQCH1 = 0x12,
        #[doc = "PRE-IRQ event for DMA Channel 2."]
        PREIRQCH2 = 0x13,
        #[doc = "PRE-IRQ event for DMA Channel 3."]
        PREIRQCH3 = 0x14,
        #[doc = "PRE-IRQ event for DMA Channel 4."]
        PREIRQCH4 = 0x15,
        #[doc = "PRE-IRQ event for DMA Channel 5."]
        PREIRQCH5 = 0x16,
        #[doc = "PRE-IRQ event for DMA Channel 6."]
        PREIRQCH6 = 0x17,
        #[doc = "PRE-IRQ event for DMA Channel 7."]
        PREIRQCH7 = 0x18,
        #[doc = "DMA address error, SRC address not reachable."]
        ADDRERR = 0x19,
        #[doc = "DMA data error, SRC data might be corrupted (PAR or ECC error)."]
        DATAERR = 0x1a,
        _RESERVED_1b = 0x1b,
        _RESERVED_1c = 0x1c,
        _RESERVED_1d = 0x1d,
        _RESERVED_1e = 0x1e,
        _RESERVED_1f = 0x1f,
        _RESERVED_20 = 0x20,
        _RESERVED_21 = 0x21,
        _RESERVED_22 = 0x22,
        _RESERVED_23 = 0x23,
        _RESERVED_24 = 0x24,
        _RESERVED_25 = 0x25,
        _RESERVED_26 = 0x26,
        _RESERVED_27 = 0x27,
        _RESERVED_28 = 0x28,
        _RESERVED_29 = 0x29,
        _RESERVED_2a = 0x2a,
        _RESERVED_2b = 0x2b,
        _RESERVED_2c = 0x2c,
        _RESERVED_2d = 0x2d,
        _RESERVED_2e = 0x2e,
        _RESERVED_2f = 0x2f,
        _RESERVED_30 = 0x30,
        _RESERVED_31 = 0x31,
        _RESERVED_32 = 0x32,
        _RESERVED_33 = 0x33,
        _RESERVED_34 = 0x34,
        _RESERVED_35 = 0x35,
        _RESERVED_36 = 0x36,
        _RESERVED_37 = 0x37,
        _RESERVED_38 = 0x38,
        _RESERVED_39 = 0x39,
        _RESERVED_3a = 0x3a,
        _RESERVED_3b = 0x3b,
        _RESERVED_3c = 0x3c,
        _RESERVED_3d = 0x3d,
        _RESERVED_3e = 0x3e,
        _RESERVED_3f = 0x3f,
        _RESERVED_40 = 0x40,
        _RESERVED_41 = 0x41,
        _RESERVED_42 = 0x42,
        _RESERVED_43 = 0x43,
        _RESERVED_44 = 0x44,
        _RESERVED_45 = 0x45,
        _RESERVED_46 = 0x46,
        _RESERVED_47 = 0x47,
        _RESERVED_48 = 0x48,
        _RESERVED_49 = 0x49,
        _RESERVED_4a = 0x4a,
        _RESERVED_4b = 0x4b,
        _RESERVED_4c = 0x4c,
        _RESERVED_4d = 0x4d,
        _RESERVED_4e = 0x4e,
        _RESERVED_4f = 0x4f,
        _RESERVED_50 = 0x50,
        _RESERVED_51 = 0x51,
        _RESERVED_52 = 0x52,
        _RESERVED_53 = 0x53,
        _RESERVED_54 = 0x54,
        _RESERVED_55 = 0x55,
        _RESERVED_56 = 0x56,
        _RESERVED_57 = 0x57,
        _RESERVED_58 = 0x58,
        _RESERVED_59 = 0x59,
        _RESERVED_5a = 0x5a,
        _RESERVED_5b = 0x5b,
        _RESERVED_5c = 0x5c,
        _RESERVED_5d = 0x5d,
        _RESERVED_5e = 0x5e,
        _RESERVED_5f = 0x5f,
        _RESERVED_60 = 0x60,
        _RESERVED_61 = 0x61,
        _RESERVED_62 = 0x62,
        _RESERVED_63 = 0x63,
        _RESERVED_64 = 0x64,
        _RESERVED_65 = 0x65,
        _RESERVED_66 = 0x66,
        _RESERVED_67 = 0x67,
        _RESERVED_68 = 0x68,
        _RESERVED_69 = 0x69,
        _RESERVED_6a = 0x6a,
        _RESERVED_6b = 0x6b,
        _RESERVED_6c = 0x6c,
        _RESERVED_6d = 0x6d,
        _RESERVED_6e = 0x6e,
        _RESERVED_6f = 0x6f,
        _RESERVED_70 = 0x70,
        _RESERVED_71 = 0x71,
        _RESERVED_72 = 0x72,
        _RESERVED_73 = 0x73,
        _RESERVED_74 = 0x74,
        _RESERVED_75 = 0x75,
        _RESERVED_76 = 0x76,
        _RESERVED_77 = 0x77,
        _RESERVED_78 = 0x78,
        _RESERVED_79 = 0x79,
        _RESERVED_7a = 0x7a,
        _RESERVED_7b = 0x7b,
        _RESERVED_7c = 0x7c,
        _RESERVED_7d = 0x7d,
        _RESERVED_7e = 0x7e,
        _RESERVED_7f = 0x7f,
        _RESERVED_80 = 0x80,
        _RESERVED_81 = 0x81,
        _RESERVED_82 = 0x82,
        _RESERVED_83 = 0x83,
        _RESERVED_84 = 0x84,
        _RESERVED_85 = 0x85,
        _RESERVED_86 = 0x86,
        _RESERVED_87 = 0x87,
        _RESERVED_88 = 0x88,
        _RESERVED_89 = 0x89,
        _RESERVED_8a = 0x8a,
        _RESERVED_8b = 0x8b,
        _RESERVED_8c = 0x8c,
        _RESERVED_8d = 0x8d,
        _RESERVED_8e = 0x8e,
        _RESERVED_8f = 0x8f,
        _RESERVED_90 = 0x90,
        _RESERVED_91 = 0x91,
        _RESERVED_92 = 0x92,
        _RESERVED_93 = 0x93,
        _RESERVED_94 = 0x94,
        _RESERVED_95 = 0x95,
        _RESERVED_96 = 0x96,
        _RESERVED_97 = 0x97,
        _RESERVED_98 = 0x98,
        _RESERVED_99 = 0x99,
        _RESERVED_9a = 0x9a,
        _RESERVED_9b = 0x9b,
        _RESERVED_9c = 0x9c,
        _RESERVED_9d = 0x9d,
        _RESERVED_9e = 0x9e,
        _RESERVED_9f = 0x9f,
        _RESERVED_a0 = 0xa0,
        _RESERVED_a1 = 0xa1,
        _RESERVED_a2 = 0xa2,
        _RESERVED_a3 = 0xa3,
        _RESERVED_a4 = 0xa4,
        _RESERVED_a5 = 0xa5,
        _RESERVED_a6 = 0xa6,
        _RESERVED_a7 = 0xa7,
        _RESERVED_a8 = 0xa8,
        _RESERVED_a9 = 0xa9,
        _RESERVED_aa = 0xaa,
        _RESERVED_ab = 0xab,
        _RESERVED_ac = 0xac,
        _RESERVED_ad = 0xad,
        _RESERVED_ae = 0xae,
        _RESERVED_af = 0xaf,
        _RESERVED_b0 = 0xb0,
        _RESERVED_b1 = 0xb1,
        _RESERVED_b2 = 0xb2,
        _RESERVED_b3 = 0xb3,
        _RESERVED_b4 = 0xb4,
        _RESERVED_b5 = 0xb5,
        _RESERVED_b6 = 0xb6,
        _RESERVED_b7 = 0xb7,
        _RESERVED_b8 = 0xb8,
        _RESERVED_b9 = 0xb9,
        _RESERVED_ba = 0xba,
        _RESERVED_bb = 0xbb,
        _RESERVED_bc = 0xbc,
        _RESERVED_bd = 0xbd,
        _RESERVED_be = 0xbe,
        _RESERVED_bf = 0xbf,
        _RESERVED_c0 = 0xc0,
        _RESERVED_c1 = 0xc1,
        _RESERVED_c2 = 0xc2,
        _RESERVED_c3 = 0xc3,
        _RESERVED_c4 = 0xc4,
        _RESERVED_c5 = 0xc5,
        _RESERVED_c6 = 0xc6,
        _RESERVED_c7 = 0xc7,
        _RESERVED_c8 = 0xc8,
        _RESERVED_c9 = 0xc9,
        _RESERVED_ca = 0xca,
        _RESERVED_cb = 0xcb,
        _RESERVED_cc = 0xcc,
        _RESERVED_cd = 0xcd,
        _RESERVED_ce = 0xce,
        _RESERVED_cf = 0xcf,
        _RESERVED_d0 = 0xd0,
        _RESERVED_d1 = 0xd1,
        _RESERVED_d2 = 0xd2,
        _RESERVED_d3 = 0xd3,
        _RESERVED_d4 = 0xd4,
        _RESERVED_d5 = 0xd5,
        _RESERVED_d6 = 0xd6,
        _RESERVED_d7 = 0xd7,
        _RESERVED_d8 = 0xd8,
        _RESERVED_d9 = 0xd9,
        _RESERVED_da = 0xda,
        _RESERVED_db = 0xdb,
        _RESERVED_dc = 0xdc,
        _RESERVED_dd = 0xdd,
        _RESERVED_de = 0xde,
        _RESERVED_df = 0xdf,
        _RESERVED_e0 = 0xe0,
        _RESERVED_e1 = 0xe1,
        _RESERVED_e2 = 0xe2,
        _RESERVED_e3 = 0xe3,
        _RESERVED_e4 = 0xe4,
        _RESERVED_e5 = 0xe5,
        _RESERVED_e6 = 0xe6,
        _RESERVED_e7 = 0xe7,
        _RESERVED_e8 = 0xe8,
        _RESERVED_e9 = 0xe9,
        _RESERVED_ea = 0xea,
        _RESERVED_eb = 0xeb,
        _RESERVED_ec = 0xec,
        _RESERVED_ed = 0xed,
        _RESERVED_ee = 0xee,
        _RESERVED_ef = 0xef,
        _RESERVED_f0 = 0xf0,
        _RESERVED_f1 = 0xf1,
        _RESERVED_f2 = 0xf2,
        _RESERVED_f3 = 0xf3,
        _RESERVED_f4 = 0xf4,
        _RESERVED_f5 = 0xf5,
        _RESERVED_f6 = 0xf6,
        _RESERVED_f7 = 0xf7,
        _RESERVED_f8 = 0xf8,
        _RESERVED_f9 = 0xf9,
        _RESERVED_fa = 0xfa,
        _RESERVED_fb = 0xfb,
        _RESERVED_fc = 0xfc,
        _RESERVED_fd = 0xfd,
        _RESERVED_fe = 0xfe,
        _RESERVED_ff = 0xff,
    }
    impl Stat {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Stat {
            unsafe { core::mem::transmute(val & 0xff) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Stat {
        #[inline(always)]
        fn from(val: u8) -> Stat {
            Stat::from_bits(val)
        }
    }
    impl From<Stat> for u8 {
        #[inline(always)]
        fn from(val: Stat) -> u8 {
            Stat::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Tint {
        #[doc = "DMATSEL will define external trigger select as transfer trigger."]
        EXTERNAL = 0x0,
        #[doc = "DMATSEL will define internal channel as transfer trigger select. 0-> Channel0-done, 1-> Channel1-done, ..."]
        INTERNAL = 0x01,
    }
    impl Tint {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Tint {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Tint {
        #[inline(always)]
        fn from(val: u8) -> Tint {
            Tint::from_bits(val)
        }
    }
    impl From<Tint> for u8 {
        #[inline(always)]
        fn from(val: Tint) -> u8 {
            Tint::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Tm {
        #[doc = "Single transfer. Each transfers requires a new trigger. When the DMASZ counts down to zero an event can be generated and the DMAEN is cleared."]
        SINGLE = 0x0,
        #[doc = "Block transfer. Each trigger transfers the complete block defined in DMASZ. After the transfer is complete an event can be generated and the DMAEN is cleared."]
        BLOCK = 0x01,
        #[doc = "Repeated single transfer. Each transfers requires a new trigger. When the DMASZ counts down to zero an event can be generated. After the last transfer the DMASA, DMADA, DAMSZ registers are restored to its initial value and the DMAEN stays enabled."]
        RPTSNGL = 0x02,
        #[doc = "Repeated block transfer. Each trigger transfers the complete block defined in DMASZ. After the last transfer the DMASA, DMADA, DAMSZ registers are restored to its initial value and the DMAEN stays enabled."]
        RPTBLCK = 0x03,
    }
    impl Tm {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Tm {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Tm {
        #[inline(always)]
        fn from(val: u8) -> Tm {
            Tm::from_bits(val)
        }
    }
    impl From<Tm> for u8 {
        #[inline(always)]
        fn from(val: Tm) -> u8 {
            Tm::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Wdth {
        #[doc = "Destination data width is BYTE (8-bit)."]
        BYTE = 0x0,
        #[doc = "Destination data width is HALF-WORD (16-bit)."]
        HALF = 0x01,
        #[doc = "Destination data width is WORD (32-bit)."]
        WORD = 0x02,
        #[doc = "Destination data width is LONG-WORD (64-bit)."]
        LONG = 0x03,
    }
    impl Wdth {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Wdth {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Wdth {
        #[inline(always)]
        fn from(val: u8) -> Wdth {
            Wdth::from_bits(val)
        }
    }
    impl From<Wdth> for u8 {
        #[inline(always)]
        fn from(val: Wdth) -> u8 {
            Wdth::to_bits(val)
        }
    }
}
