// This file is autogenerated by mspm0-metapac-gen: do not edit by hand.
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::identity_op)]
#![allow(clippy::unnecessary_cast)]
#![allow(clippy::erasing_op)]

#[doc = "CPU subsystem"]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Cpuss {
    ptr: *mut u8,
}
unsafe impl Send for Cpuss {}
unsafe impl Sync for Cpuss {}
impl Cpuss {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Event Mode."]
    #[inline(always)]
    pub const fn evt_mode(self) -> crate::common::Reg<regs::EvtMode, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10e0usize) as _) }
    }
    #[doc = "Module Description."]
    #[inline(always)]
    pub const fn desc(self) -> crate::common::Reg<regs::Desc, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10fcusize) as _) }
    }
    #[doc = "CPUSS Interrupt group (x = 0..2). Depending on the model, the later elements of this array may be undefined. For C110x only index 0 is valid. Meanwhile for L222x indices 0 and 1 are valid."]
    #[inline(always)]
    pub const fn int_group(self, n: usize) -> IntGroup {
        assert!(n < 2usize);
        unsafe { IntGroup::from_ptr(self.ptr.add(0x1100usize + n * 48usize) as _) }
    }
    #[doc = "Prefetch/Cache control."]
    #[inline(always)]
    pub const fn ctl(self) -> crate::common::Reg<regs::Ctl, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1300usize) as _) }
    }
}
#[doc = "Interrupt group."]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct IntGroup {
    ptr: *mut u8,
}
unsafe impl Send for IntGroup {}
unsafe impl Sync for IntGroup {}
impl IntGroup {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Interrupt index"]
    #[inline(always)]
    pub const fn iidx(self) -> crate::common::Reg<regs::Iidx, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "Interrupt mask."]
    #[inline(always)]
    pub const fn imask(self) -> crate::common::Reg<regs::Imask, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
    }
    #[doc = "Raw interrupt status."]
    #[inline(always)]
    pub const fn ris(self) -> crate::common::Reg<regs::Ris, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
    }
    #[doc = "Masked interrupt status."]
    #[inline(always)]
    pub const fn mis(self) -> crate::common::Reg<regs::Mis, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
    }
    #[doc = "Interrupt set."]
    #[inline(always)]
    pub const fn iset(self) -> crate::common::Reg<regs::Iset, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
    }
    #[doc = "Interrupt clear."]
    #[inline(always)]
    pub const fn iclr(self) -> crate::common::Reg<regs::Iclr, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
    }
}
pub mod regs {
    #[doc = "Prefetch/Cache control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ctl(pub u32);
    impl Ctl {
        #[doc = "Used to enable/disable instruction prefetch to Flash."]
        #[inline(always)]
        pub const fn prefetch(&self) -> super::vals::Prefetch {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Prefetch::from_bits(val as u8)
        }
        #[doc = "Used to enable/disable instruction prefetch to Flash."]
        #[inline(always)]
        pub fn set_prefetch(&mut self, val: super::vals::Prefetch) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "Used to enable/disable Instruction caching on flash access."]
        #[inline(always)]
        pub const fn icache(&self) -> super::vals::Icache {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Icache::from_bits(val as u8)
        }
        #[doc = "Used to enable/disable Instruction caching on flash access."]
        #[inline(always)]
        pub fn set_icache(&mut self, val: super::vals::Icache) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "Literal caching and prefetch enable. This bit is a subset of ICACHE/PREFETCH bit i.e. literal caching or literal prefetching will only happen if ICACHE or PREFETCH bits have been set respectively When enabled, the cache and prefetcher structures inside CPUSS will cache and prefetch literals When disabled, the cache and prefetcher structures inside CPUSS will not cache and prefetch literals."]
        #[inline(always)]
        pub const fn liten(&self) -> super::vals::Liten {
            let val = (self.0 >> 2usize) & 0x01;
            super::vals::Liten::from_bits(val as u8)
        }
        #[doc = "Literal caching and prefetch enable. This bit is a subset of ICACHE/PREFETCH bit i.e. literal caching or literal prefetching will only happen if ICACHE or PREFETCH bits have been set respectively When enabled, the cache and prefetcher structures inside CPUSS will cache and prefetch literals When disabled, the cache and prefetcher structures inside CPUSS will not cache and prefetch literals."]
        #[inline(always)]
        pub fn set_liten(&mut self, val: super::vals::Liten) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
        }
    }
    impl Default for Ctl {
        #[inline(always)]
        fn default() -> Ctl {
            Ctl(0)
        }
    }
    #[doc = "Module Description."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Desc(pub u32);
    impl Desc {
        #[doc = "Minor rev of the IP."]
        #[inline(always)]
        pub const fn minrev(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x0f;
            val as u8
        }
        #[doc = "Minor rev of the IP."]
        #[inline(always)]
        pub fn set_minrev(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
        }
        #[doc = "Major rev of the IP."]
        #[inline(always)]
        pub const fn majrev(&self) -> u8 {
            let val = (self.0 >> 4usize) & 0x0f;
            val as u8
        }
        #[doc = "Major rev of the IP."]
        #[inline(always)]
        pub fn set_majrev(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
        }
        #[doc = "Feature Set for the module *instance*."]
        #[inline(always)]
        pub const fn featurever(&self) -> u8 {
            let val = (self.0 >> 12usize) & 0x0f;
            val as u8
        }
        #[doc = "Feature Set for the module *instance*."]
        #[inline(always)]
        pub fn set_featurever(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
        }
        #[doc = "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness."]
        #[inline(always)]
        pub const fn moduleid(&self) -> u16 {
            let val = (self.0 >> 16usize) & 0xffff;
            val as u16
        }
        #[doc = "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness."]
        #[inline(always)]
        pub fn set_moduleid(&mut self, val: u16) {
            self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
        }
    }
    impl Default for Desc {
        #[inline(always)]
        fn default() -> Desc {
            Desc(0)
        }
    }
    #[doc = "Event Mode."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EvtMode(pub u32);
    impl EvtMode {
        #[doc = "Event line mode select."]
        #[inline(always)]
        pub const fn int_cfg(&self) -> super::vals::IntCfg {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::IntCfg::from_bits(val as u8)
        }
        #[doc = "Event line mode select."]
        #[inline(always)]
        pub fn set_int_cfg(&mut self, val: super::vals::IntCfg) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
    }
    impl Default for EvtMode {
        #[inline(always)]
        fn default() -> EvtMode {
            EvtMode(0)
        }
    }
    #[doc = "Interrupt clear."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iclr(pub u32);
    impl Iclr {
        #[doc = "Clears INT in RIS register."]
        #[inline(always)]
        pub const fn int(&self) -> super::vals::Iclr {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Iclr::from_bits(val as u8)
        }
        #[doc = "Clears INT in RIS register."]
        #[inline(always)]
        pub fn set_int(&mut self, val: super::vals::Iclr) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Iclr {
        #[inline(always)]
        fn default() -> Iclr {
            Iclr(0)
        }
    }
    #[doc = "Interrupt index."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iidx(pub u32);
    impl Iidx {
        #[doc = "Interrupt index status."]
        #[inline(always)]
        pub const fn stat(&self) -> super::vals::Iidx {
            let val = (self.0 >> 0usize) & 0xff;
            super::vals::Iidx::from_bits(val as u8)
        }
        #[doc = "Interrupt index status."]
        #[inline(always)]
        pub fn set_stat(&mut self, val: super::vals::Iidx) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
        }
    }
    impl Default for Iidx {
        #[inline(always)]
        fn default() -> Iidx {
            Iidx(0)
        }
    }
    #[doc = "Interrupt mask."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Imask(pub u32);
    impl Imask {
        #[doc = "Masks the corresponding interrupt."]
        #[inline(always)]
        pub const fn int(&self) -> super::vals::Imask {
            let val = (self.0 >> 0usize) & 0xff;
            super::vals::Imask::from_bits(val as u8)
        }
        #[doc = "Masks the corresponding interrupt."]
        #[inline(always)]
        pub fn set_int(&mut self, val: super::vals::Imask) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
        }
    }
    impl Default for Imask {
        #[inline(always)]
        fn default() -> Imask {
            Imask(0)
        }
    }
    #[doc = "Interrupt set."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iset(pub u32);
    impl Iset {
        #[doc = "Sets INT in RIS register."]
        #[inline(always)]
        pub const fn int(&self) -> super::vals::Iset {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Iset::from_bits(val as u8)
        }
        #[doc = "Sets INT in RIS register."]
        #[inline(always)]
        pub fn set_int(&mut self, val: super::vals::Iset) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Iset {
        #[inline(always)]
        fn default() -> Iset {
            Iset(0)
        }
    }
    #[doc = "Masked interrupt status."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Mis(pub u32);
    impl Mis {
        #[doc = "Masked interrupt status for INT."]
        #[inline(always)]
        pub const fn int(&self) -> super::vals::Mis {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Mis::from_bits(val as u8)
        }
        #[doc = "Masked interrupt status for INT."]
        #[inline(always)]
        pub fn set_int(&mut self, val: super::vals::Mis) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Mis {
        #[inline(always)]
        fn default() -> Mis {
            Mis(0)
        }
    }
    #[doc = "Raw interrupt status."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ris(pub u32);
    impl Ris {
        #[doc = "Raw interrupt status for INT."]
        #[inline(always)]
        pub const fn int(&self) -> super::vals::Ris {
            let val = (self.0 >> 0usize) & 0xff;
            super::vals::Ris::from_bits(val as u8)
        }
        #[doc = "Raw interrupt status for INT."]
        #[inline(always)]
        pub fn set_int(&mut self, val: super::vals::Ris) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
        }
    }
    impl Default for Ris {
        #[inline(always)]
        fn default() -> Ris {
            Ris(0)
        }
    }
}
pub mod vals {
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Icache {
        #[doc = "Disable instruction caching."]
        DISABLE = 0x0,
        #[doc = "Enable instruction caching."]
        ENABLE = 0x01,
    }
    impl Icache {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Icache {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Icache {
        #[inline(always)]
        fn from(val: u8) -> Icache {
            Icache::from_bits(val)
        }
    }
    impl From<Icache> for u8 {
        #[inline(always)]
        fn from(val: Icache) -> u8 {
            Icache::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Iclr {
        #[doc = "Writing a 0 has no effect."]
        NO_EFFECT = 0x0,
        #[doc = "RIS bit corresponding to INT is cleared."]
        CLR = 0x01,
    }
    impl Iclr {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Iclr {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Iclr {
        #[inline(always)]
        fn from(val: u8) -> Iclr {
            Iclr::from_bits(val)
        }
    }
    impl From<Iclr> for u8 {
        #[inline(always)]
        fn from(val: Iclr) -> u8 {
            Iclr::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Iidx {
        #[doc = "No pending interrupt."]
        NO_INTR = 0x0,
        #[doc = "Interrupt 0."]
        INT0 = 0x01,
        #[doc = "Interrupt 1."]
        INT1 = 0x02,
        #[doc = "Interrupt 2."]
        INT2 = 0x03,
        #[doc = "Interrupt 3."]
        INT3 = 0x04,
        #[doc = "Interrupt 4."]
        INT4 = 0x05,
        #[doc = "Interrupt 5."]
        INT5 = 0x06,
        #[doc = "Interrupt 6."]
        INT6 = 0x07,
        #[doc = "Interrupt 7."]
        INT7 = 0x08,
        _RESERVED_9 = 0x09,
        _RESERVED_a = 0x0a,
        _RESERVED_b = 0x0b,
        _RESERVED_c = 0x0c,
        _RESERVED_d = 0x0d,
        _RESERVED_e = 0x0e,
        _RESERVED_f = 0x0f,
        _RESERVED_10 = 0x10,
        _RESERVED_11 = 0x11,
        _RESERVED_12 = 0x12,
        _RESERVED_13 = 0x13,
        _RESERVED_14 = 0x14,
        _RESERVED_15 = 0x15,
        _RESERVED_16 = 0x16,
        _RESERVED_17 = 0x17,
        _RESERVED_18 = 0x18,
        _RESERVED_19 = 0x19,
        _RESERVED_1a = 0x1a,
        _RESERVED_1b = 0x1b,
        _RESERVED_1c = 0x1c,
        _RESERVED_1d = 0x1d,
        _RESERVED_1e = 0x1e,
        _RESERVED_1f = 0x1f,
        _RESERVED_20 = 0x20,
        _RESERVED_21 = 0x21,
        _RESERVED_22 = 0x22,
        _RESERVED_23 = 0x23,
        _RESERVED_24 = 0x24,
        _RESERVED_25 = 0x25,
        _RESERVED_26 = 0x26,
        _RESERVED_27 = 0x27,
        _RESERVED_28 = 0x28,
        _RESERVED_29 = 0x29,
        _RESERVED_2a = 0x2a,
        _RESERVED_2b = 0x2b,
        _RESERVED_2c = 0x2c,
        _RESERVED_2d = 0x2d,
        _RESERVED_2e = 0x2e,
        _RESERVED_2f = 0x2f,
        _RESERVED_30 = 0x30,
        _RESERVED_31 = 0x31,
        _RESERVED_32 = 0x32,
        _RESERVED_33 = 0x33,
        _RESERVED_34 = 0x34,
        _RESERVED_35 = 0x35,
        _RESERVED_36 = 0x36,
        _RESERVED_37 = 0x37,
        _RESERVED_38 = 0x38,
        _RESERVED_39 = 0x39,
        _RESERVED_3a = 0x3a,
        _RESERVED_3b = 0x3b,
        _RESERVED_3c = 0x3c,
        _RESERVED_3d = 0x3d,
        _RESERVED_3e = 0x3e,
        _RESERVED_3f = 0x3f,
        _RESERVED_40 = 0x40,
        _RESERVED_41 = 0x41,
        _RESERVED_42 = 0x42,
        _RESERVED_43 = 0x43,
        _RESERVED_44 = 0x44,
        _RESERVED_45 = 0x45,
        _RESERVED_46 = 0x46,
        _RESERVED_47 = 0x47,
        _RESERVED_48 = 0x48,
        _RESERVED_49 = 0x49,
        _RESERVED_4a = 0x4a,
        _RESERVED_4b = 0x4b,
        _RESERVED_4c = 0x4c,
        _RESERVED_4d = 0x4d,
        _RESERVED_4e = 0x4e,
        _RESERVED_4f = 0x4f,
        _RESERVED_50 = 0x50,
        _RESERVED_51 = 0x51,
        _RESERVED_52 = 0x52,
        _RESERVED_53 = 0x53,
        _RESERVED_54 = 0x54,
        _RESERVED_55 = 0x55,
        _RESERVED_56 = 0x56,
        _RESERVED_57 = 0x57,
        _RESERVED_58 = 0x58,
        _RESERVED_59 = 0x59,
        _RESERVED_5a = 0x5a,
        _RESERVED_5b = 0x5b,
        _RESERVED_5c = 0x5c,
        _RESERVED_5d = 0x5d,
        _RESERVED_5e = 0x5e,
        _RESERVED_5f = 0x5f,
        _RESERVED_60 = 0x60,
        _RESERVED_61 = 0x61,
        _RESERVED_62 = 0x62,
        _RESERVED_63 = 0x63,
        _RESERVED_64 = 0x64,
        _RESERVED_65 = 0x65,
        _RESERVED_66 = 0x66,
        _RESERVED_67 = 0x67,
        _RESERVED_68 = 0x68,
        _RESERVED_69 = 0x69,
        _RESERVED_6a = 0x6a,
        _RESERVED_6b = 0x6b,
        _RESERVED_6c = 0x6c,
        _RESERVED_6d = 0x6d,
        _RESERVED_6e = 0x6e,
        _RESERVED_6f = 0x6f,
        _RESERVED_70 = 0x70,
        _RESERVED_71 = 0x71,
        _RESERVED_72 = 0x72,
        _RESERVED_73 = 0x73,
        _RESERVED_74 = 0x74,
        _RESERVED_75 = 0x75,
        _RESERVED_76 = 0x76,
        _RESERVED_77 = 0x77,
        _RESERVED_78 = 0x78,
        _RESERVED_79 = 0x79,
        _RESERVED_7a = 0x7a,
        _RESERVED_7b = 0x7b,
        _RESERVED_7c = 0x7c,
        _RESERVED_7d = 0x7d,
        _RESERVED_7e = 0x7e,
        _RESERVED_7f = 0x7f,
        _RESERVED_80 = 0x80,
        _RESERVED_81 = 0x81,
        _RESERVED_82 = 0x82,
        _RESERVED_83 = 0x83,
        _RESERVED_84 = 0x84,
        _RESERVED_85 = 0x85,
        _RESERVED_86 = 0x86,
        _RESERVED_87 = 0x87,
        _RESERVED_88 = 0x88,
        _RESERVED_89 = 0x89,
        _RESERVED_8a = 0x8a,
        _RESERVED_8b = 0x8b,
        _RESERVED_8c = 0x8c,
        _RESERVED_8d = 0x8d,
        _RESERVED_8e = 0x8e,
        _RESERVED_8f = 0x8f,
        _RESERVED_90 = 0x90,
        _RESERVED_91 = 0x91,
        _RESERVED_92 = 0x92,
        _RESERVED_93 = 0x93,
        _RESERVED_94 = 0x94,
        _RESERVED_95 = 0x95,
        _RESERVED_96 = 0x96,
        _RESERVED_97 = 0x97,
        _RESERVED_98 = 0x98,
        _RESERVED_99 = 0x99,
        _RESERVED_9a = 0x9a,
        _RESERVED_9b = 0x9b,
        _RESERVED_9c = 0x9c,
        _RESERVED_9d = 0x9d,
        _RESERVED_9e = 0x9e,
        _RESERVED_9f = 0x9f,
        _RESERVED_a0 = 0xa0,
        _RESERVED_a1 = 0xa1,
        _RESERVED_a2 = 0xa2,
        _RESERVED_a3 = 0xa3,
        _RESERVED_a4 = 0xa4,
        _RESERVED_a5 = 0xa5,
        _RESERVED_a6 = 0xa6,
        _RESERVED_a7 = 0xa7,
        _RESERVED_a8 = 0xa8,
        _RESERVED_a9 = 0xa9,
        _RESERVED_aa = 0xaa,
        _RESERVED_ab = 0xab,
        _RESERVED_ac = 0xac,
        _RESERVED_ad = 0xad,
        _RESERVED_ae = 0xae,
        _RESERVED_af = 0xaf,
        _RESERVED_b0 = 0xb0,
        _RESERVED_b1 = 0xb1,
        _RESERVED_b2 = 0xb2,
        _RESERVED_b3 = 0xb3,
        _RESERVED_b4 = 0xb4,
        _RESERVED_b5 = 0xb5,
        _RESERVED_b6 = 0xb6,
        _RESERVED_b7 = 0xb7,
        _RESERVED_b8 = 0xb8,
        _RESERVED_b9 = 0xb9,
        _RESERVED_ba = 0xba,
        _RESERVED_bb = 0xbb,
        _RESERVED_bc = 0xbc,
        _RESERVED_bd = 0xbd,
        _RESERVED_be = 0xbe,
        _RESERVED_bf = 0xbf,
        _RESERVED_c0 = 0xc0,
        _RESERVED_c1 = 0xc1,
        _RESERVED_c2 = 0xc2,
        _RESERVED_c3 = 0xc3,
        _RESERVED_c4 = 0xc4,
        _RESERVED_c5 = 0xc5,
        _RESERVED_c6 = 0xc6,
        _RESERVED_c7 = 0xc7,
        _RESERVED_c8 = 0xc8,
        _RESERVED_c9 = 0xc9,
        _RESERVED_ca = 0xca,
        _RESERVED_cb = 0xcb,
        _RESERVED_cc = 0xcc,
        _RESERVED_cd = 0xcd,
        _RESERVED_ce = 0xce,
        _RESERVED_cf = 0xcf,
        _RESERVED_d0 = 0xd0,
        _RESERVED_d1 = 0xd1,
        _RESERVED_d2 = 0xd2,
        _RESERVED_d3 = 0xd3,
        _RESERVED_d4 = 0xd4,
        _RESERVED_d5 = 0xd5,
        _RESERVED_d6 = 0xd6,
        _RESERVED_d7 = 0xd7,
        _RESERVED_d8 = 0xd8,
        _RESERVED_d9 = 0xd9,
        _RESERVED_da = 0xda,
        _RESERVED_db = 0xdb,
        _RESERVED_dc = 0xdc,
        _RESERVED_dd = 0xdd,
        _RESERVED_de = 0xde,
        _RESERVED_df = 0xdf,
        _RESERVED_e0 = 0xe0,
        _RESERVED_e1 = 0xe1,
        _RESERVED_e2 = 0xe2,
        _RESERVED_e3 = 0xe3,
        _RESERVED_e4 = 0xe4,
        _RESERVED_e5 = 0xe5,
        _RESERVED_e6 = 0xe6,
        _RESERVED_e7 = 0xe7,
        _RESERVED_e8 = 0xe8,
        _RESERVED_e9 = 0xe9,
        _RESERVED_ea = 0xea,
        _RESERVED_eb = 0xeb,
        _RESERVED_ec = 0xec,
        _RESERVED_ed = 0xed,
        _RESERVED_ee = 0xee,
        _RESERVED_ef = 0xef,
        _RESERVED_f0 = 0xf0,
        _RESERVED_f1 = 0xf1,
        _RESERVED_f2 = 0xf2,
        _RESERVED_f3 = 0xf3,
        _RESERVED_f4 = 0xf4,
        _RESERVED_f5 = 0xf5,
        _RESERVED_f6 = 0xf6,
        _RESERVED_f7 = 0xf7,
        _RESERVED_f8 = 0xf8,
        _RESERVED_f9 = 0xf9,
        _RESERVED_fa = 0xfa,
        _RESERVED_fb = 0xfb,
        _RESERVED_fc = 0xfc,
        _RESERVED_fd = 0xfd,
        _RESERVED_fe = 0xfe,
        _RESERVED_ff = 0xff,
    }
    impl Iidx {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Iidx {
            unsafe { core::mem::transmute(val & 0xff) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Iidx {
        #[inline(always)]
        fn from(val: u8) -> Iidx {
            Iidx::from_bits(val)
        }
    }
    impl From<Iidx> for u8 {
        #[inline(always)]
        fn from(val: Iidx) -> u8 {
            Iidx::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Imask(pub u8);
    impl Imask {
        #[doc = "Interrupt is masked out."]
        pub const CLR: Self = Self(0x0);
        #[doc = "Interrupt will request an interrupt service routine and corresponding bit in MIS will be set."]
        pub const SET: Self = Self(0x01);
    }
    impl Imask {
        pub const fn from_bits(val: u8) -> Imask {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for Imask {
        #[inline(always)]
        fn from(val: u8) -> Imask {
            Imask::from_bits(val)
        }
    }
    impl From<Imask> for u8 {
        #[inline(always)]
        fn from(val: Imask) -> u8 {
            Imask::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum IntCfg {
        #[doc = "The interrupt or event line is disabled."]
        DISABLE = 0x0,
        #[doc = "Event handled by software. Software must clear the associated RIS flag."]
        SOFTWARE = 0x01,
        #[doc = "Event handled by hardware. The hardware (another module) clears automatically the associated RIS flag."]
        HARDWARE = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl IntCfg {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> IntCfg {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for IntCfg {
        #[inline(always)]
        fn from(val: u8) -> IntCfg {
            IntCfg::from_bits(val)
        }
    }
    impl From<IntCfg> for u8 {
        #[inline(always)]
        fn from(val: IntCfg) -> u8 {
            IntCfg::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Iset {
        #[doc = "Writing a 0 has no effect."]
        NO_EFFECT = 0x0,
        #[doc = "RIS bit corresponding to INT is set."]
        SET = 0x01,
    }
    impl Iset {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Iset {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Iset {
        #[inline(always)]
        fn from(val: u8) -> Iset {
            Iset::from_bits(val)
        }
    }
    impl From<Iset> for u8 {
        #[inline(always)]
        fn from(val: Iset) -> u8 {
            Iset::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Liten {
        #[doc = "Literal caching disabled."]
        DISABLE = 0x0,
        #[doc = "Literal caching enabled."]
        ENABLE = 0x01,
    }
    impl Liten {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Liten {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Liten {
        #[inline(always)]
        fn from(val: u8) -> Liten {
            Liten::from_bits(val)
        }
    }
    impl From<Liten> for u8 {
        #[inline(always)]
        fn from(val: Liten) -> u8 {
            Liten::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Mis {
        #[doc = "INT does not request an interrupt service routine."]
        CLR = 0x0,
        #[doc = "INT requests an interrupt service routine."]
        SET = 0x01,
    }
    impl Mis {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Mis {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Mis {
        #[inline(always)]
        fn from(val: u8) -> Mis {
            Mis::from_bits(val)
        }
    }
    impl From<Mis> for u8 {
        #[inline(always)]
        fn from(val: Mis) -> u8 {
            Mis::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Prefetch {
        #[doc = "Disable instruction prefetch."]
        DISABLE = 0x0,
        #[doc = "Enable instruction prefetch."]
        ENABLE = 0x01,
    }
    impl Prefetch {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Prefetch {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Prefetch {
        #[inline(always)]
        fn from(val: u8) -> Prefetch {
            Prefetch::from_bits(val)
        }
    }
    impl From<Prefetch> for u8 {
        #[inline(always)]
        fn from(val: Prefetch) -> u8 {
            Prefetch::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Ris(pub u8);
    impl Ris {
        #[doc = "INT did not occur."]
        pub const CLR: Self = Self(0x0);
        #[doc = "INT occurred."]
        pub const SET: Self = Self(0x01);
    }
    impl Ris {
        pub const fn from_bits(val: u8) -> Ris {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for Ris {
        #[inline(always)]
        fn from(val: u8) -> Ris {
            Ris::from_bits(val)
        }
    }
    impl From<Ris> for u8 {
        #[inline(always)]
        fn from(val: Ris) -> u8 {
            Ris::to_bits(val)
        }
    }
}
