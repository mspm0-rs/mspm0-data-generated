// This file is autogenerated by mspm0-metapac-gen: do not edit by hand.
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::identity_op)]
#![allow(clippy::unnecessary_cast)]
#![allow(clippy::erasing_op)]

#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Gprcm {
    ptr: *mut u8,
}
unsafe impl Send for Gprcm {}
unsafe impl Sync for Gprcm {}
impl Gprcm {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Power enable."]
    #[inline(always)]
    pub const fn pwren(self) -> crate::common::Reg<regs::Pwren, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "Reset Control."]
    #[inline(always)]
    pub const fn rstctl(self) -> crate::common::Reg<regs::Rstctl, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
    }
    #[doc = "Status Register."]
    #[inline(always)]
    pub const fn stat(self) -> crate::common::Reg<regs::Stat, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
    }
}
#[doc = "PERIPHERALREGION."]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mathacl {
    ptr: *mut u8,
}
unsafe impl Send for Mathacl {}
unsafe impl Sync for Mathacl {}
impl Mathacl {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[inline(always)]
    pub const fn gprcm(self, n: usize) -> Gprcm {
        assert!(n < 1usize);
        unsafe { Gprcm::from_ptr(self.ptr.add(0x0800usize + n * 24usize) as _) }
    }
    #[doc = "Control Register."]
    #[inline(always)]
    pub const fn ctl(self) -> crate::common::Reg<regs::Ctl, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1100usize) as _) }
    }
    #[doc = "Operand 2 register."]
    #[inline(always)]
    pub const fn op2(self) -> crate::common::Reg<regs::Op2, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1118usize) as _) }
    }
    #[doc = "Operand 1 register."]
    #[inline(always)]
    pub const fn op1(self) -> crate::common::Reg<regs::Op1, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x111cusize) as _) }
    }
    #[doc = "Result 1 register."]
    #[inline(always)]
    pub const fn res1(self) -> crate::common::Reg<regs::Res1, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1120usize) as _) }
    }
    #[doc = "Result 2 register."]
    #[inline(always)]
    pub const fn res2(self) -> crate::common::Reg<regs::Res2, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1124usize) as _) }
    }
    #[doc = "Status Register."]
    #[inline(always)]
    pub const fn status(self) -> crate::common::Reg<regs::Status, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1130usize) as _) }
    }
    #[doc = "Status flag clear register."]
    #[inline(always)]
    pub const fn statusclr(self) -> crate::common::Reg<regs::Statusclr, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1140usize) as _) }
    }
}
pub mod regs {
    #[doc = "Control Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ctl(pub u32);
    impl Ctl {
        #[doc = "ULP_ADCHP Enable Conversions."]
        #[inline(always)]
        pub const fn func(&self) -> super::vals::Func {
            let val = (self.0 >> 0usize) & 0x1f;
            super::vals::Func::from_bits(val as u8)
        }
        #[doc = "ULP_ADCHP Enable Conversions."]
        #[inline(always)]
        pub fn set_func(&mut self, val: super::vals::Func) {
            self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u32) & 0x1f) << 0usize);
        }
        #[doc = "Operand type, could signed or unsigned. applicable to DIV function."]
        #[inline(always)]
        pub const fn optype(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Operand type, could signed or unsigned. applicable to DIV function."]
        #[inline(always)]
        pub fn set_optype(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "Indicates the fractional bits in the operands, ranges from 0 to 31. Applicable to DIV function."]
        #[inline(always)]
        pub const fn qval(&self) -> super::vals::Qval {
            let val = (self.0 >> 8usize) & 0x1f;
            super::vals::Qval::from_bits(val as u8)
        }
        #[doc = "Indicates the fractional bits in the operands, ranges from 0 to 31. Applicable to DIV function."]
        #[inline(always)]
        pub fn set_qval(&mut self, val: super::vals::Qval) {
            self.0 = (self.0 & !(0x1f << 8usize)) | (((val.to_bits() as u32) & 0x1f) << 8usize);
        }
        #[doc = "Scaling factor. In case of SQRT function, the input operand needs to be in a range. If not it has to be scaled to 2^(+/-n). This field should be written with the value 'n'."]
        #[inline(always)]
        pub const fn sfactor(&self) -> u8 {
            let val = (self.0 >> 16usize) & 0x3f;
            val as u8
        }
        #[doc = "Scaling factor. In case of SQRT function, the input operand needs to be in a range. If not it has to be scaled to 2^(+/-n). This field should be written with the value 'n'."]
        #[inline(always)]
        pub fn set_sfactor(&mut self, val: u8) {
            self.0 = (self.0 & !(0x3f << 16usize)) | (((val as u32) & 0x3f) << 16usize);
        }
        #[doc = "Saturation enable This bit is shared among DIV, SQUARE32, MPY32, MAC and SAC functions. When enabled, it will make the result to saturate to maximum value in case of an overflow event When disabled, the result will overflow to an unknown value."]
        #[inline(always)]
        pub const fn saten(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "Saturation enable This bit is shared among DIV, SQUARE32, MPY32, MAC and SAC functions. When enabled, it will make the result to saturate to maximum value in case of an overflow event When disabled, the result will overflow to an unknown value."]
        #[inline(always)]
        pub fn set_saten(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
        #[doc = "Number of iterations, applicable if the function does the computations iteratively, for example sine/cosine/atan2/sqrt. Note: A value of 0 is interpreted as 31."]
        #[inline(always)]
        pub const fn numiter(&self) -> u8 {
            let val = (self.0 >> 24usize) & 0x1f;
            val as u8
        }
        #[doc = "Number of iterations, applicable if the function does the computations iteratively, for example sine/cosine/atan2/sqrt. Note: A value of 0 is interpreted as 31."]
        #[inline(always)]
        pub fn set_numiter(&mut self, val: u8) {
            self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
        }
    }
    impl Default for Ctl {
        #[inline(always)]
        fn default() -> Ctl {
            Ctl(0)
        }
    }
    #[doc = "Operand 1 register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Op1(pub u32);
    impl Op1 {
        #[doc = "Operand 1 Register"]
        #[inline(always)]
        pub const fn data(&self) -> u32 {
            let val = (self.0 >> 0usize) & 0xffff_ffff;
            val as u32
        }
        #[doc = "Operand 1 Register"]
        #[inline(always)]
        pub fn set_data(&mut self, val: u32) {
            self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
        }
    }
    impl Default for Op1 {
        #[inline(always)]
        fn default() -> Op1 {
            Op1(0)
        }
    }
    #[doc = "Operand 2 register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Op2(pub u32);
    impl Op2 {
        #[doc = "Operand 1 Register"]
        #[inline(always)]
        pub const fn data(&self) -> u32 {
            let val = (self.0 >> 0usize) & 0xffff_ffff;
            val as u32
        }
        #[doc = "Operand 1 Register"]
        #[inline(always)]
        pub fn set_data(&mut self, val: u32) {
            self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
        }
    }
    impl Default for Op2 {
        #[inline(always)]
        fn default() -> Op2 {
            Op2(0)
        }
    }
    #[doc = "Power enable."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pwren(pub u32);
    impl Pwren {
        #[doc = "Enable the power."]
        #[inline(always)]
        pub const fn enable(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Enable the power."]
        #[inline(always)]
        pub fn set_enable(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "KEY to allow Power State Change 26h = KEY to allow write access to this register"]
        #[inline(always)]
        pub const fn key(&self) -> super::vals::PwrenKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::PwrenKey::from_bits(val as u8)
        }
        #[doc = "KEY to allow Power State Change 26h = KEY to allow write access to this register"]
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::PwrenKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Pwren {
        #[inline(always)]
        fn default() -> Pwren {
            Pwren(0)
        }
    }
    #[doc = "Result 1 register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Res1(pub u32);
    impl Res1 {
        #[doc = "Result 1 Register"]
        #[inline(always)]
        pub const fn data(&self) -> u32 {
            let val = (self.0 >> 0usize) & 0xffff_ffff;
            val as u32
        }
        #[doc = "Result 1 Register"]
        #[inline(always)]
        pub fn set_data(&mut self, val: u32) {
            self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
        }
    }
    impl Default for Res1 {
        #[inline(always)]
        fn default() -> Res1 {
            Res1(0)
        }
    }
    #[doc = "Result 2 register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Res2(pub u32);
    impl Res2 {
        #[doc = "Result 2 Register"]
        #[inline(always)]
        pub const fn data(&self) -> u32 {
            let val = (self.0 >> 0usize) & 0xffff_ffff;
            val as u32
        }
        #[doc = "Result 2 Register"]
        #[inline(always)]
        pub fn set_data(&mut self, val: u32) {
            self.0 = (self.0 & !(0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize);
        }
    }
    impl Default for Res2 {
        #[inline(always)]
        fn default() -> Res2 {
            Res2(0)
        }
    }
    #[doc = "Reset Control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rstctl(pub u32);
    impl Rstctl {
        #[doc = "Assert reset to the peripheral."]
        #[inline(always)]
        pub const fn resetassert(&self) -> super::vals::Resetassert {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Resetassert::from_bits(val as u8)
        }
        #[doc = "Assert reset to the peripheral."]
        #[inline(always)]
        pub fn set_resetassert(&mut self, val: super::vals::Resetassert) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "Clear the RESETSTKY bit in the STAT register."]
        #[inline(always)]
        pub const fn resetstkyclr(&self) -> super::vals::Resetstkyclr {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::Resetstkyclr::from_bits(val as u8)
        }
        #[doc = "Clear the RESETSTKY bit in the STAT register."]
        #[inline(always)]
        pub fn set_resetstkyclr(&mut self, val: super::vals::Resetstkyclr) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
        #[doc = "Unlock key B1h = KEY to allow write access to this register"]
        #[inline(always)]
        pub const fn key(&self) -> super::vals::ResetKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::ResetKey::from_bits(val as u8)
        }
        #[doc = "Unlock key B1h = KEY to allow write access to this register"]
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::ResetKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Rstctl {
        #[inline(always)]
        fn default() -> Rstctl {
            Rstctl(0)
        }
    }
    #[doc = "Status Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Stat(pub u32);
    impl Stat {
        #[doc = "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register."]
        #[inline(always)]
        pub const fn resetstky(&self) -> super::vals::Resetstky {
            let val = (self.0 >> 16usize) & 0x01;
            super::vals::Resetstky::from_bits(val as u8)
        }
        #[doc = "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register."]
        #[inline(always)]
        pub fn set_resetstky(&mut self, val: super::vals::Resetstky) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
        }
    }
    impl Default for Stat {
        #[inline(always)]
        fn default() -> Stat {
            Stat(0)
        }
    }
    #[doc = "Status Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Status(pub u32);
    impl Status {
        #[doc = "Underflow Flag."]
        #[inline(always)]
        pub const fn uf(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Underflow Flag."]
        #[inline(always)]
        pub fn set_uf(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Overflow bit for MPY32, SQUARE32, DIV, MAC, and SAC functions This bit will be set on overflow and will retain its value until cleared by writing 1 into CLR.CLR_OVF."]
        #[inline(always)]
        pub const fn ovf(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Overflow bit for MPY32, SQUARE32, DIV, MAC, and SAC functions This bit will be set on overflow and will retain its value until cleared by writing 1 into CLR.CLR_OVF."]
        #[inline(always)]
        pub fn set_ovf(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Incorrect inputs/outputs."]
        #[inline(always)]
        pub const fn err(&self) -> super::vals::Err {
            let val = (self.0 >> 2usize) & 0x03;
            super::vals::Err::from_bits(val as u8)
        }
        #[doc = "Incorrect inputs/outputs."]
        #[inline(always)]
        pub fn set_err(&mut self, val: super::vals::Err) {
            self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
        }
        #[doc = "MATHACL busy bit."]
        #[inline(always)]
        pub const fn busy(&self) -> super::vals::Busy {
            let val = (self.0 >> 8usize) & 0x01;
            super::vals::Busy::from_bits(val as u8)
        }
        #[doc = "MATHACL busy bit."]
        #[inline(always)]
        pub fn set_busy(&mut self, val: super::vals::Busy) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
        }
    }
    impl Default for Status {
        #[inline(always)]
        fn default() -> Status {
            Status(0)
        }
    }
    #[doc = "Status flag clear register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Statusclr(pub u32);
    impl Statusclr {
        #[doc = "Write 1 to this bit to clear STATUS.UF bit."]
        #[inline(always)]
        pub const fn clr_uf(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Write 1 to this bit to clear STATUS.UF bit."]
        #[inline(always)]
        pub fn set_clr_uf(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Write 1 to this bit to clear STATUS.OVF bit."]
        #[inline(always)]
        pub const fn clr_ovf(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Write 1 to this bit to clear STATUS.OVF bit."]
        #[inline(always)]
        pub fn set_clr_ovf(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Write 1 to this bit to clear STATUS.ERR field."]
        #[inline(always)]
        pub const fn clr_err(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Write 1 to this bit to clear STATUS.ERR field."]
        #[inline(always)]
        pub fn set_clr_err(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
    }
    impl Default for Statusclr {
        #[inline(always)]
        fn default() -> Statusclr {
            Statusclr(0)
        }
    }
}
pub mod vals {
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Busy {
        #[doc = "Compute has completed."]
        DONE = 0x0,
        #[doc = "Compute ongoing."]
        NOTDONE = 0x01,
    }
    impl Busy {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Busy {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Busy {
        #[inline(always)]
        fn from(val: u8) -> Busy {
            Busy::from_bits(val)
        }
    }
    impl From<Busy> for u8 {
        #[inline(always)]
        fn from(val: Busy) -> u8 {
            Busy::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Err {
        #[doc = "No Error in computation."]
        NOERROR = 0x0,
        #[doc = "DIVBY0 error."]
        DIVBY0 = 0x01,
        _RESERVED_2 = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl Err {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Err {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Err {
        #[inline(always)]
        fn from(val: u8) -> Err {
            Err::from_bits(val)
        }
    }
    impl From<Err> for u8 {
        #[inline(always)]
        fn from(val: Err) -> u8 {
            Err::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Func {
        #[doc = "No operation."]
        NOP = 0x0,
        #[doc = "Sine and Cosine operation."]
        SINCOS = 0x01,
        #[doc = "Arc tangent with x and y values as operands."]
        ATAN2 = 0x02,
        _RESERVED_3 = 0x03,
        #[doc = "Divide, the operands are numerator, denominator, and the divide type. Result is the quotient and reminder."]
        DIV = 0x04,
        #[doc = "Do square root. Operand is the number whoose square root needs to be computed. The number if outside the range needs to be scaled up down by 2 power 2n to bring it with in the range."]
        SQRT = 0x05,
        #[doc = "32-bit Multiply Result."]
        MPY32 = 0x06,
        #[doc = "32-bit square result."]
        SQUARE32 = 0x07,
        #[doc = "64-bit multiply result."]
        MPY64 = 0x08,
        #[doc = "64-bit multiply result."]
        SQUARE64 = 0x09,
        #[doc = "Multiply and accumulate operation."]
        MAC = 0x0a,
        #[doc = "Square and accumulate operation."]
        SAC = 0x0b,
        _RESERVED_c = 0x0c,
        _RESERVED_d = 0x0d,
        _RESERVED_e = 0x0e,
        _RESERVED_f = 0x0f,
        _RESERVED_10 = 0x10,
        _RESERVED_11 = 0x11,
        _RESERVED_12 = 0x12,
        _RESERVED_13 = 0x13,
        _RESERVED_14 = 0x14,
        _RESERVED_15 = 0x15,
        _RESERVED_16 = 0x16,
        _RESERVED_17 = 0x17,
        _RESERVED_18 = 0x18,
        _RESERVED_19 = 0x19,
        _RESERVED_1a = 0x1a,
        _RESERVED_1b = 0x1b,
        _RESERVED_1c = 0x1c,
        _RESERVED_1d = 0x1d,
        _RESERVED_1e = 0x1e,
        _RESERVED_1f = 0x1f,
    }
    impl Func {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Func {
            unsafe { core::mem::transmute(val & 0x1f) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Func {
        #[inline(always)]
        fn from(val: u8) -> Func {
            Func::from_bits(val)
        }
    }
    impl From<Func> for u8 {
        #[inline(always)]
        fn from(val: Func) -> u8 {
            Func::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct PwrenKey(pub u8);
    impl PwrenKey {
        pub const KEY: Self = Self(0x26);
    }
    impl PwrenKey {
        pub const fn from_bits(val: u8) -> PwrenKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for PwrenKey {
        #[inline(always)]
        fn from(val: u8) -> PwrenKey {
            PwrenKey::from_bits(val)
        }
    }
    impl From<PwrenKey> for u8 {
        #[inline(always)]
        fn from(val: PwrenKey) -> u8 {
            PwrenKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Qval {
        #[doc = "Q0 operands."]
        Q0 = 0x0,
        #[doc = "Q1 operands."]
        Q1 = 0x01,
        #[doc = "Q2 operands."]
        Q2 = 0x02,
        #[doc = "Q3 operands."]
        Q3 = 0x03,
        #[doc = "Q4 operands."]
        Q4 = 0x04,
        #[doc = "Q5 operands."]
        Q5 = 0x05,
        #[doc = "Q6 operands."]
        Q6 = 0x06,
        #[doc = "Q7 operands."]
        Q7 = 0x07,
        #[doc = "Q8 operands."]
        Q8 = 0x08,
        #[doc = "Q9 operands."]
        Q9 = 0x09,
        #[doc = "Q10 operands."]
        Q10 = 0x0a,
        #[doc = "Q11 operands."]
        Q11 = 0x0b,
        #[doc = "Q12 operands."]
        Q12 = 0x0c,
        #[doc = "Q13 operands."]
        Q13 = 0x0d,
        #[doc = "Q14 operands."]
        Q14 = 0x0e,
        #[doc = "Q15 operands."]
        Q15 = 0x0f,
        #[doc = "Q16 operands."]
        Q16 = 0x10,
        #[doc = "Q17 operands."]
        Q17 = 0x11,
        #[doc = "Q18 operands."]
        Q18 = 0x12,
        #[doc = "Q19 operands."]
        Q19 = 0x13,
        #[doc = "Q20 operands."]
        Q20 = 0x14,
        #[doc = "Q21 operands."]
        Q21 = 0x15,
        #[doc = "Q22 operands."]
        Q22 = 0x16,
        #[doc = "Q23 operands."]
        Q23 = 0x17,
        #[doc = "Q24 operands."]
        Q24 = 0x18,
        #[doc = "Q25 operands."]
        Q25 = 0x19,
        #[doc = "Q26 operands."]
        Q26 = 0x1a,
        #[doc = "Q27 operands."]
        Q27 = 0x1b,
        #[doc = "Q28 operands."]
        Q28 = 0x1c,
        #[doc = "Q29 operands."]
        Q29 = 0x1d,
        #[doc = "Q30 operands."]
        Q30 = 0x1e,
        #[doc = "Q31 operands."]
        Q31 = 0x1f,
    }
    impl Qval {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Qval {
            unsafe { core::mem::transmute(val & 0x1f) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Qval {
        #[inline(always)]
        fn from(val: u8) -> Qval {
            Qval::from_bits(val)
        }
    }
    impl From<Qval> for u8 {
        #[inline(always)]
        fn from(val: Qval) -> u8 {
            Qval::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct ResetKey(pub u8);
    impl ResetKey {
        pub const KEY: Self = Self(0xb1);
    }
    impl ResetKey {
        pub const fn from_bits(val: u8) -> ResetKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for ResetKey {
        #[inline(always)]
        fn from(val: u8) -> ResetKey {
            ResetKey::from_bits(val)
        }
    }
    impl From<ResetKey> for u8 {
        #[inline(always)]
        fn from(val: ResetKey) -> u8 {
            ResetKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Resetassert {
        #[doc = "Writing 0 has no effect."]
        NOP = 0x0,
        #[doc = "Assert reset."]
        ASSERT = 0x01,
    }
    impl Resetassert {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Resetassert {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Resetassert {
        #[inline(always)]
        fn from(val: u8) -> Resetassert {
            Resetassert::from_bits(val)
        }
    }
    impl From<Resetassert> for u8 {
        #[inline(always)]
        fn from(val: Resetassert) -> u8 {
            Resetassert::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Resetstky {
        #[doc = "The peripheral has not been reset since this bit was last cleared by RESETSTKYCLR in the RSTCTL register."]
        NORES = 0x0,
        #[doc = "The peripheral was reset since the last bit clear."]
        RESET = 0x01,
    }
    impl Resetstky {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Resetstky {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Resetstky {
        #[inline(always)]
        fn from(val: u8) -> Resetstky {
            Resetstky::from_bits(val)
        }
    }
    impl From<Resetstky> for u8 {
        #[inline(always)]
        fn from(val: Resetstky) -> u8 {
            Resetstky::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Resetstkyclr {
        #[doc = "Writing 0 has no effect."]
        NOP = 0x0,
        #[doc = "Clear reset sticky bit."]
        CLR = 0x01,
    }
    impl Resetstkyclr {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Resetstkyclr {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Resetstkyclr {
        #[inline(always)]
        fn from(val: u8) -> Resetstkyclr {
            Resetstkyclr::from_bits(val)
        }
    }
    impl From<Resetstkyclr> for u8 {
        #[inline(always)]
        fn from(val: Resetstkyclr) -> u8 {
            Resetstkyclr::to_bits(val)
        }
    }
}
