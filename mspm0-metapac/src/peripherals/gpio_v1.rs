// This file is autogenerated by mspm0-metapac-gen: do not edit by hand.
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::identity_op)]
#![allow(clippy::unnecessary_cast)]
#![allow(clippy::erasing_op)]

#[derive(Copy, Clone, Eq, PartialEq)]
pub struct CpuInt {
    ptr: *mut u8,
}
unsafe impl Send for CpuInt {}
unsafe impl Sync for CpuInt {}
impl CpuInt {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Interrupt index."]
    #[inline(always)]
    pub const fn iidx(self) -> crate::common::Reg<regs::CpuIntIidx, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "Interrupt mask."]
    #[inline(always)]
    pub const fn imask(self) -> crate::common::Reg<regs::CpuInt, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
    }
    #[doc = "Raw interrupt status."]
    #[inline(always)]
    pub const fn ris(self) -> crate::common::Reg<regs::CpuInt, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
    }
    #[doc = "Masked interrupt status."]
    #[inline(always)]
    pub const fn mis(self) -> crate::common::Reg<regs::CpuInt, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
    }
    #[doc = "Interrupt set."]
    #[inline(always)]
    pub const fn iset(self) -> crate::common::Reg<regs::CpuInt, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
    }
    #[doc = "Interrupt clear."]
    #[inline(always)]
    pub const fn iclr(self) -> crate::common::Reg<regs::CpuInt, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
    }
}
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GenEvent {
    ptr: *mut u8,
}
unsafe impl Send for GenEvent {}
unsafe impl Sync for GenEvent {}
impl GenEvent {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Interrupt index."]
    #[inline(always)]
    pub const fn iidx(self) -> crate::common::Reg<regs::GenEventIidx, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "Interrupt mask."]
    #[inline(always)]
    pub const fn imask(self) -> crate::common::Reg<regs::GenEvent, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
    }
    #[doc = "Raw interrupt status."]
    #[inline(always)]
    pub const fn ris(self) -> crate::common::Reg<regs::GenEvent, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
    }
    #[doc = "Masked interrupt status."]
    #[inline(always)]
    pub const fn mis(self) -> crate::common::Reg<regs::GenEvent, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
    }
    #[doc = "Interrupt set."]
    #[inline(always)]
    pub const fn iset(self) -> crate::common::Reg<regs::GenEvent, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
    }
    #[doc = "Interrupt clear."]
    #[inline(always)]
    pub const fn iclr(self) -> crate::common::Reg<regs::GenEvent, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
    }
}
#[doc = "PERIPHERALREGION."]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Gpio {
    ptr: *mut u8,
}
unsafe impl Send for Gpio {}
unsafe impl Sync for Gpio {}
impl Gpio {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Subsciber Port 0."]
    #[inline(always)]
    pub const fn fsub(self, n: usize) -> crate::common::Reg<regs::Fport, crate::common::RW> {
        assert!(n < 2usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize + n * 4usize) as _) }
    }
    #[doc = "Publisher Port 0."]
    #[inline(always)]
    pub const fn fpub(self, n: usize) -> crate::common::Reg<regs::Fport, crate::common::RW> {
        assert!(n < 2usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0444usize + n * 4usize) as _) }
    }
    #[inline(always)]
    pub const fn gprcm(self) -> Gprcm {
        unsafe { Gprcm::from_ptr(self.ptr.add(0x0800usize) as _) }
    }
    #[doc = "Clock Override."]
    #[inline(always)]
    pub const fn clkovr(self) -> crate::common::Reg<regs::Clkovr, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1010usize) as _) }
    }
    #[doc = "Peripheral Debug Control."]
    #[inline(always)]
    pub const fn pdbgctl(self) -> crate::common::Reg<regs::Pdbgctl, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1018usize) as _) }
    }
    #[inline(always)]
    pub const fn cpu_int(self) -> CpuInt {
        unsafe { CpuInt::from_ptr(self.ptr.add(0x1020usize) as _) }
    }
    #[inline(always)]
    pub const fn gen_event(self, n: usize) -> GenEvent {
        assert!(n < 2usize);
        unsafe { GenEvent::from_ptr(self.ptr.add(0x1050usize + n * 48usize) as _) }
    }
    #[doc = "Event Mode."]
    #[inline(always)]
    pub const fn evt_mode(self) -> crate::common::Reg<regs::EvtMode, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10e0usize) as _) }
    }
    #[doc = "Module Description."]
    #[inline(always)]
    pub const fn desc(self) -> crate::common::Reg<regs::Desc, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10fcusize) as _) }
    }
    #[doc = "Data output 3 to 0."]
    #[inline(always)]
    pub const fn dout_y_x4(self, n: usize) -> crate::common::Reg<regs::DoutX4, crate::common::W> {
        assert!(n < 8usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1200usize + n * 4usize) as _) }
    }
    #[doc = "Data output 31 to 0."]
    #[inline(always)]
    pub const fn dout31_0(self) -> crate::common::Reg<regs::Dout310, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1280usize) as _) }
    }
    #[doc = "Data output set 31 to 0."]
    #[inline(always)]
    pub const fn doutset31_0(self) -> crate::common::Reg<regs::Doutset310, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1290usize) as _) }
    }
    #[doc = "Data output clear 31 to 0."]
    #[inline(always)]
    pub const fn doutclr31_0(self) -> crate::common::Reg<regs::Doutclr310, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12a0usize) as _) }
    }
    #[doc = "Data output toggle 31 to 0."]
    #[inline(always)]
    pub const fn douttgl31_0(self) -> crate::common::Reg<regs::Douttgl310, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12b0usize) as _) }
    }
    #[doc = "Data output enable 31 to 0."]
    #[inline(always)]
    pub const fn doe31_0(self) -> crate::common::Reg<regs::Doe310, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12c0usize) as _) }
    }
    #[doc = "Data output enable set 31 to 0."]
    #[inline(always)]
    pub const fn doeset31_0(self) -> crate::common::Reg<regs::Doeset310, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12d0usize) as _) }
    }
    #[doc = "Data output enable clear 31 to 0."]
    #[inline(always)]
    pub const fn doeclr31_0(self) -> crate::common::Reg<regs::Doeclr310, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x12e0usize) as _) }
    }
    #[doc = "Data input 3 to 0."]
    #[inline(always)]
    pub const fn din_y_x4(self, n: usize) -> crate::common::Reg<regs::DinX4, crate::common::R> {
        assert!(n < 8usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1300usize + n * 4usize) as _) }
    }
    #[doc = "Data input 31 to 0."]
    #[inline(always)]
    pub const fn din31_0(self) -> crate::common::Reg<regs::Din310, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1380usize) as _) }
    }
    #[doc = "Polarity 15 to 0."]
    #[inline(always)]
    pub const fn polarity15_0(self) -> crate::common::Reg<regs::Polarity150, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1390usize) as _) }
    }
    #[doc = "Polarity 31 to 16."]
    #[inline(always)]
    pub const fn polarity31_16(self) -> crate::common::Reg<regs::Polarity3116, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x13a0usize) as _) }
    }
    #[doc = "FAST WAKE GLOBAL EN."]
    #[inline(always)]
    pub const fn ctl(self) -> crate::common::Reg<regs::Ctl, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1400usize) as _) }
    }
    #[doc = "FAST WAKE ENABLE."]
    #[inline(always)]
    pub const fn fastwake(self) -> crate::common::Reg<regs::Fastwake, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1404usize) as _) }
    }
    #[doc = "Subscriber 0 configuration."]
    #[inline(always)]
    pub const fn subcfg(self, n: usize) -> crate::common::Reg<regs::Subcfg, crate::common::RW> {
        assert!(n < 2usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1500usize + n * 32usize) as _) }
    }
    #[doc = "Filter Enable 15 to 0."]
    #[inline(always)]
    pub const fn filteren15_0(self) -> crate::common::Reg<regs::Filteren, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1508usize) as _) }
    }
    #[doc = "Filter Enable 31 to 16."]
    #[inline(always)]
    pub const fn filteren31_16(self) -> crate::common::Reg<regs::Filteren, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x150cusize) as _) }
    }
    #[doc = "DMA Write MASK."]
    #[inline(always)]
    pub const fn dmamask(self) -> crate::common::Reg<regs::Dmamask, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1510usize) as _) }
    }
}
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Gprcm {
    ptr: *mut u8,
}
unsafe impl Send for Gprcm {}
unsafe impl Sync for Gprcm {}
impl Gprcm {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Power enable."]
    #[inline(always)]
    pub const fn pwren(self) -> crate::common::Reg<regs::Pwren, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "Reset Control."]
    #[inline(always)]
    pub const fn rstctl(self) -> crate::common::Reg<regs::Rstctl, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
    }
    #[doc = "Status Register."]
    #[inline(always)]
    pub const fn stat(self) -> crate::common::Reg<regs::Stat, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
    }
}
pub mod regs {
    #[doc = "Clock Override."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Clkovr(pub u32);
    impl Clkovr {
        #[doc = "Unlocks the functionality of \\[RUN_STOP\\]
to override the automatic peripheral clock request."]
        #[inline(always)]
        pub const fn override_(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Unlocks the functionality of \\[RUN_STOP\\]
to override the automatic peripheral clock request."]
        #[inline(always)]
        pub fn set_override_(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "If \\[OVERRIDE\\]
is enabled, this register is used to manually control the peripheral's clock request to the system."]
        #[inline(always)]
        pub const fn run_stop(&self) -> super::vals::RunStop {
            let val = (self.0 >> 1usize) & 0x01;
            super::vals::RunStop::from_bits(val as u8)
        }
        #[doc = "If \\[OVERRIDE\\]
is enabled, this register is used to manually control the peripheral's clock request to the system."]
        #[inline(always)]
        pub fn set_run_stop(&mut self, val: super::vals::RunStop) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
        }
    }
    impl Default for Clkovr {
        #[inline(always)]
        fn default() -> Clkovr {
            Clkovr(0)
        }
    }
    #[doc = "Interrupt clear."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct CpuInt(pub u32);
    impl CpuInt {
        #[doc = "DIO0 event."]
        #[inline(always)]
        pub const fn dio(&self, n: usize) -> bool {
            assert!(n < 32usize);
            let offs = 0usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "DIO0 event."]
        #[inline(always)]
        pub fn set_dio(&mut self, n: usize, val: bool) {
            assert!(n < 32usize);
            let offs = 0usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for CpuInt {
        #[inline(always)]
        fn default() -> CpuInt {
            CpuInt(0)
        }
    }
    #[doc = "Interrupt index."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct CpuIntIidx(pub u32);
    impl CpuIntIidx {
        #[doc = "Interrupt index status."]
        #[inline(always)]
        pub const fn stat(&self) -> super::vals::CpuIntIidxStat {
            let val = (self.0 >> 0usize) & 0xff;
            super::vals::CpuIntIidxStat::from_bits(val as u8)
        }
        #[doc = "Interrupt index status."]
        #[inline(always)]
        pub fn set_stat(&mut self, val: super::vals::CpuIntIidxStat) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
        }
    }
    impl Default for CpuIntIidx {
        #[inline(always)]
        fn default() -> CpuIntIidx {
            CpuIntIidx(0)
        }
    }
    #[doc = "FAST WAKE GLOBAL EN."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ctl(pub u32);
    impl Ctl {
        #[doc = "FASTWAKEONLY for the global control of fastwake."]
        #[inline(always)]
        pub const fn fastwakeonly(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "FASTWAKEONLY for the global control of fastwake."]
        #[inline(always)]
        pub fn set_fastwakeonly(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Ctl {
        #[inline(always)]
        fn default() -> Ctl {
            Ctl(0)
        }
    }
    #[doc = "Module Description."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Desc(pub u32);
    impl Desc {
        #[doc = "Minor rev of the IP."]
        #[inline(always)]
        pub const fn minrev(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x0f;
            val as u8
        }
        #[doc = "Minor rev of the IP."]
        #[inline(always)]
        pub fn set_minrev(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
        }
        #[doc = "Major rev of the IP."]
        #[inline(always)]
        pub const fn majrev(&self) -> u8 {
            let val = (self.0 >> 4usize) & 0x0f;
            val as u8
        }
        #[doc = "Major rev of the IP."]
        #[inline(always)]
        pub fn set_majrev(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
        }
        #[doc = "Feature Set for the module *instance*."]
        #[inline(always)]
        pub const fn featurever(&self) -> u8 {
            let val = (self.0 >> 12usize) & 0x0f;
            val as u8
        }
        #[doc = "Feature Set for the module *instance*."]
        #[inline(always)]
        pub fn set_featurever(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
        }
        #[doc = "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness."]
        #[inline(always)]
        pub const fn moduleid(&self) -> u16 {
            let val = (self.0 >> 16usize) & 0xffff;
            val as u16
        }
        #[doc = "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness."]
        #[inline(always)]
        pub fn set_moduleid(&mut self, val: u16) {
            self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
        }
    }
    impl Default for Desc {
        #[inline(always)]
        fn default() -> Desc {
            Desc(0)
        }
    }
    #[doc = "Data input 31 to 0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Din310(pub u32);
    impl Din310 {
        #[doc = "This bit reads the data input value of DIO0."]
        #[inline(always)]
        pub const fn dio(&self, n: usize) -> bool {
            assert!(n < 32usize);
            let offs = 0usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "This bit reads the data input value of DIO0."]
        #[inline(always)]
        pub fn set_dio(&mut self, n: usize, val: bool) {
            assert!(n < 32usize);
            let offs = 0usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for Din310 {
        #[inline(always)]
        fn default() -> Din310 {
            Din310(0)
        }
    }
    #[doc = "Data input 11 to 8."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DinX4(pub u32);
    impl DinX4 {
        #[doc = "This bit reads the data input value of DIO8."]
        #[inline(always)]
        pub const fn dio(&self, n: usize) -> bool {
            assert!(n < 4usize);
            let offs = 0usize + n * 8usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "This bit reads the data input value of DIO8."]
        #[inline(always)]
        pub fn set_dio(&mut self, n: usize, val: bool) {
            assert!(n < 4usize);
            let offs = 0usize + n * 8usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for DinX4 {
        #[inline(always)]
        fn default() -> DinX4 {
            DinX4(0)
        }
    }
    #[doc = "DMA Write MASK."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dmamask(pub u32);
    impl Dmamask {
        #[doc = "DMA is allowed to modify DOUT0."]
        #[inline(always)]
        pub const fn dout(&self, n: usize) -> bool {
            assert!(n < 32usize);
            let offs = 0usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "DMA is allowed to modify DOUT0."]
        #[inline(always)]
        pub fn set_dout(&mut self, n: usize, val: bool) {
            assert!(n < 32usize);
            let offs = 0usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for Dmamask {
        #[inline(always)]
        fn default() -> Dmamask {
            Dmamask(0)
        }
    }
    #[doc = "Data output enable 31 to 0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Doe310(pub u32);
    impl Doe310 {
        #[doc = "Enables data output for DIO0."]
        #[inline(always)]
        pub const fn dio(&self, n: usize) -> bool {
            assert!(n < 32usize);
            let offs = 0usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "Enables data output for DIO0."]
        #[inline(always)]
        pub fn set_dio(&mut self, n: usize, val: bool) {
            assert!(n < 32usize);
            let offs = 0usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for Doe310 {
        #[inline(always)]
        fn default() -> Doe310 {
            Doe310(0)
        }
    }
    #[doc = "Data output enable clear 31 to 0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Doeclr310(pub u32);
    impl Doeclr310 {
        #[doc = "Writing 1 to this bit clears the DIO0 bit in the DOE31_0 register. Writing 0 has no effect."]
        #[inline(always)]
        pub const fn dio(&self, n: usize) -> bool {
            assert!(n < 32usize);
            let offs = 0usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "Writing 1 to this bit clears the DIO0 bit in the DOE31_0 register. Writing 0 has no effect."]
        #[inline(always)]
        pub fn set_dio(&mut self, n: usize, val: bool) {
            assert!(n < 32usize);
            let offs = 0usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for Doeclr310 {
        #[inline(always)]
        fn default() -> Doeclr310 {
            Doeclr310(0)
        }
    }
    #[doc = "Data output enable set 31 to 0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Doeset310(pub u32);
    impl Doeset310 {
        #[doc = "Writing 1 to this bit sets the DIO0 bit in the DOE31_0 register. Writing 0 has no effect."]
        #[inline(always)]
        pub const fn dio(&self, n: usize) -> bool {
            assert!(n < 32usize);
            let offs = 0usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "Writing 1 to this bit sets the DIO0 bit in the DOE31_0 register. Writing 0 has no effect."]
        #[inline(always)]
        pub fn set_dio(&mut self, n: usize, val: bool) {
            assert!(n < 32usize);
            let offs = 0usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for Doeset310 {
        #[inline(always)]
        fn default() -> Doeset310 {
            Doeset310(0)
        }
    }
    #[doc = "Data output 31 to 0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dout310(pub u32);
    impl Dout310 {
        #[doc = "This bit sets the value of the pin configured as DIO0 when the output is enabled through DOE31_0 register."]
        #[inline(always)]
        pub const fn dio(&self, n: usize) -> bool {
            assert!(n < 32usize);
            let offs = 0usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "This bit sets the value of the pin configured as DIO0 when the output is enabled through DOE31_0 register."]
        #[inline(always)]
        pub fn set_dio(&mut self, n: usize, val: bool) {
            assert!(n < 32usize);
            let offs = 0usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for Dout310 {
        #[inline(always)]
        fn default() -> Dout310 {
            Dout310(0)
        }
    }
    #[doc = "Data output 11 to 8."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DoutX4(pub u32);
    impl DoutX4 {
        #[doc = "This bit sets the value of the pin configured as DIO8 when the output is enabled through DOE31_0 register."]
        #[inline(always)]
        pub const fn dio(&self, n: usize) -> bool {
            assert!(n < 4usize);
            let offs = 0usize + n * 8usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "This bit sets the value of the pin configured as DIO8 when the output is enabled through DOE31_0 register."]
        #[inline(always)]
        pub fn set_dio(&mut self, n: usize, val: bool) {
            assert!(n < 4usize);
            let offs = 0usize + n * 8usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for DoutX4 {
        #[inline(always)]
        fn default() -> DoutX4 {
            DoutX4(0)
        }
    }
    #[doc = "Data output clear 31 to 0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Doutclr310(pub u32);
    impl Doutclr310 {
        #[doc = "Writing 1 to this bit clears the DIO0 bit in the DOUT31_0 register. Writing 0 has no effect."]
        #[inline(always)]
        pub const fn dio(&self, n: usize) -> bool {
            assert!(n < 32usize);
            let offs = 0usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "Writing 1 to this bit clears the DIO0 bit in the DOUT31_0 register. Writing 0 has no effect."]
        #[inline(always)]
        pub fn set_dio(&mut self, n: usize, val: bool) {
            assert!(n < 32usize);
            let offs = 0usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for Doutclr310 {
        #[inline(always)]
        fn default() -> Doutclr310 {
            Doutclr310(0)
        }
    }
    #[doc = "Data output set 31 to 0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Doutset310(pub u32);
    impl Doutset310 {
        #[doc = "Writing 1 to this bit sets the DIO0 bit in the DOUT31_0 register. Writing 0 has no effect."]
        #[inline(always)]
        pub const fn dio(&self, n: usize) -> bool {
            assert!(n < 32usize);
            let offs = 0usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "Writing 1 to this bit sets the DIO0 bit in the DOUT31_0 register. Writing 0 has no effect."]
        #[inline(always)]
        pub fn set_dio(&mut self, n: usize, val: bool) {
            assert!(n < 32usize);
            let offs = 0usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for Doutset310 {
        #[inline(always)]
        fn default() -> Doutset310 {
            Doutset310(0)
        }
    }
    #[doc = "Data output toggle 31 to 0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Douttgl310(pub u32);
    impl Douttgl310 {
        #[doc = "This bit is used to toggle DIO0 output."]
        #[inline(always)]
        pub const fn dio(&self, n: usize) -> bool {
            assert!(n < 32usize);
            let offs = 0usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "This bit is used to toggle DIO0 output."]
        #[inline(always)]
        pub fn set_dio(&mut self, n: usize, val: bool) {
            assert!(n < 32usize);
            let offs = 0usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for Douttgl310 {
        #[inline(always)]
        fn default() -> Douttgl310 {
            Douttgl310(0)
        }
    }
    #[doc = "Event Mode."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EvtMode(pub u32);
    impl EvtMode {
        #[doc = "Event line mode select for event corresponding to \\[IPSTANDARD.CPU_INT\\]."]
        #[inline(always)]
        pub const fn cpu_cfg(&self) -> super::vals::EvtCfg {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::EvtCfg::from_bits(val as u8)
        }
        #[doc = "Event line mode select for event corresponding to \\[IPSTANDARD.CPU_INT\\]."]
        #[inline(always)]
        pub fn set_cpu_cfg(&mut self, val: super::vals::EvtCfg) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
        #[doc = "Event line mode select for event corresponding to \\[IPSTANDARD.GEN_EVENT0\\]."]
        #[inline(always)]
        pub const fn gen_evt_cfg(&self, n: usize) -> super::vals::EvtCfg {
            assert!(n < 2usize);
            let offs = 2usize + n * 2usize;
            let val = (self.0 >> offs) & 0x03;
            super::vals::EvtCfg::from_bits(val as u8)
        }
        #[doc = "Event line mode select for event corresponding to \\[IPSTANDARD.GEN_EVENT0\\]."]
        #[inline(always)]
        pub fn set_gen_evt_cfg(&mut self, n: usize, val: super::vals::EvtCfg) {
            assert!(n < 2usize);
            let offs = 2usize + n * 2usize;
            self.0 = (self.0 & !(0x03 << offs)) | (((val.to_bits() as u32) & 0x03) << offs);
        }
    }
    impl Default for EvtMode {
        #[inline(always)]
        fn default() -> EvtMode {
            EvtMode(0)
        }
    }
    #[doc = "FAST WAKE ENABLE."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Fastwake(pub u32);
    impl Fastwake {
        #[doc = "Enable fastwake feature for DIN0."]
        #[inline(always)]
        pub const fn din(&self, n: usize) -> bool {
            assert!(n < 32usize);
            let offs = 0usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "Enable fastwake feature for DIN0."]
        #[inline(always)]
        pub fn set_din(&mut self, n: usize, val: bool) {
            assert!(n < 32usize);
            let offs = 0usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for Fastwake {
        #[inline(always)]
        fn default() -> Fastwake {
            Fastwake(0)
        }
    }
    #[doc = "Filter Enable 15 to 0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Filteren(pub u32);
    impl Filteren {
        #[doc = "Programmable counter length of digital glitch filter for DIN0."]
        #[inline(always)]
        pub const fn din(&self, n: usize) -> super::vals::Filteren {
            assert!(n < 16usize);
            let offs = 0usize + n * 2usize;
            let val = (self.0 >> offs) & 0x03;
            super::vals::Filteren::from_bits(val as u8)
        }
        #[doc = "Programmable counter length of digital glitch filter for DIN0."]
        #[inline(always)]
        pub fn set_din(&mut self, n: usize, val: super::vals::Filteren) {
            assert!(n < 16usize);
            let offs = 0usize + n * 2usize;
            self.0 = (self.0 & !(0x03 << offs)) | (((val.to_bits() as u32) & 0x03) << offs);
        }
    }
    impl Default for Filteren {
        #[inline(always)]
        fn default() -> Filteren {
            Filteren(0)
        }
    }
    #[doc = "Publisher Port 0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Fport(pub u32);
    impl Fport {
        #[doc = "0 = disconnected. 1-15 = connected to channelID = CHANID."]
        #[inline(always)]
        pub const fn chanid(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x0f;
            val as u8
        }
        #[doc = "0 = disconnected. 1-15 = connected to channelID = CHANID."]
        #[inline(always)]
        pub fn set_chanid(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
        }
    }
    impl Default for Fport {
        #[inline(always)]
        fn default() -> Fport {
            Fport(0)
        }
    }
    #[doc = "Interrupt clear."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct GenEvent(pub u32);
    impl GenEvent {
        #[doc = "DIO0 event."]
        #[inline(always)]
        pub const fn dio(&self, n: usize) -> bool {
            assert!(n < 16usize);
            let offs = 0usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "DIO0 event."]
        #[inline(always)]
        pub fn set_dio(&mut self, n: usize, val: bool) {
            assert!(n < 16usize);
            let offs = 0usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for GenEvent {
        #[inline(always)]
        fn default() -> GenEvent {
            GenEvent(0)
        }
    }
    #[doc = "Interrupt index."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct GenEventIidx(pub u32);
    impl GenEventIidx {
        #[doc = "Interrupt index status."]
        #[inline(always)]
        pub const fn stat(&self) -> super::vals::GenEventIidxStat {
            let val = (self.0 >> 0usize) & 0xff;
            super::vals::GenEventIidxStat::from_bits(val as u8)
        }
        #[doc = "Interrupt index status."]
        #[inline(always)]
        pub fn set_stat(&mut self, val: super::vals::GenEventIidxStat) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
        }
    }
    impl Default for GenEventIidx {
        #[inline(always)]
        fn default() -> GenEventIidx {
            GenEventIidx(0)
        }
    }
    #[doc = "Peripheral Debug Control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pdbgctl(pub u32);
    impl Pdbgctl {
        #[doc = "Free run control."]
        #[inline(always)]
        pub const fn free(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Free run control."]
        #[inline(always)]
        pub fn set_free(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Pdbgctl {
        #[inline(always)]
        fn default() -> Pdbgctl {
            Pdbgctl(0)
        }
    }
    #[doc = "Polarity 15 to 0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Polarity150(pub u32);
    impl Polarity150 {
        #[doc = "Enables and configures edge detection polarity for DIO0."]
        #[inline(always)]
        pub const fn dio(&self, n: usize) -> super::vals::Polarity {
            assert!(n < 16usize);
            let offs = 0usize + n * 2usize;
            let val = (self.0 >> offs) & 0x03;
            super::vals::Polarity::from_bits(val as u8)
        }
        #[doc = "Enables and configures edge detection polarity for DIO0."]
        #[inline(always)]
        pub fn set_dio(&mut self, n: usize, val: super::vals::Polarity) {
            assert!(n < 16usize);
            let offs = 0usize + n * 2usize;
            self.0 = (self.0 & !(0x03 << offs)) | (((val.to_bits() as u32) & 0x03) << offs);
        }
    }
    impl Default for Polarity150 {
        #[inline(always)]
        fn default() -> Polarity150 {
            Polarity150(0)
        }
    }
    #[doc = "Polarity 31 to 16."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Polarity3116(pub u32);
    impl Polarity3116 {
        #[doc = "Enables and configures edge detection polarity for DIO16."]
        #[inline(always)]
        pub const fn dio(&self, n: usize) -> super::vals::Polarity {
            assert!(n < 16usize);
            let offs = 0usize + n * 2usize;
            let val = (self.0 >> offs) & 0x03;
            super::vals::Polarity::from_bits(val as u8)
        }
        #[doc = "Enables and configures edge detection polarity for DIO16."]
        #[inline(always)]
        pub fn set_dio(&mut self, n: usize, val: super::vals::Polarity) {
            assert!(n < 16usize);
            let offs = 0usize + n * 2usize;
            self.0 = (self.0 & !(0x03 << offs)) | (((val.to_bits() as u32) & 0x03) << offs);
        }
    }
    impl Default for Polarity3116 {
        #[inline(always)]
        fn default() -> Polarity3116 {
            Polarity3116(0)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pwren(pub u32);
    impl Pwren {
        #[inline(always)]
        pub const fn enable(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[inline(always)]
        pub fn set_enable(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "KEY to allow Power State Change 26h = KEY to allow write access to this register"]
        #[inline(always)]
        pub const fn key(&self) -> super::vals::PwrenKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::PwrenKey::from_bits(val as u8)
        }
        #[doc = "KEY to allow Power State Change 26h = KEY to allow write access to this register"]
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::PwrenKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Pwren {
        #[inline(always)]
        fn default() -> Pwren {
            Pwren(0)
        }
    }
    #[doc = "Reset Control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rstctl(pub u32);
    impl Rstctl {
        #[doc = "Assert reset to the peripheral."]
        #[inline(always)]
        pub const fn resetassert(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Assert reset to the peripheral."]
        #[inline(always)]
        pub fn set_resetassert(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Clear the RESETSTKY bit in the STAT register."]
        #[inline(always)]
        pub const fn resetstkyclr(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Clear the RESETSTKY bit in the STAT register."]
        #[inline(always)]
        pub fn set_resetstkyclr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Unlock key B1h = KEY to allow write access to this register"]
        #[inline(always)]
        pub const fn key(&self) -> super::vals::ResetKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::ResetKey::from_bits(val as u8)
        }
        #[doc = "Unlock key B1h = KEY to allow write access to this register"]
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::ResetKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Rstctl {
        #[inline(always)]
        fn default() -> Rstctl {
            Rstctl(0)
        }
    }
    #[doc = "Status Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Stat(pub u32);
    impl Stat {
        #[doc = "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register."]
        #[inline(always)]
        pub const fn resetstky(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register."]
        #[inline(always)]
        pub fn set_resetstky(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
    }
    impl Default for Stat {
        #[inline(always)]
        fn default() -> Stat {
            Stat(0)
        }
    }
    #[doc = "Subscriber 0 configuration."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Subcfg(pub u32);
    impl Subcfg {
        #[doc = "This bit is used to enable subscriber 0 event."]
        #[inline(always)]
        pub const fn enable(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "This bit is used to enable subscriber 0 event."]
        #[inline(always)]
        pub fn set_enable(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "These bits configure the output policy for subscriber 0 event."]
        #[inline(always)]
        pub const fn outpolicy(&self) -> super::vals::SubcfgOutpolicy {
            let val = (self.0 >> 8usize) & 0x03;
            super::vals::SubcfgOutpolicy::from_bits(val as u8)
        }
        #[doc = "These bits configure the output policy for subscriber 0 event."]
        #[inline(always)]
        pub fn set_outpolicy(&mut self, val: super::vals::SubcfgOutpolicy) {
            self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
        }
        #[doc = "Indicates the specific bit among lower 16 bits that is targeted by the subscriber action."]
        #[inline(always)]
        pub const fn index(&self) -> u8 {
            let val = (self.0 >> 16usize) & 0x0f;
            val as u8
        }
        #[doc = "Indicates the specific bit among lower 16 bits that is targeted by the subscriber action."]
        #[inline(always)]
        pub fn set_index(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
        }
    }
    impl Default for Subcfg {
        #[inline(always)]
        fn default() -> Subcfg {
            Subcfg(0)
        }
    }
}
pub mod vals {
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum CpuIntIidxStat {
        #[doc = "No bit is set means there is no pending interrupt request."]
        NO_INTR = 0x0,
        #[doc = "DIO0 interrupt."]
        DIO0 = 0x01,
        #[doc = "DIO1 interrupt."]
        DIO1 = 0x02,
        #[doc = "DIO2 interrupt."]
        DIO2 = 0x03,
        #[doc = "DIO3 interrupt."]
        DIO3 = 0x04,
        #[doc = "DIO4 interrupt."]
        DIO4 = 0x05,
        #[doc = "DIO5 interrupt."]
        DIO5 = 0x06,
        #[doc = "DIO6 interrupt."]
        DIO6 = 0x07,
        #[doc = "DIO7 interrupt."]
        DIO7 = 0x08,
        #[doc = "DIO8 interrupt."]
        DIO8 = 0x09,
        #[doc = "DIO9 interrupt."]
        DIO9 = 0x0a,
        #[doc = "DIO10 interrupt."]
        DIO10 = 0x0b,
        #[doc = "DIO11 interrupt."]
        DIO11 = 0x0c,
        #[doc = "DIO12 interrupt."]
        DIO12 = 0x0d,
        #[doc = "DIO13 interrupt."]
        DIO13 = 0x0e,
        #[doc = "DIO14 interrupt."]
        DIO14 = 0x0f,
        #[doc = "DIO15 interrupt."]
        DIO15 = 0x10,
        #[doc = "DIO16 interrupt."]
        DIO16 = 0x11,
        #[doc = "DIO17 interrupt."]
        DIO17 = 0x12,
        #[doc = "DIO18 interrupt."]
        DIO18 = 0x13,
        #[doc = "DIO19 interrupt."]
        DIO19 = 0x14,
        #[doc = "DIO20 interrupt."]
        DIO20 = 0x15,
        #[doc = "DIO21 interrupt."]
        DIO21 = 0x16,
        #[doc = "DIO22 interrupt."]
        DIO22 = 0x17,
        #[doc = "DIO23 interrupt."]
        DIO23 = 0x18,
        #[doc = "DIO24 interrupt."]
        DIO24 = 0x19,
        #[doc = "DIO25 interrupt."]
        DIO25 = 0x1a,
        #[doc = "DIO26 interrupt."]
        DIO26 = 0x1b,
        #[doc = "DIO27 interrupt."]
        DIO27 = 0x1c,
        #[doc = "DIO28 interrupt."]
        DIO28 = 0x1d,
        #[doc = "DIO29 interrupt."]
        DIO29 = 0x1e,
        #[doc = "DIO30 interrupt."]
        DIO30 = 0x1f,
        #[doc = "DIO31 interrupt."]
        DIO31 = 0x20,
        _RESERVED_21 = 0x21,
        _RESERVED_22 = 0x22,
        _RESERVED_23 = 0x23,
        _RESERVED_24 = 0x24,
        _RESERVED_25 = 0x25,
        _RESERVED_26 = 0x26,
        _RESERVED_27 = 0x27,
        _RESERVED_28 = 0x28,
        _RESERVED_29 = 0x29,
        _RESERVED_2a = 0x2a,
        _RESERVED_2b = 0x2b,
        _RESERVED_2c = 0x2c,
        _RESERVED_2d = 0x2d,
        _RESERVED_2e = 0x2e,
        _RESERVED_2f = 0x2f,
        _RESERVED_30 = 0x30,
        _RESERVED_31 = 0x31,
        _RESERVED_32 = 0x32,
        _RESERVED_33 = 0x33,
        _RESERVED_34 = 0x34,
        _RESERVED_35 = 0x35,
        _RESERVED_36 = 0x36,
        _RESERVED_37 = 0x37,
        _RESERVED_38 = 0x38,
        _RESERVED_39 = 0x39,
        _RESERVED_3a = 0x3a,
        _RESERVED_3b = 0x3b,
        _RESERVED_3c = 0x3c,
        _RESERVED_3d = 0x3d,
        _RESERVED_3e = 0x3e,
        _RESERVED_3f = 0x3f,
        _RESERVED_40 = 0x40,
        _RESERVED_41 = 0x41,
        _RESERVED_42 = 0x42,
        _RESERVED_43 = 0x43,
        _RESERVED_44 = 0x44,
        _RESERVED_45 = 0x45,
        _RESERVED_46 = 0x46,
        _RESERVED_47 = 0x47,
        _RESERVED_48 = 0x48,
        _RESERVED_49 = 0x49,
        _RESERVED_4a = 0x4a,
        _RESERVED_4b = 0x4b,
        _RESERVED_4c = 0x4c,
        _RESERVED_4d = 0x4d,
        _RESERVED_4e = 0x4e,
        _RESERVED_4f = 0x4f,
        _RESERVED_50 = 0x50,
        _RESERVED_51 = 0x51,
        _RESERVED_52 = 0x52,
        _RESERVED_53 = 0x53,
        _RESERVED_54 = 0x54,
        _RESERVED_55 = 0x55,
        _RESERVED_56 = 0x56,
        _RESERVED_57 = 0x57,
        _RESERVED_58 = 0x58,
        _RESERVED_59 = 0x59,
        _RESERVED_5a = 0x5a,
        _RESERVED_5b = 0x5b,
        _RESERVED_5c = 0x5c,
        _RESERVED_5d = 0x5d,
        _RESERVED_5e = 0x5e,
        _RESERVED_5f = 0x5f,
        _RESERVED_60 = 0x60,
        _RESERVED_61 = 0x61,
        _RESERVED_62 = 0x62,
        _RESERVED_63 = 0x63,
        _RESERVED_64 = 0x64,
        _RESERVED_65 = 0x65,
        _RESERVED_66 = 0x66,
        _RESERVED_67 = 0x67,
        _RESERVED_68 = 0x68,
        _RESERVED_69 = 0x69,
        _RESERVED_6a = 0x6a,
        _RESERVED_6b = 0x6b,
        _RESERVED_6c = 0x6c,
        _RESERVED_6d = 0x6d,
        _RESERVED_6e = 0x6e,
        _RESERVED_6f = 0x6f,
        _RESERVED_70 = 0x70,
        _RESERVED_71 = 0x71,
        _RESERVED_72 = 0x72,
        _RESERVED_73 = 0x73,
        _RESERVED_74 = 0x74,
        _RESERVED_75 = 0x75,
        _RESERVED_76 = 0x76,
        _RESERVED_77 = 0x77,
        _RESERVED_78 = 0x78,
        _RESERVED_79 = 0x79,
        _RESERVED_7a = 0x7a,
        _RESERVED_7b = 0x7b,
        _RESERVED_7c = 0x7c,
        _RESERVED_7d = 0x7d,
        _RESERVED_7e = 0x7e,
        _RESERVED_7f = 0x7f,
        _RESERVED_80 = 0x80,
        _RESERVED_81 = 0x81,
        _RESERVED_82 = 0x82,
        _RESERVED_83 = 0x83,
        _RESERVED_84 = 0x84,
        _RESERVED_85 = 0x85,
        _RESERVED_86 = 0x86,
        _RESERVED_87 = 0x87,
        _RESERVED_88 = 0x88,
        _RESERVED_89 = 0x89,
        _RESERVED_8a = 0x8a,
        _RESERVED_8b = 0x8b,
        _RESERVED_8c = 0x8c,
        _RESERVED_8d = 0x8d,
        _RESERVED_8e = 0x8e,
        _RESERVED_8f = 0x8f,
        _RESERVED_90 = 0x90,
        _RESERVED_91 = 0x91,
        _RESERVED_92 = 0x92,
        _RESERVED_93 = 0x93,
        _RESERVED_94 = 0x94,
        _RESERVED_95 = 0x95,
        _RESERVED_96 = 0x96,
        _RESERVED_97 = 0x97,
        _RESERVED_98 = 0x98,
        _RESERVED_99 = 0x99,
        _RESERVED_9a = 0x9a,
        _RESERVED_9b = 0x9b,
        _RESERVED_9c = 0x9c,
        _RESERVED_9d = 0x9d,
        _RESERVED_9e = 0x9e,
        _RESERVED_9f = 0x9f,
        _RESERVED_a0 = 0xa0,
        _RESERVED_a1 = 0xa1,
        _RESERVED_a2 = 0xa2,
        _RESERVED_a3 = 0xa3,
        _RESERVED_a4 = 0xa4,
        _RESERVED_a5 = 0xa5,
        _RESERVED_a6 = 0xa6,
        _RESERVED_a7 = 0xa7,
        _RESERVED_a8 = 0xa8,
        _RESERVED_a9 = 0xa9,
        _RESERVED_aa = 0xaa,
        _RESERVED_ab = 0xab,
        _RESERVED_ac = 0xac,
        _RESERVED_ad = 0xad,
        _RESERVED_ae = 0xae,
        _RESERVED_af = 0xaf,
        _RESERVED_b0 = 0xb0,
        _RESERVED_b1 = 0xb1,
        _RESERVED_b2 = 0xb2,
        _RESERVED_b3 = 0xb3,
        _RESERVED_b4 = 0xb4,
        _RESERVED_b5 = 0xb5,
        _RESERVED_b6 = 0xb6,
        _RESERVED_b7 = 0xb7,
        _RESERVED_b8 = 0xb8,
        _RESERVED_b9 = 0xb9,
        _RESERVED_ba = 0xba,
        _RESERVED_bb = 0xbb,
        _RESERVED_bc = 0xbc,
        _RESERVED_bd = 0xbd,
        _RESERVED_be = 0xbe,
        _RESERVED_bf = 0xbf,
        _RESERVED_c0 = 0xc0,
        _RESERVED_c1 = 0xc1,
        _RESERVED_c2 = 0xc2,
        _RESERVED_c3 = 0xc3,
        _RESERVED_c4 = 0xc4,
        _RESERVED_c5 = 0xc5,
        _RESERVED_c6 = 0xc6,
        _RESERVED_c7 = 0xc7,
        _RESERVED_c8 = 0xc8,
        _RESERVED_c9 = 0xc9,
        _RESERVED_ca = 0xca,
        _RESERVED_cb = 0xcb,
        _RESERVED_cc = 0xcc,
        _RESERVED_cd = 0xcd,
        _RESERVED_ce = 0xce,
        _RESERVED_cf = 0xcf,
        _RESERVED_d0 = 0xd0,
        _RESERVED_d1 = 0xd1,
        _RESERVED_d2 = 0xd2,
        _RESERVED_d3 = 0xd3,
        _RESERVED_d4 = 0xd4,
        _RESERVED_d5 = 0xd5,
        _RESERVED_d6 = 0xd6,
        _RESERVED_d7 = 0xd7,
        _RESERVED_d8 = 0xd8,
        _RESERVED_d9 = 0xd9,
        _RESERVED_da = 0xda,
        _RESERVED_db = 0xdb,
        _RESERVED_dc = 0xdc,
        _RESERVED_dd = 0xdd,
        _RESERVED_de = 0xde,
        _RESERVED_df = 0xdf,
        _RESERVED_e0 = 0xe0,
        _RESERVED_e1 = 0xe1,
        _RESERVED_e2 = 0xe2,
        _RESERVED_e3 = 0xe3,
        _RESERVED_e4 = 0xe4,
        _RESERVED_e5 = 0xe5,
        _RESERVED_e6 = 0xe6,
        _RESERVED_e7 = 0xe7,
        _RESERVED_e8 = 0xe8,
        _RESERVED_e9 = 0xe9,
        _RESERVED_ea = 0xea,
        _RESERVED_eb = 0xeb,
        _RESERVED_ec = 0xec,
        _RESERVED_ed = 0xed,
        _RESERVED_ee = 0xee,
        _RESERVED_ef = 0xef,
        _RESERVED_f0 = 0xf0,
        _RESERVED_f1 = 0xf1,
        _RESERVED_f2 = 0xf2,
        _RESERVED_f3 = 0xf3,
        _RESERVED_f4 = 0xf4,
        _RESERVED_f5 = 0xf5,
        _RESERVED_f6 = 0xf6,
        _RESERVED_f7 = 0xf7,
        _RESERVED_f8 = 0xf8,
        _RESERVED_f9 = 0xf9,
        _RESERVED_fa = 0xfa,
        _RESERVED_fb = 0xfb,
        _RESERVED_fc = 0xfc,
        _RESERVED_fd = 0xfd,
        _RESERVED_fe = 0xfe,
        _RESERVED_ff = 0xff,
    }
    impl CpuIntIidxStat {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> CpuIntIidxStat {
            unsafe { core::mem::transmute(val & 0xff) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for CpuIntIidxStat {
        #[inline(always)]
        fn from(val: u8) -> CpuIntIidxStat {
            CpuIntIidxStat::from_bits(val)
        }
    }
    impl From<CpuIntIidxStat> for u8 {
        #[inline(always)]
        fn from(val: CpuIntIidxStat) -> u8 {
            CpuIntIidxStat::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum EvtCfg {
        #[doc = "The interrupt or event line is disabled."]
        DISABLE = 0x0,
        #[doc = "The interrupt or event line is in software mode. Software must clear the RIS."]
        SOFTWARE = 0x01,
        #[doc = "The interrupt or event line is in hardware mode. The hardware (another module) clears automatically the associated RIS flag."]
        HARDWARE = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl EvtCfg {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> EvtCfg {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for EvtCfg {
        #[inline(always)]
        fn from(val: u8) -> EvtCfg {
            EvtCfg::from_bits(val)
        }
    }
    impl From<EvtCfg> for u8 {
        #[inline(always)]
        fn from(val: EvtCfg) -> u8 {
            EvtCfg::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Filteren {
        #[doc = "No additional filter beyond the CDC synchronization sample."]
        DISABLE = 0x0,
        #[doc = "1 ULPCLK minimum sample."]
        ONE_CYCLE = 0x01,
        #[doc = "3 ULPCLK minimum sample."]
        THREE_CYCLE = 0x02,
        #[doc = "8 ULPCLK minimum sample."]
        EIGHT_CYCLE = 0x03,
    }
    impl Filteren {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Filteren {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Filteren {
        #[inline(always)]
        fn from(val: u8) -> Filteren {
            Filteren::from_bits(val)
        }
    }
    impl From<Filteren> for u8 {
        #[inline(always)]
        fn from(val: Filteren) -> u8 {
            Filteren::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum GenEventIidxStat {
        #[doc = "No bit is set means there is no pending interrupt request."]
        NO_INTR = 0x0,
        #[doc = "DIO0 interrupt."]
        DIO0 = 0x01,
        #[doc = "DIO1 interrupt."]
        DIO1 = 0x02,
        #[doc = "DIO2 interrupt."]
        DIO2 = 0x03,
        #[doc = "DIO3 interrupt."]
        DIO3 = 0x04,
        #[doc = "DIO4 interrupt."]
        DIO4 = 0x05,
        #[doc = "DIO5 interrupt."]
        DIO5 = 0x06,
        #[doc = "DIO6 interrupt."]
        DIO6 = 0x07,
        #[doc = "DIO7 interrupt."]
        DIO7 = 0x08,
        #[doc = "DIO8 interrupt."]
        DIO8 = 0x09,
        #[doc = "DIO9 interrupt."]
        DIO9 = 0x0a,
        #[doc = "DIO10 interrupt."]
        DIO10 = 0x0b,
        #[doc = "DIO11 interrupt."]
        DIO11 = 0x0c,
        #[doc = "DIO12 interrupt."]
        DIO12 = 0x0d,
        #[doc = "DIO13 interrupt."]
        DIO13 = 0x0e,
        #[doc = "DIO14 interrupt."]
        DIO14 = 0x0f,
        #[doc = "DIO15 interrupt."]
        DIO15 = 0x10,
        _RESERVED_11 = 0x11,
        _RESERVED_12 = 0x12,
        _RESERVED_13 = 0x13,
        _RESERVED_14 = 0x14,
        _RESERVED_15 = 0x15,
        _RESERVED_16 = 0x16,
        _RESERVED_17 = 0x17,
        _RESERVED_18 = 0x18,
        _RESERVED_19 = 0x19,
        _RESERVED_1a = 0x1a,
        _RESERVED_1b = 0x1b,
        _RESERVED_1c = 0x1c,
        _RESERVED_1d = 0x1d,
        _RESERVED_1e = 0x1e,
        _RESERVED_1f = 0x1f,
        _RESERVED_20 = 0x20,
        _RESERVED_21 = 0x21,
        _RESERVED_22 = 0x22,
        _RESERVED_23 = 0x23,
        _RESERVED_24 = 0x24,
        _RESERVED_25 = 0x25,
        _RESERVED_26 = 0x26,
        _RESERVED_27 = 0x27,
        _RESERVED_28 = 0x28,
        _RESERVED_29 = 0x29,
        _RESERVED_2a = 0x2a,
        _RESERVED_2b = 0x2b,
        _RESERVED_2c = 0x2c,
        _RESERVED_2d = 0x2d,
        _RESERVED_2e = 0x2e,
        _RESERVED_2f = 0x2f,
        _RESERVED_30 = 0x30,
        _RESERVED_31 = 0x31,
        _RESERVED_32 = 0x32,
        _RESERVED_33 = 0x33,
        _RESERVED_34 = 0x34,
        _RESERVED_35 = 0x35,
        _RESERVED_36 = 0x36,
        _RESERVED_37 = 0x37,
        _RESERVED_38 = 0x38,
        _RESERVED_39 = 0x39,
        _RESERVED_3a = 0x3a,
        _RESERVED_3b = 0x3b,
        _RESERVED_3c = 0x3c,
        _RESERVED_3d = 0x3d,
        _RESERVED_3e = 0x3e,
        _RESERVED_3f = 0x3f,
        _RESERVED_40 = 0x40,
        _RESERVED_41 = 0x41,
        _RESERVED_42 = 0x42,
        _RESERVED_43 = 0x43,
        _RESERVED_44 = 0x44,
        _RESERVED_45 = 0x45,
        _RESERVED_46 = 0x46,
        _RESERVED_47 = 0x47,
        _RESERVED_48 = 0x48,
        _RESERVED_49 = 0x49,
        _RESERVED_4a = 0x4a,
        _RESERVED_4b = 0x4b,
        _RESERVED_4c = 0x4c,
        _RESERVED_4d = 0x4d,
        _RESERVED_4e = 0x4e,
        _RESERVED_4f = 0x4f,
        _RESERVED_50 = 0x50,
        _RESERVED_51 = 0x51,
        _RESERVED_52 = 0x52,
        _RESERVED_53 = 0x53,
        _RESERVED_54 = 0x54,
        _RESERVED_55 = 0x55,
        _RESERVED_56 = 0x56,
        _RESERVED_57 = 0x57,
        _RESERVED_58 = 0x58,
        _RESERVED_59 = 0x59,
        _RESERVED_5a = 0x5a,
        _RESERVED_5b = 0x5b,
        _RESERVED_5c = 0x5c,
        _RESERVED_5d = 0x5d,
        _RESERVED_5e = 0x5e,
        _RESERVED_5f = 0x5f,
        _RESERVED_60 = 0x60,
        _RESERVED_61 = 0x61,
        _RESERVED_62 = 0x62,
        _RESERVED_63 = 0x63,
        _RESERVED_64 = 0x64,
        _RESERVED_65 = 0x65,
        _RESERVED_66 = 0x66,
        _RESERVED_67 = 0x67,
        _RESERVED_68 = 0x68,
        _RESERVED_69 = 0x69,
        _RESERVED_6a = 0x6a,
        _RESERVED_6b = 0x6b,
        _RESERVED_6c = 0x6c,
        _RESERVED_6d = 0x6d,
        _RESERVED_6e = 0x6e,
        _RESERVED_6f = 0x6f,
        _RESERVED_70 = 0x70,
        _RESERVED_71 = 0x71,
        _RESERVED_72 = 0x72,
        _RESERVED_73 = 0x73,
        _RESERVED_74 = 0x74,
        _RESERVED_75 = 0x75,
        _RESERVED_76 = 0x76,
        _RESERVED_77 = 0x77,
        _RESERVED_78 = 0x78,
        _RESERVED_79 = 0x79,
        _RESERVED_7a = 0x7a,
        _RESERVED_7b = 0x7b,
        _RESERVED_7c = 0x7c,
        _RESERVED_7d = 0x7d,
        _RESERVED_7e = 0x7e,
        _RESERVED_7f = 0x7f,
        _RESERVED_80 = 0x80,
        _RESERVED_81 = 0x81,
        _RESERVED_82 = 0x82,
        _RESERVED_83 = 0x83,
        _RESERVED_84 = 0x84,
        _RESERVED_85 = 0x85,
        _RESERVED_86 = 0x86,
        _RESERVED_87 = 0x87,
        _RESERVED_88 = 0x88,
        _RESERVED_89 = 0x89,
        _RESERVED_8a = 0x8a,
        _RESERVED_8b = 0x8b,
        _RESERVED_8c = 0x8c,
        _RESERVED_8d = 0x8d,
        _RESERVED_8e = 0x8e,
        _RESERVED_8f = 0x8f,
        _RESERVED_90 = 0x90,
        _RESERVED_91 = 0x91,
        _RESERVED_92 = 0x92,
        _RESERVED_93 = 0x93,
        _RESERVED_94 = 0x94,
        _RESERVED_95 = 0x95,
        _RESERVED_96 = 0x96,
        _RESERVED_97 = 0x97,
        _RESERVED_98 = 0x98,
        _RESERVED_99 = 0x99,
        _RESERVED_9a = 0x9a,
        _RESERVED_9b = 0x9b,
        _RESERVED_9c = 0x9c,
        _RESERVED_9d = 0x9d,
        _RESERVED_9e = 0x9e,
        _RESERVED_9f = 0x9f,
        _RESERVED_a0 = 0xa0,
        _RESERVED_a1 = 0xa1,
        _RESERVED_a2 = 0xa2,
        _RESERVED_a3 = 0xa3,
        _RESERVED_a4 = 0xa4,
        _RESERVED_a5 = 0xa5,
        _RESERVED_a6 = 0xa6,
        _RESERVED_a7 = 0xa7,
        _RESERVED_a8 = 0xa8,
        _RESERVED_a9 = 0xa9,
        _RESERVED_aa = 0xaa,
        _RESERVED_ab = 0xab,
        _RESERVED_ac = 0xac,
        _RESERVED_ad = 0xad,
        _RESERVED_ae = 0xae,
        _RESERVED_af = 0xaf,
        _RESERVED_b0 = 0xb0,
        _RESERVED_b1 = 0xb1,
        _RESERVED_b2 = 0xb2,
        _RESERVED_b3 = 0xb3,
        _RESERVED_b4 = 0xb4,
        _RESERVED_b5 = 0xb5,
        _RESERVED_b6 = 0xb6,
        _RESERVED_b7 = 0xb7,
        _RESERVED_b8 = 0xb8,
        _RESERVED_b9 = 0xb9,
        _RESERVED_ba = 0xba,
        _RESERVED_bb = 0xbb,
        _RESERVED_bc = 0xbc,
        _RESERVED_bd = 0xbd,
        _RESERVED_be = 0xbe,
        _RESERVED_bf = 0xbf,
        _RESERVED_c0 = 0xc0,
        _RESERVED_c1 = 0xc1,
        _RESERVED_c2 = 0xc2,
        _RESERVED_c3 = 0xc3,
        _RESERVED_c4 = 0xc4,
        _RESERVED_c5 = 0xc5,
        _RESERVED_c6 = 0xc6,
        _RESERVED_c7 = 0xc7,
        _RESERVED_c8 = 0xc8,
        _RESERVED_c9 = 0xc9,
        _RESERVED_ca = 0xca,
        _RESERVED_cb = 0xcb,
        _RESERVED_cc = 0xcc,
        _RESERVED_cd = 0xcd,
        _RESERVED_ce = 0xce,
        _RESERVED_cf = 0xcf,
        _RESERVED_d0 = 0xd0,
        _RESERVED_d1 = 0xd1,
        _RESERVED_d2 = 0xd2,
        _RESERVED_d3 = 0xd3,
        _RESERVED_d4 = 0xd4,
        _RESERVED_d5 = 0xd5,
        _RESERVED_d6 = 0xd6,
        _RESERVED_d7 = 0xd7,
        _RESERVED_d8 = 0xd8,
        _RESERVED_d9 = 0xd9,
        _RESERVED_da = 0xda,
        _RESERVED_db = 0xdb,
        _RESERVED_dc = 0xdc,
        _RESERVED_dd = 0xdd,
        _RESERVED_de = 0xde,
        _RESERVED_df = 0xdf,
        _RESERVED_e0 = 0xe0,
        _RESERVED_e1 = 0xe1,
        _RESERVED_e2 = 0xe2,
        _RESERVED_e3 = 0xe3,
        _RESERVED_e4 = 0xe4,
        _RESERVED_e5 = 0xe5,
        _RESERVED_e6 = 0xe6,
        _RESERVED_e7 = 0xe7,
        _RESERVED_e8 = 0xe8,
        _RESERVED_e9 = 0xe9,
        _RESERVED_ea = 0xea,
        _RESERVED_eb = 0xeb,
        _RESERVED_ec = 0xec,
        _RESERVED_ed = 0xed,
        _RESERVED_ee = 0xee,
        _RESERVED_ef = 0xef,
        _RESERVED_f0 = 0xf0,
        _RESERVED_f1 = 0xf1,
        _RESERVED_f2 = 0xf2,
        _RESERVED_f3 = 0xf3,
        _RESERVED_f4 = 0xf4,
        _RESERVED_f5 = 0xf5,
        _RESERVED_f6 = 0xf6,
        _RESERVED_f7 = 0xf7,
        _RESERVED_f8 = 0xf8,
        _RESERVED_f9 = 0xf9,
        _RESERVED_fa = 0xfa,
        _RESERVED_fb = 0xfb,
        _RESERVED_fc = 0xfc,
        _RESERVED_fd = 0xfd,
        _RESERVED_fe = 0xfe,
        _RESERVED_ff = 0xff,
    }
    impl GenEventIidxStat {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> GenEventIidxStat {
            unsafe { core::mem::transmute(val & 0xff) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for GenEventIidxStat {
        #[inline(always)]
        fn from(val: u8) -> GenEventIidxStat {
            GenEventIidxStat::from_bits(val)
        }
    }
    impl From<GenEventIidxStat> for u8 {
        #[inline(always)]
        fn from(val: GenEventIidxStat) -> u8 {
            GenEventIidxStat::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Polarity {
        #[doc = "Edge detection disabled."]
        DISABLE = 0x0,
        #[doc = "Detects rising edge of input event."]
        RISE = 0x01,
        #[doc = "Detects falling edge of input event."]
        FALL = 0x02,
        #[doc = "Detects both rising and falling edge of input event."]
        RISE_FALL = 0x03,
    }
    impl Polarity {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Polarity {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Polarity {
        #[inline(always)]
        fn from(val: u8) -> Polarity {
            Polarity::from_bits(val)
        }
    }
    impl From<Polarity> for u8 {
        #[inline(always)]
        fn from(val: Polarity) -> u8 {
            Polarity::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct PwrenKey(pub u8);
    impl PwrenKey {
        pub const KEY: Self = Self(0x26);
    }
    impl PwrenKey {
        pub const fn from_bits(val: u8) -> PwrenKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for PwrenKey {
        #[inline(always)]
        fn from(val: u8) -> PwrenKey {
            PwrenKey::from_bits(val)
        }
    }
    impl From<PwrenKey> for u8 {
        #[inline(always)]
        fn from(val: PwrenKey) -> u8 {
            PwrenKey::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct ResetKey(pub u8);
    impl ResetKey {
        pub const KEY: Self = Self(0xb1);
    }
    impl ResetKey {
        pub const fn from_bits(val: u8) -> ResetKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for ResetKey {
        #[inline(always)]
        fn from(val: u8) -> ResetKey {
            ResetKey::from_bits(val)
        }
    }
    impl From<ResetKey> for u8 {
        #[inline(always)]
        fn from(val: ResetKey) -> u8 {
            ResetKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum RunStop {
        #[doc = "Run/ungate functional clock."]
        RUN = 0x0,
        #[doc = "Stop/gate functional clock."]
        STOP = 0x01,
    }
    impl RunStop {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> RunStop {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for RunStop {
        #[inline(always)]
        fn from(val: u8) -> RunStop {
            RunStop::from_bits(val)
        }
    }
    impl From<RunStop> for u8 {
        #[inline(always)]
        fn from(val: RunStop) -> u8 {
            RunStop::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum SubcfgOutpolicy {
        #[doc = "Selected DIO pins are set."]
        SET = 0x0,
        #[doc = "Selected DIO pins are cleared."]
        CLR = 0x01,
        #[doc = "Selected DIO pins are toggled."]
        TOGGLE = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl SubcfgOutpolicy {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> SubcfgOutpolicy {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for SubcfgOutpolicy {
        #[inline(always)]
        fn from(val: u8) -> SubcfgOutpolicy {
            SubcfgOutpolicy::from_bits(val)
        }
    }
    impl From<SubcfgOutpolicy> for u8 {
        #[inline(always)]
        fn from(val: SubcfgOutpolicy) -> u8 {
            SubcfgOutpolicy::to_bits(val)
        }
    }
}
