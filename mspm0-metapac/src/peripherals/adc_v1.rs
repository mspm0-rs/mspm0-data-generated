// This file is autogenerated by mspm0-metapac-gen: do not edit by hand.
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::identity_op)]
#![allow(clippy::unnecessary_cast)]
#![allow(clippy::erasing_op)]

#[doc = "PERIPHERALREGION."]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Adc {
    ptr: *mut u8,
}
unsafe impl Send for Adc {}
unsafe impl Sync for Adc {}
impl Adc {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Subscriber Configuration Register."]
    #[inline(always)]
    pub const fn fsub(self) -> crate::common::Reg<regs::Fport, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
    }
    #[doc = "Publisher Configuration Register."]
    #[inline(always)]
    pub const fn fpub(self) -> crate::common::Reg<regs::Fport, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0444usize) as _) }
    }
    #[inline(always)]
    pub const fn gprcm(self, n: usize) -> Gprcm {
        assert!(n < 1usize);
        unsafe { Gprcm::from_ptr(self.ptr.add(0x0800usize + n * 24usize) as _) }
    }
    #[inline(always)]
    pub const fn cpu_int(self, n: usize) -> CpuInt {
        assert!(n < 1usize);
        unsafe { CpuInt::from_ptr(self.ptr.add(0x1020usize + n * 44usize) as _) }
    }
    #[inline(always)]
    pub const fn gen_event(self, n: usize) -> GenEvent {
        assert!(n < 1usize);
        unsafe { GenEvent::from_ptr(self.ptr.add(0x1050usize + n * 44usize) as _) }
    }
    #[inline(always)]
    pub const fn dma_trig(self, n: usize) -> DmaTrig {
        assert!(n < 1usize);
        unsafe { DmaTrig::from_ptr(self.ptr.add(0x1080usize + n * 44usize) as _) }
    }
    #[doc = "Event Mode."]
    #[inline(always)]
    pub const fn evt_mode(self) -> crate::common::Reg<regs::EvtMode, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10e0usize) as _) }
    }
    #[doc = "Module Description."]
    #[inline(always)]
    pub const fn desc(self) -> crate::common::Reg<regs::Desc, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10fcusize) as _) }
    }
    #[doc = "Control Register 0."]
    #[inline(always)]
    pub const fn ctl0(self) -> crate::common::Reg<regs::Ctl0, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1100usize) as _) }
    }
    #[doc = "Control Register 1."]
    #[inline(always)]
    pub const fn ctl1(self) -> crate::common::Reg<regs::Ctl1, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1104usize) as _) }
    }
    #[doc = "Control Register 2."]
    #[inline(always)]
    pub const fn ctl2(self) -> crate::common::Reg<regs::Ctl2, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1108usize) as _) }
    }
    #[doc = "Sample Clock Frequency Range Register."]
    #[inline(always)]
    pub const fn clkfreq(self) -> crate::common::Reg<regs::Clkfreq, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1110usize) as _) }
    }
    #[doc = "Sample Time Compare 0 Register."]
    #[inline(always)]
    pub const fn scomp0(self) -> crate::common::Reg<regs::Scomp0, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1114usize) as _) }
    }
    #[doc = "Sample Time Compare 1 Register."]
    #[inline(always)]
    pub const fn scomp1(self) -> crate::common::Reg<regs::Scomp1, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1118usize) as _) }
    }
    #[doc = "Window Comparator Low Threshold Register."]
    #[inline(always)]
    pub const fn wclow(self) -> crate::common::Reg<regs::Wclow, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1148usize) as _) }
    }
    #[doc = "Window Comparator High Threshold Register."]
    #[inline(always)]
    pub const fn wchigh(self) -> crate::common::Reg<regs::Wchigh, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1150usize) as _) }
    }
    #[doc = "Conversion Memory Control Register."]
    #[inline(always)]
    pub const fn memctl(self, n: usize) -> crate::common::Reg<regs::Memctl, crate::common::RW> {
        assert!(n < 24usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1180usize + n * 4usize) as _) }
    }
    #[doc = "Memory result register."]
    #[inline(always)]
    pub const fn memres(self, n: usize) -> crate::common::Reg<regs::Memres, crate::common::R> {
        assert!(n < 24usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1280usize + n * 4usize) as _) }
    }
    #[doc = "Status Register."]
    #[inline(always)]
    pub const fn status(self) -> crate::common::Reg<regs::Status, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1340usize) as _) }
    }
}
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct CpuInt {
    ptr: *mut u8,
}
unsafe impl Send for CpuInt {}
unsafe impl Sync for CpuInt {}
impl CpuInt {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Interrupt index."]
    #[inline(always)]
    pub const fn iidx(self) -> crate::common::Reg<regs::CpuIntIidx, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "Interrupt mask."]
    #[inline(always)]
    pub const fn imask(self) -> crate::common::Reg<regs::CpuInt, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
    }
    #[doc = "Raw interrupt status."]
    #[inline(always)]
    pub const fn ris(self) -> crate::common::Reg<regs::CpuInt, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
    }
    #[doc = "Masked interrupt status."]
    #[inline(always)]
    pub const fn mis(self) -> crate::common::Reg<regs::CpuInt, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
    }
    #[doc = "Interrupt set."]
    #[inline(always)]
    pub const fn iset(self) -> crate::common::Reg<regs::CpuInt, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
    }
    #[doc = "Interrupt clear."]
    #[inline(always)]
    pub const fn iclr(self) -> crate::common::Reg<regs::CpuInt, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
    }
}
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct DmaTrig {
    ptr: *mut u8,
}
unsafe impl Send for DmaTrig {}
unsafe impl Sync for DmaTrig {}
impl DmaTrig {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Interrupt index."]
    #[inline(always)]
    pub const fn iidx(self) -> crate::common::Reg<regs::DmaTrigIidx, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "Interrupt mask extension."]
    #[inline(always)]
    pub const fn imask(self) -> crate::common::Reg<regs::DmaTrig, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
    }
    #[doc = "Raw interrupt status extension."]
    #[inline(always)]
    pub const fn ris(self) -> crate::common::Reg<regs::DmaTrig, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
    }
    #[doc = "Masked interrupt status extension."]
    #[inline(always)]
    pub const fn mis(self) -> crate::common::Reg<regs::DmaTrig, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
    }
    #[doc = "Interrupt set extension."]
    #[inline(always)]
    pub const fn iset(self) -> crate::common::Reg<regs::DmaTrig, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
    }
    #[doc = "Interrupt clear extension."]
    #[inline(always)]
    pub const fn iclr(self) -> crate::common::Reg<regs::DmaTrig, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
    }
}
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct GenEvent {
    ptr: *mut u8,
}
unsafe impl Send for GenEvent {}
unsafe impl Sync for GenEvent {}
impl GenEvent {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Interrupt index."]
    #[inline(always)]
    pub const fn iidx(self) -> crate::common::Reg<regs::GenEventIidx, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "Interrupt mask."]
    #[inline(always)]
    pub const fn imask(self) -> crate::common::Reg<regs::GenEvent, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
    }
    #[doc = "Raw interrupt status."]
    #[inline(always)]
    pub const fn ris(self) -> crate::common::Reg<regs::GenEvent, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
    }
    #[doc = "Masked interrupt status."]
    #[inline(always)]
    pub const fn mis(self) -> crate::common::Reg<regs::GenEvent, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
    }
    #[doc = "Interrupt set."]
    #[inline(always)]
    pub const fn iset(self) -> crate::common::Reg<regs::GenEvent, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
    }
    #[doc = "Interrupt clear."]
    #[inline(always)]
    pub const fn iclr(self) -> crate::common::Reg<regs::GenEvent, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
    }
}
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Gprcm {
    ptr: *mut u8,
}
unsafe impl Send for Gprcm {}
unsafe impl Sync for Gprcm {}
impl Gprcm {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Power enable."]
    #[inline(always)]
    pub const fn pwren(self) -> crate::common::Reg<regs::Pwren, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "Reset Control."]
    #[inline(always)]
    pub const fn rstctl(self) -> crate::common::Reg<regs::Rstctl, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
    }
    #[doc = "ADC clock configuration Register."]
    #[inline(always)]
    pub const fn clkcfg(self) -> crate::common::Reg<regs::Clkcfg, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
    }
    #[doc = "Status Register."]
    #[inline(always)]
    pub const fn stat(self) -> crate::common::Reg<regs::Stat, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
    }
}
pub mod regs {
    #[doc = "ADC clock configuration Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Clkcfg(pub u32);
    impl Clkcfg {
        #[doc = "ADC sample clock source selection."]
        #[inline(always)]
        pub const fn sampclk(&self) -> super::vals::Sampclk {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::Sampclk::from_bits(val as u8)
        }
        #[doc = "ADC sample clock source selection."]
        #[inline(always)]
        pub fn set_sampclk(&mut self, val: super::vals::Sampclk) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
        #[doc = "CCONRUN: Forces SYSOSC to run at base frequency when device is in RUN mode which can be used as ADC sample or conversion clock source."]
        #[inline(always)]
        pub const fn cconrun(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "CCONRUN: Forces SYSOSC to run at base frequency when device is in RUN mode which can be used as ADC sample or conversion clock source."]
        #[inline(always)]
        pub fn set_cconrun(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "CCONSTOP: Forces SYSOSC to run at base frequency when device is in STOP mode which can be used as ADC sample or conversion clock source."]
        #[inline(always)]
        pub const fn cconstop(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "CCONSTOP: Forces SYSOSC to run at base frequency when device is in STOP mode which can be used as ADC sample or conversion clock source."]
        #[inline(always)]
        pub fn set_cconstop(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "KEY to Allow State Change A9h = KEY to allow write access to this register"]
        #[inline(always)]
        pub const fn key(&self) -> super::vals::ClkcfgKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::ClkcfgKey::from_bits(val as u8)
        }
        #[doc = "KEY to Allow State Change A9h = KEY to allow write access to this register"]
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::ClkcfgKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Clkcfg {
        #[inline(always)]
        fn default() -> Clkcfg {
            Clkcfg(0)
        }
    }
    #[doc = "Sample Clock Frequency Range Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Clkfreq(pub u32);
    impl Clkfreq {
        #[doc = "Frequency Range."]
        #[inline(always)]
        pub const fn frange(&self) -> super::vals::Frange {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::Frange::from_bits(val as u8)
        }
        #[doc = "Frequency Range."]
        #[inline(always)]
        pub fn set_frange(&mut self, val: super::vals::Frange) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
    }
    impl Default for Clkfreq {
        #[inline(always)]
        fn default() -> Clkfreq {
            Clkfreq(0)
        }
    }
    #[doc = "Interrupt clear."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct CpuInt(pub u32);
    impl CpuInt {
        #[doc = "Raw interrupt flag for MEMRESx overflow. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1."]
        #[inline(always)]
        pub const fn ovifg(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Raw interrupt flag for MEMRESx overflow. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1."]
        #[inline(always)]
        pub fn set_ovifg(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Raw interrupt flag for sequence conversion timeout overflow. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1."]
        #[inline(always)]
        pub const fn tovifg(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Raw interrupt flag for sequence conversion timeout overflow. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1."]
        #[inline(always)]
        pub fn set_tovifg(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Raw interrupt flag for the MEMRESx result register being higher than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1."]
        #[inline(always)]
        pub const fn highifg(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Raw interrupt flag for the MEMRESx result register being higher than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1."]
        #[inline(always)]
        pub fn set_highifg(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Raw interrupt flag for the MEMRESx result register being below than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1."]
        #[inline(always)]
        pub const fn lowifg(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Raw interrupt flag for the MEMRESx result register being below than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1."]
        #[inline(always)]
        pub fn set_lowifg(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Mask INIFG in MIS_EX register."]
        #[inline(always)]
        pub const fn inifg(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Mask INIFG in MIS_EX register."]
        #[inline(always)]
        pub fn set_inifg(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Raw interrupt flag for DMADONE. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1."]
        #[inline(always)]
        pub const fn dmadone(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "Raw interrupt flag for DMADONE. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1."]
        #[inline(always)]
        pub fn set_dmadone(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "Raw interrupt flag for MEMRESx underflow. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1."]
        #[inline(always)]
        pub const fn uvifg(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "Raw interrupt flag for MEMRESx underflow. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1."]
        #[inline(always)]
        pub fn set_uvifg(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "Raw interrupt status for MEMRES0. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1."]
        #[inline(always)]
        pub const fn memresifg(&self, n: usize) -> bool {
            assert!(n < 24usize);
            let offs = 8usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "Raw interrupt status for MEMRES0. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1."]
        #[inline(always)]
        pub fn set_memresifg(&mut self, n: usize, val: bool) {
            assert!(n < 24usize);
            let offs = 8usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for CpuInt {
        #[inline(always)]
        fn default() -> CpuInt {
            CpuInt(0)
        }
    }
    #[doc = "Interrupt index."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct CpuIntIidx(pub u32);
    impl CpuIntIidx {
        #[doc = "Interrupt index status."]
        #[inline(always)]
        pub const fn stat(&self) -> super::vals::CpuIntIidxStat {
            let val = (self.0 >> 0usize) & 0x03ff;
            super::vals::CpuIntIidxStat::from_bits(val as u16)
        }
        #[doc = "Interrupt index status."]
        #[inline(always)]
        pub fn set_stat(&mut self, val: super::vals::CpuIntIidxStat) {
            self.0 = (self.0 & !(0x03ff << 0usize)) | (((val.to_bits() as u32) & 0x03ff) << 0usize);
        }
    }
    impl Default for CpuIntIidx {
        #[inline(always)]
        fn default() -> CpuIntIidx {
            CpuIntIidx(0)
        }
    }
    #[doc = "Control Register 0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ctl0(pub u32);
    impl Ctl0 {
        #[doc = "Enable conversion."]
        #[inline(always)]
        pub const fn enc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Enable conversion."]
        #[inline(always)]
        pub fn set_enc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Power down policy."]
        #[inline(always)]
        pub const fn pwrdn(&self) -> super::vals::Pwrdn {
            let val = (self.0 >> 16usize) & 0x01;
            super::vals::Pwrdn::from_bits(val as u8)
        }
        #[doc = "Power down policy."]
        #[inline(always)]
        pub fn set_pwrdn(&mut self, val: super::vals::Pwrdn) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
        }
        #[doc = "Sample clock divider."]
        #[inline(always)]
        pub const fn sclkdiv(&self) -> super::vals::Sclkdiv {
            let val = (self.0 >> 24usize) & 0x07;
            super::vals::Sclkdiv::from_bits(val as u8)
        }
        #[doc = "Sample clock divider."]
        #[inline(always)]
        pub fn set_sclkdiv(&mut self, val: super::vals::Sclkdiv) {
            self.0 = (self.0 & !(0x07 << 24usize)) | (((val.to_bits() as u32) & 0x07) << 24usize);
        }
    }
    impl Default for Ctl0 {
        #[inline(always)]
        fn default() -> Ctl0 {
            Ctl0(0)
        }
    }
    #[doc = "Control Register 1."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ctl1(pub u32);
    impl Ctl1 {
        #[doc = "Sample trigger source."]
        #[inline(always)]
        pub const fn trigsrc(&self) -> super::vals::Trigsrc {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Trigsrc::from_bits(val as u8)
        }
        #[doc = "Sample trigger source."]
        #[inline(always)]
        pub fn set_trigsrc(&mut self, val: super::vals::Trigsrc) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "Start of conversion."]
        #[inline(always)]
        pub const fn sc(&self) -> super::vals::Sc {
            let val = (self.0 >> 8usize) & 0x01;
            super::vals::Sc::from_bits(val as u8)
        }
        #[doc = "Start of conversion."]
        #[inline(always)]
        pub fn set_sc(&mut self, val: super::vals::Sc) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
        }
        #[doc = "Conversion sequence mode."]
        #[inline(always)]
        pub const fn conseq(&self) -> super::vals::Conseq {
            let val = (self.0 >> 16usize) & 0x03;
            super::vals::Conseq::from_bits(val as u8)
        }
        #[doc = "Conversion sequence mode."]
        #[inline(always)]
        pub fn set_conseq(&mut self, val: super::vals::Conseq) {
            self.0 = (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
        }
        #[doc = "Sample mode. This bit selects the source of the sampling signal. MANUAL option is not valid when TRIGSRC is selected as hardware event trigger."]
        #[inline(always)]
        pub const fn sampmode(&self) -> super::vals::Sampmode {
            let val = (self.0 >> 20usize) & 0x01;
            super::vals::Sampmode::from_bits(val as u8)
        }
        #[doc = "Sample mode. This bit selects the source of the sampling signal. MANUAL option is not valid when TRIGSRC is selected as hardware event trigger."]
        #[inline(always)]
        pub fn set_sampmode(&mut self, val: super::vals::Sampmode) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
        }
        #[doc = "Hardware averager numerator. Selects number of conversions to accumulate for current MEMCTLx and then it is divided by AVGD. Result will be stored in MEMRESx."]
        #[inline(always)]
        pub const fn avgn(&self) -> super::vals::Avgn {
            let val = (self.0 >> 24usize) & 0x07;
            super::vals::Avgn::from_bits(val as u8)
        }
        #[doc = "Hardware averager numerator. Selects number of conversions to accumulate for current MEMCTLx and then it is divided by AVGD. Result will be stored in MEMRESx."]
        #[inline(always)]
        pub fn set_avgn(&mut self, val: super::vals::Avgn) {
            self.0 = (self.0 & !(0x07 << 24usize)) | (((val.to_bits() as u32) & 0x07) << 24usize);
        }
        #[doc = "Hardware averager denominator. The number to divide the accumulated value by (this is a shift). Note result register is maximum of 16-bits long so if not shifted appropriately result will be truncated."]
        #[inline(always)]
        pub const fn avgd(&self) -> u8 {
            let val = (self.0 >> 28usize) & 0x07;
            val as u8
        }
        #[doc = "Hardware averager denominator. The number to divide the accumulated value by (this is a shift). Note result register is maximum of 16-bits long so if not shifted appropriately result will be truncated."]
        #[inline(always)]
        pub fn set_avgd(&mut self, val: u8) {
            self.0 = (self.0 & !(0x07 << 28usize)) | (((val as u32) & 0x07) << 28usize);
        }
    }
    impl Default for Ctl1 {
        #[inline(always)]
        fn default() -> Ctl1 {
            Ctl1(0)
        }
    }
    #[doc = "Control Register 2."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ctl2(pub u32);
    impl Ctl2 {
        #[doc = "Data read-back format. Data is always stored in binary unsigned format."]
        #[inline(always)]
        pub const fn df(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Data read-back format. Data is always stored in binary unsigned format."]
        #[inline(always)]
        pub fn set_df(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Resolution. These bits define the resolution of ADC conversion result. Note : A value of 3 defaults to 12-bits resolution."]
        #[inline(always)]
        pub const fn res(&self) -> super::vals::Res {
            let val = (self.0 >> 1usize) & 0x03;
            super::vals::Res::from_bits(val as u8)
        }
        #[doc = "Resolution. These bits define the resolution of ADC conversion result. Note : A value of 3 defaults to 12-bits resolution."]
        #[inline(always)]
        pub fn set_res(&mut self, val: super::vals::Res) {
            self.0 = (self.0 & !(0x03 << 1usize)) | (((val.to_bits() as u32) & 0x03) << 1usize);
        }
        #[doc = "0: Sample and hold capacitor is not explicitly discharged at the end of conversion. 1: Sample and hold capacitor is discharged at the end of conversion. This incurs one additional conversion clock cycle."]
        #[inline(always)]
        pub const fn rstsampcapen(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "0: Sample and hold capacitor is not explicitly discharged at the end of conversion. 1: Sample and hold capacitor is discharged at the end of conversion. This incurs one additional conversion clock cycle."]
        #[inline(always)]
        pub fn set_rstsampcapen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Enable DMA trigger for data transfer. Note: DMAEN bit is cleared by hardware based on DMA done signal at the end of data transfer. Software has to re-enable DMAEN bit for ADC to generate DMA triggers."]
        #[inline(always)]
        pub const fn dmaen(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "Enable DMA trigger for data transfer. Note: DMAEN bit is cleared by hardware based on DMA done signal at the end of data transfer. Software has to re-enable DMAEN bit for ADC to generate DMA triggers."]
        #[inline(always)]
        pub fn set_dmaen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "Enable FIFO based operation."]
        #[inline(always)]
        pub const fn fifoen(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "Enable FIFO based operation."]
        #[inline(always)]
        pub fn set_fifoen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "Number of ADC converted samples to be transferred on a DMA trigger."]
        #[inline(always)]
        pub const fn sampcnt(&self) -> super::vals::Sampcnt {
            let val = (self.0 >> 11usize) & 0x1f;
            super::vals::Sampcnt::from_bits(val as u8)
        }
        #[doc = "Number of ADC converted samples to be transferred on a DMA trigger."]
        #[inline(always)]
        pub fn set_sampcnt(&mut self, val: super::vals::Sampcnt) {
            self.0 = (self.0 & !(0x1f << 11usize)) | (((val.to_bits() as u32) & 0x1f) << 11usize);
        }
        #[doc = "Sequencer start address. These bits select which MEMCTLx is used for single conversion or as first MEMCTL for sequence mode. The value of STARTADD is 0x00 to 0x17, corresponding to MEMRES0 to MEMRES23."]
        #[inline(always)]
        pub const fn startadd(&self) -> u8 {
            let val = (self.0 >> 16usize) & 0x1f;
            val as u8
        }
        #[doc = "Sequencer start address. These bits select which MEMCTLx is used for single conversion or as first MEMCTL for sequence mode. The value of STARTADD is 0x00 to 0x17, corresponding to MEMRES0 to MEMRES23."]
        #[inline(always)]
        pub fn set_startadd(&mut self, val: u8) {
            self.0 = (self.0 & !(0x1f << 16usize)) | (((val as u32) & 0x1f) << 16usize);
        }
        #[doc = "Sequence end address. These bits select which MEMCTLx is the last one for the sequence mode. The value of ENDADD is 0x00 to 0x17, corresponding to MEMRES0 to MEMRES23."]
        #[inline(always)]
        pub const fn endadd(&self) -> u8 {
            let val = (self.0 >> 24usize) & 0x1f;
            val as u8
        }
        #[doc = "Sequence end address. These bits select which MEMCTLx is the last one for the sequence mode. The value of ENDADD is 0x00 to 0x17, corresponding to MEMRES0 to MEMRES23."]
        #[inline(always)]
        pub fn set_endadd(&mut self, val: u8) {
            self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
        }
    }
    impl Default for Ctl2 {
        #[inline(always)]
        fn default() -> Ctl2 {
            Ctl2(0)
        }
    }
    #[doc = "Module Description."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Desc(pub u32);
    impl Desc {
        #[doc = "Minor rev of the IP."]
        #[inline(always)]
        pub const fn minrev(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x0f;
            val as u8
        }
        #[doc = "Minor rev of the IP."]
        #[inline(always)]
        pub fn set_minrev(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
        }
        #[doc = "Major rev of the IP."]
        #[inline(always)]
        pub const fn majrev(&self) -> u8 {
            let val = (self.0 >> 4usize) & 0x0f;
            val as u8
        }
        #[doc = "Major rev of the IP."]
        #[inline(always)]
        pub fn set_majrev(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
        }
        #[doc = "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances."]
        #[inline(always)]
        pub const fn instnum(&self) -> u8 {
            let val = (self.0 >> 8usize) & 0x0f;
            val as u8
        }
        #[doc = "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances."]
        #[inline(always)]
        pub fn set_instnum(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
        }
        #[doc = "Feature Set for the module *instance*."]
        #[inline(always)]
        pub const fn featurever(&self) -> u8 {
            let val = (self.0 >> 12usize) & 0x0f;
            val as u8
        }
        #[doc = "Feature Set for the module *instance*."]
        #[inline(always)]
        pub fn set_featurever(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
        }
        #[doc = "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness."]
        #[inline(always)]
        pub const fn moduleid(&self) -> u16 {
            let val = (self.0 >> 16usize) & 0xffff;
            val as u16
        }
        #[doc = "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness."]
        #[inline(always)]
        pub fn set_moduleid(&mut self, val: u16) {
            self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
        }
    }
    impl Default for Desc {
        #[inline(always)]
        fn default() -> Desc {
            Desc(0)
        }
    }
    #[doc = "Interrupt clear extension."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTrig(pub u32);
    impl DmaTrig {
        #[doc = "Raw interrupt status for MEMRES0. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1."]
        #[inline(always)]
        pub const fn memresifg(&self, n: usize) -> bool {
            assert!(n < 24usize);
            let offs = 8usize + n * 1usize;
            let val = (self.0 >> offs) & 0x01;
            val != 0
        }
        #[doc = "Raw interrupt status for MEMRES0. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1."]
        #[inline(always)]
        pub fn set_memresifg(&mut self, n: usize, val: bool) {
            assert!(n < 24usize);
            let offs = 8usize + n * 1usize;
            self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
        }
    }
    impl Default for DmaTrig {
        #[inline(always)]
        fn default() -> DmaTrig {
            DmaTrig(0)
        }
    }
    #[doc = "Interrupt index."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTrigIidx(pub u32);
    impl DmaTrigIidx {
        #[doc = "Interrupt index status."]
        #[inline(always)]
        pub const fn stat(&self) -> super::vals::DmaTrigIidxStat {
            let val = (self.0 >> 0usize) & 0x03ff;
            super::vals::DmaTrigIidxStat::from_bits(val as u16)
        }
        #[doc = "Interrupt index status."]
        #[inline(always)]
        pub fn set_stat(&mut self, val: super::vals::DmaTrigIidxStat) {
            self.0 = (self.0 & !(0x03ff << 0usize)) | (((val.to_bits() as u32) & 0x03ff) << 0usize);
        }
    }
    impl Default for DmaTrigIidx {
        #[inline(always)]
        fn default() -> DmaTrigIidx {
            DmaTrigIidx(0)
        }
    }
    #[doc = "Event Mode."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EvtMode(pub u32);
    impl EvtMode {
        #[doc = "Event line mode select for event corresponding to CPU_INT."]
        #[inline(always)]
        pub const fn cpu(&self) -> super::vals::IntCfg {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::IntCfg::from_bits(val as u8)
        }
        #[doc = "Event line mode select for event corresponding to CPU_INT."]
        #[inline(always)]
        pub fn set_cpu(&mut self, val: super::vals::IntCfg) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
        #[doc = "Event line mode select for event corresponding to GEN_EVENT."]
        #[inline(always)]
        pub const fn evt1_cfg(&self) -> super::vals::Evt1Cfg {
            let val = (self.0 >> 2usize) & 0x03;
            super::vals::Evt1Cfg::from_bits(val as u8)
        }
        #[doc = "Event line mode select for event corresponding to GEN_EVENT."]
        #[inline(always)]
        pub fn set_evt1_cfg(&mut self, val: super::vals::Evt1Cfg) {
            self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
        }
    }
    impl Default for EvtMode {
        #[inline(always)]
        fn default() -> EvtMode {
            EvtMode(0)
        }
    }
    #[doc = "Publisher Configuration Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Fport(pub u32);
    impl Fport {
        #[doc = "0 = disconnected. 1-15 = connected to channelID = CHANID."]
        #[inline(always)]
        pub const fn chanid(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x0f;
            val as u8
        }
        #[doc = "0 = disconnected. 1-15 = connected to channelID = CHANID."]
        #[inline(always)]
        pub fn set_chanid(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
        }
    }
    impl Default for Fport {
        #[inline(always)]
        fn default() -> Fport {
            Fport(0)
        }
    }
    #[doc = "Interrupt clear."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct GenEvent(pub u32);
    impl GenEvent {
        #[doc = "Raw interrupt flag for the MEMRESx result register being higher than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1."]
        #[inline(always)]
        pub const fn highifg(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Raw interrupt flag for the MEMRESx result register being higher than the WCHIGHx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1."]
        #[inline(always)]
        pub fn set_highifg(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Raw interrupt flag for the MEMRESx result register being below than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1."]
        #[inline(always)]
        pub const fn lowifg(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Raw interrupt flag for the MEMRESx result register being below than the WCLOWx threshold of the window comparator. This bit is reset to 0 by IIDX read or when corresponding bit in ICLR_EX is set to 1."]
        #[inline(always)]
        pub fn set_lowifg(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "Mask INIFG in MIS_EX register."]
        #[inline(always)]
        pub const fn inifg(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Mask INIFG in MIS_EX register."]
        #[inline(always)]
        pub fn set_inifg(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "Raw interrupt status for MEMRES0. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1."]
        #[inline(always)]
        pub const fn memresifg0(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "Raw interrupt status for MEMRES0. This bit is set to 1 when MEMRES0 is loaded with a new conversion result. Reading MEMRES0 register will clear this bit, or when the corresponding bit in ICLR is set to 1."]
        #[inline(always)]
        pub fn set_memresifg0(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
    }
    impl Default for GenEvent {
        #[inline(always)]
        fn default() -> GenEvent {
            GenEvent(0)
        }
    }
    #[doc = "Interrupt index."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct GenEventIidx(pub u32);
    impl GenEventIidx {
        #[doc = "Interrupt index status."]
        #[inline(always)]
        pub const fn stat(&self) -> super::vals::GenEventIidxStat {
            let val = (self.0 >> 0usize) & 0x03ff;
            super::vals::GenEventIidxStat::from_bits(val as u16)
        }
        #[doc = "Interrupt index status."]
        #[inline(always)]
        pub fn set_stat(&mut self, val: super::vals::GenEventIidxStat) {
            self.0 = (self.0 & !(0x03ff << 0usize)) | (((val.to_bits() as u32) & 0x03ff) << 0usize);
        }
    }
    impl Default for GenEventIidx {
        #[inline(always)]
        fn default() -> GenEventIidx {
            GenEventIidx(0)
        }
    }
    #[doc = "Conversion Memory Control Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Memctl(pub u32);
    impl Memctl {
        #[doc = "Input channel select."]
        #[inline(always)]
        pub const fn chansel(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x1f;
            val as u8
        }
        #[doc = "Input channel select."]
        #[inline(always)]
        pub fn set_chansel(&mut self, val: u8) {
            self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
        }
        #[doc = "Voltage reference selection. VEREFM must be connected to on-board ground when external reference option is selected. Note: Writing value 0x3 defaults to INTREF."]
        #[inline(always)]
        pub const fn vrsel(&self) -> super::vals::Vrsel {
            let val = (self.0 >> 8usize) & 0x07;
            super::vals::Vrsel::from_bits(val as u8)
        }
        #[doc = "Voltage reference selection. VEREFM must be connected to on-board ground when external reference option is selected. Note: Writing value 0x3 defaults to INTREF."]
        #[inline(always)]
        pub fn set_vrsel(&mut self, val: super::vals::Vrsel) {
            self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
        }
        #[doc = "Selects the source of sample timer period between SCOMP0 and SCOMP1."]
        #[inline(always)]
        pub const fn stime(&self) -> super::vals::Stime {
            let val = (self.0 >> 12usize) & 0x01;
            super::vals::Stime::from_bits(val as u8)
        }
        #[doc = "Selects the source of sample timer period between SCOMP0 and SCOMP1."]
        #[inline(always)]
        pub fn set_stime(&mut self, val: super::vals::Stime) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
        }
        #[doc = "Enable hardware averaging."]
        #[inline(always)]
        pub const fn avgen(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "Enable hardware averaging."]
        #[inline(always)]
        pub fn set_avgen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "Enable burn out current source."]
        #[inline(always)]
        pub const fn bcsen(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "Enable burn out current source."]
        #[inline(always)]
        pub fn set_bcsen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "Trigger policy. Indicates if a trigger will be needed to step to the next MEMCTL in the sequence or to perform next conversion in the case of repeat single channel conversions."]
        #[inline(always)]
        pub const fn trig(&self) -> super::vals::Trig {
            let val = (self.0 >> 24usize) & 0x01;
            super::vals::Trig::from_bits(val as u8)
        }
        #[doc = "Trigger policy. Indicates if a trigger will be needed to step to the next MEMCTL in the sequence or to perform next conversion in the case of repeat single channel conversions."]
        #[inline(always)]
        pub fn set_trig(&mut self, val: super::vals::Trig) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
        }
        #[doc = "Enable window comparator."]
        #[inline(always)]
        pub const fn wincomp(&self) -> bool {
            let val = (self.0 >> 28usize) & 0x01;
            val != 0
        }
        #[doc = "Enable window comparator."]
        #[inline(always)]
        pub fn set_wincomp(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
        }
    }
    impl Default for Memctl {
        #[inline(always)]
        fn default() -> Memctl {
            Memctl(0)
        }
    }
    #[doc = "MEMRES result register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Memres(pub u32);
    impl Memres {
        #[inline(always)]
        pub const fn data(&self) -> u16 {
            let val = (self.0 >> 0usize) & 0xffff;
            val as u16
        }
        #[inline(always)]
        pub fn set_data(&mut self, val: u16) {
            self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
        }
    }
    impl Default for Memres {
        #[inline(always)]
        fn default() -> Memres {
            Memres(0)
        }
    }
    #[doc = "Power enable."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pwren(pub u32);
    impl Pwren {
        #[doc = "Enable the power."]
        #[inline(always)]
        pub const fn enable(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Enable the power."]
        #[inline(always)]
        pub fn set_enable(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "KEY to allow Power State Change 26h = KEY to allow write access to this register"]
        #[inline(always)]
        pub const fn key(&self) -> super::vals::PwrenKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::PwrenKey::from_bits(val as u8)
        }
        #[doc = "KEY to allow Power State Change 26h = KEY to allow write access to this register"]
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::PwrenKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Pwren {
        #[inline(always)]
        fn default() -> Pwren {
            Pwren(0)
        }
    }
    #[doc = "Reset Control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rstctl(pub u32);
    impl Rstctl {
        #[doc = "Assert reset to the peripheral."]
        #[inline(always)]
        pub const fn resetassert(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Assert reset to the peripheral."]
        #[inline(always)]
        pub fn set_resetassert(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Clear the RESETSTKY bit in the STAT register."]
        #[inline(always)]
        pub const fn resetstkyclr(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Clear the RESETSTKY bit in the STAT register."]
        #[inline(always)]
        pub fn set_resetstkyclr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Unlock key B1h = KEY to allow write access to this register"]
        #[inline(always)]
        pub const fn key(&self) -> super::vals::ResetKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::ResetKey::from_bits(val as u8)
        }
        #[doc = "Unlock key B1h = KEY to allow write access to this register"]
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::ResetKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Rstctl {
        #[inline(always)]
        fn default() -> Rstctl {
            Rstctl(0)
        }
    }
    #[doc = "Sample Time Compare 0 Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Scomp0(pub u32);
    impl Scomp0 {
        #[doc = "Specifies the number of sample clocks. When VAL = 0 or 1, number of sample clocks = Sample clock divide value. When VAL > 1, number of sample clocks = VAL x Sample clock divide value. Note: Sample clock divide value is not the value written to SCLKDIV but the actual divide value (SCLKDIV = 2 implies divide value is 4). Example: VAL = 4, SCLKDIV = 3 implies 32 sample clock cycles."]
        #[inline(always)]
        pub const fn val(&self) -> u16 {
            let val = (self.0 >> 0usize) & 0x03ff;
            val as u16
        }
        #[doc = "Specifies the number of sample clocks. When VAL = 0 or 1, number of sample clocks = Sample clock divide value. When VAL > 1, number of sample clocks = VAL x Sample clock divide value. Note: Sample clock divide value is not the value written to SCLKDIV but the actual divide value (SCLKDIV = 2 implies divide value is 4). Example: VAL = 4, SCLKDIV = 3 implies 32 sample clock cycles."]
        #[inline(always)]
        pub fn set_val(&mut self, val: u16) {
            self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
        }
    }
    impl Default for Scomp0 {
        #[inline(always)]
        fn default() -> Scomp0 {
            Scomp0(0)
        }
    }
    #[doc = "Sample Time Compare 1 Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Scomp1(pub u32);
    impl Scomp1 {
        #[doc = "Specifies the number of sample clocks. When VAL = 0 or 1, number of sample clocks = Sample clock divide value. When VAL > 1, number of sample clocks = VAL x Sample clock divide value. Note: Sample clock divide value is not the value written to SCLKDIV but the actual divide value (SCLKDIV = 2 implies divide value is 4). Example: VAL = 4, SCLKDIV = 3 implies 32 sample clock cycles."]
        #[inline(always)]
        pub const fn val(&self) -> u16 {
            let val = (self.0 >> 0usize) & 0x03ff;
            val as u16
        }
        #[doc = "Specifies the number of sample clocks. When VAL = 0 or 1, number of sample clocks = Sample clock divide value. When VAL > 1, number of sample clocks = VAL x Sample clock divide value. Note: Sample clock divide value is not the value written to SCLKDIV but the actual divide value (SCLKDIV = 2 implies divide value is 4). Example: VAL = 4, SCLKDIV = 3 implies 32 sample clock cycles."]
        #[inline(always)]
        pub fn set_val(&mut self, val: u16) {
            self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
        }
    }
    impl Default for Scomp1 {
        #[inline(always)]
        fn default() -> Scomp1 {
            Scomp1(0)
        }
    }
    #[doc = "Status Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Stat(pub u32);
    impl Stat {
        #[doc = "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register."]
        #[inline(always)]
        pub const fn resetstky(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register."]
        #[inline(always)]
        pub fn set_resetstky(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
    }
    impl Default for Stat {
        #[inline(always)]
        fn default() -> Stat {
            Stat(0)
        }
    }
    #[doc = "Status Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Status(pub u32);
    impl Status {
        #[doc = "Busy. This bit indicates that an active ADC sample or conversion operation is in progress."]
        #[inline(always)]
        pub const fn busy(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Busy. This bit indicates that an active ADC sample or conversion operation is in progress."]
        #[inline(always)]
        pub fn set_busy(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Indicates reference buffer is powered up and ready."]
        #[inline(always)]
        pub const fn refbufrdy(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Indicates reference buffer is powered up and ready."]
        #[inline(always)]
        pub fn set_refbufrdy(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
    }
    impl Default for Status {
        #[inline(always)]
        fn default() -> Status {
            Status(0)
        }
    }
    #[doc = "Window Comparator High Threshold Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Wchigh(pub u32);
    impl Wchigh {
        #[doc = "If DF = 0, unsigned binary format has to be used. The threshold value has to be right aligned, with the MSB on the left. For 10-bits and 8-bits resolution, unused bit have to be 0s. If DF = 1, 2s-complement format has to be used. The value based on the resolution has to be left aligned with the LSB on the right. For 10-bits and 8-bits resolution, unused bit have to be 0s."]
        #[inline(always)]
        pub const fn data(&self) -> u16 {
            let val = (self.0 >> 0usize) & 0xffff;
            val as u16
        }
        #[doc = "If DF = 0, unsigned binary format has to be used. The threshold value has to be right aligned, with the MSB on the left. For 10-bits and 8-bits resolution, unused bit have to be 0s. If DF = 1, 2s-complement format has to be used. The value based on the resolution has to be left aligned with the LSB on the right. For 10-bits and 8-bits resolution, unused bit have to be 0s."]
        #[inline(always)]
        pub fn set_data(&mut self, val: u16) {
            self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
        }
    }
    impl Default for Wchigh {
        #[inline(always)]
        fn default() -> Wchigh {
            Wchigh(0)
        }
    }
    #[doc = "Window Comparator Low Threshold Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Wclow(pub u32);
    impl Wclow {
        #[doc = "If DF = 0, unsigned binary format has to be used. The value based on the resolution has to be right aligned with the MSB on the left. For 10-bits and 8-bits resolution, unused bits have to be 0s. If DF = 1, 2s-complement format has to be used. The value based on the resolution has to be left aligned with the LSB on the right. For 10-bits and 8-bits resolution, unused bits have to be 0s."]
        #[inline(always)]
        pub const fn data(&self) -> u16 {
            let val = (self.0 >> 0usize) & 0xffff;
            val as u16
        }
        #[doc = "If DF = 0, unsigned binary format has to be used. The value based on the resolution has to be right aligned with the MSB on the left. For 10-bits and 8-bits resolution, unused bits have to be 0s. If DF = 1, 2s-complement format has to be used. The value based on the resolution has to be left aligned with the LSB on the right. For 10-bits and 8-bits resolution, unused bits have to be 0s."]
        #[inline(always)]
        pub fn set_data(&mut self, val: u16) {
            self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
        }
    }
    impl Default for Wclow {
        #[inline(always)]
        fn default() -> Wclow {
            Wclow(0)
        }
    }
}
pub mod vals {
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Avgn {
        #[doc = "Disables averager."]
        DISABLE = 0x0,
        #[doc = "Averages 2 conversions before storing in MEMRESx register."]
        AVG_2 = 0x01,
        #[doc = "Averages 4 conversions before storing in MEMRESx register."]
        AVG_4 = 0x02,
        #[doc = "Averages 8 conversions before storing in MEMRESx register."]
        AVG_8 = 0x03,
        #[doc = "Averages 16 conversions before storing in MEMRESx register."]
        AVG_16 = 0x04,
        #[doc = "Averages 32 conversions before storing in MEMRESx register."]
        AVG_32 = 0x05,
        #[doc = "Averages 64 conversions before storing in MEMRESx register."]
        AVG_64 = 0x06,
        #[doc = "Averages 128 conversions before storing in MEMRESx register."]
        AVG_128 = 0x07,
    }
    impl Avgn {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Avgn {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Avgn {
        #[inline(always)]
        fn from(val: u8) -> Avgn {
            Avgn::from_bits(val)
        }
    }
    impl From<Avgn> for u8 {
        #[inline(always)]
        fn from(val: Avgn) -> u8 {
            Avgn::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct ClkcfgKey(pub u8);
    impl ClkcfgKey {
        pub const KEY: Self = Self(0xa9);
    }
    impl ClkcfgKey {
        pub const fn from_bits(val: u8) -> ClkcfgKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for ClkcfgKey {
        #[inline(always)]
        fn from(val: u8) -> ClkcfgKey {
            ClkcfgKey::from_bits(val)
        }
    }
    impl From<ClkcfgKey> for u8 {
        #[inline(always)]
        fn from(val: ClkcfgKey) -> u8 {
            ClkcfgKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Conseq {
        #[doc = "ADC channel in MEMCTLx pointed by STARTADD will be converted once."]
        SINGLE = 0x0,
        #[doc = "ADC channel sequence pointed by STARTADD and ENDADD will be converted once."]
        SEQUENCE = 0x01,
        #[doc = "ADC channel in MEMCTLx pointed by STARTADD will be converted repeatedly."]
        REPEATSINGLE = 0x02,
        #[doc = "ADC channel sequence pointed by STARTADD and ENDADD will be converted repeatedly."]
        REPEATSEQUENCE = 0x03,
    }
    impl Conseq {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Conseq {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Conseq {
        #[inline(always)]
        fn from(val: u8) -> Conseq {
            Conseq::from_bits(val)
        }
    }
    impl From<Conseq> for u8 {
        #[inline(always)]
        fn from(val: Conseq) -> u8 {
            Conseq::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct CpuIntIidxStat(pub u16);
    impl CpuIntIidxStat {
        #[doc = "No bit is set means there is no pending interrupt request."]
        pub const NO_INTR: Self = Self(0x0);
        #[doc = "MEMRESx overflow interrupt."]
        pub const OVIFG: Self = Self(0x01);
        #[doc = "Sequence Conversion time overflow interrupt."]
        pub const TOVIFG: Self = Self(0x02);
        #[doc = "High threshold compare interrupt."]
        pub const HIGHIFG: Self = Self(0x03);
        #[doc = "Low threshold compare interrupt."]
        pub const LOWIFG: Self = Self(0x04);
        #[doc = "Primary Sequence In range comparator interrupt."]
        pub const INIFG: Self = Self(0x05);
        #[doc = "DMA done interrupt, generated on DMA transfer completion,."]
        pub const DMADONE: Self = Self(0x06);
        #[doc = "MEMRESx underflow interrupt."]
        pub const UVIFG: Self = Self(0x07);
        #[doc = "MEMRES0 data loaded interrupt."]
        pub const MEMRESIFG0: Self = Self(0x09);
        #[doc = "MEMRES1 data loaded interrupt."]
        pub const MEMRESIFG1: Self = Self(0x0a);
        #[doc = "MEMRES2 data loaded interrupt."]
        pub const MEMRESIFG2: Self = Self(0x0b);
        #[doc = "MEMRES3 data loaded interrupt."]
        pub const MEMRESIFG3: Self = Self(0x0c);
        #[doc = "MEMRES4 data loaded interrupt."]
        pub const MEMRESIFG4: Self = Self(0x0d);
        #[doc = "MEMRES5 data loaded interrupt."]
        pub const MEMRESIFG5: Self = Self(0x0e);
        #[doc = "MEMRES6 data loaded interrupt."]
        pub const MEMRESIFG6: Self = Self(0x0f);
        #[doc = "MEMRES7 data loaded interrupt."]
        pub const MEMRESIFG7: Self = Self(0x10);
        #[doc = "MEMRES8 data loaded interrupt."]
        pub const MEMRESIFG8: Self = Self(0x11);
        #[doc = "MEMRES9 data loaded interrupt."]
        pub const MEMRESIFG9: Self = Self(0x12);
        #[doc = "MEMRES10 data loaded interrupt."]
        pub const MEMRESIFG10: Self = Self(0x13);
        #[doc = "MEMRES11 data loaded interrupt."]
        pub const MEMRESIFG11: Self = Self(0x14);
        #[doc = "MEMRES12 data loaded interrupt."]
        pub const MEMRESIFG12: Self = Self(0x15);
        #[doc = "MEMRES13 data loaded interrupt."]
        pub const MEMRESIFG13: Self = Self(0x16);
        #[doc = "MEMRES14 data loaded interrupt."]
        pub const MEMRESIFG14: Self = Self(0x17);
        #[doc = "MEMRES15 data loaded interrupt."]
        pub const MEMRESIFG15: Self = Self(0x18);
        #[doc = "MEMRES16 data loaded interrupt."]
        pub const MEMRESIFG16: Self = Self(0x19);
        #[doc = "MEMRES17 data loaded interrupt."]
        pub const MEMRESIFG17: Self = Self(0x1a);
        #[doc = "MEMRES18 data loaded interrupt."]
        pub const MEMRESIFG18: Self = Self(0x1b);
        #[doc = "MEMRES19 data loaded interrupt."]
        pub const MEMRESIFG19: Self = Self(0x1c);
        #[doc = "MEMRES20 data loaded interrupt."]
        pub const MEMRESIFG20: Self = Self(0x1d);
        #[doc = "MEMRES21 data loaded interrupt."]
        pub const MEMRESIFG21: Self = Self(0x1e);
        #[doc = "MEMRES22 data loaded interrupt."]
        pub const MEMRESIFG22: Self = Self(0x1f);
        #[doc = "MEMRES23 data loaded interrupt."]
        pub const MEMRESIFG23: Self = Self(0x20);
    }
    impl CpuIntIidxStat {
        pub const fn from_bits(val: u16) -> CpuIntIidxStat {
            Self(val & 0x03ff)
        }
        pub const fn to_bits(self) -> u16 {
            self.0
        }
    }
    impl From<u16> for CpuIntIidxStat {
        #[inline(always)]
        fn from(val: u16) -> CpuIntIidxStat {
            CpuIntIidxStat::from_bits(val)
        }
    }
    impl From<CpuIntIidxStat> for u16 {
        #[inline(always)]
        fn from(val: CpuIntIidxStat) -> u16 {
            CpuIntIidxStat::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct DmaTrigIidxStat(pub u16);
    impl DmaTrigIidxStat {
        #[doc = "No bit is set means there is no pending interrupt request."]
        pub const NO_INTR: Self = Self(0x0);
        #[doc = "MEMRES0 data loaded interrupt."]
        pub const MEMRESIFG0: Self = Self(0x09);
        #[doc = "MEMRES1 data loaded interrupt."]
        pub const MEMRESIFG1: Self = Self(0x0a);
        #[doc = "MEMRES2 data loaded interrupt."]
        pub const MEMRESIFG2: Self = Self(0x0b);
        #[doc = "MEMRES3 data loaded interrupt."]
        pub const MEMRESIFG3: Self = Self(0x0c);
        #[doc = "MEMRES4 data loaded interrupt."]
        pub const MEMRESIFG4: Self = Self(0x0d);
        #[doc = "MEMRES5 data loaded interrupt."]
        pub const MEMRESIFG5: Self = Self(0x0e);
        #[doc = "MEMRES6 data loaded interrupt."]
        pub const MEMRESIFG6: Self = Self(0x0f);
        #[doc = "MEMRES7 data loaded interrupt."]
        pub const MEMRESIFG7: Self = Self(0x10);
        #[doc = "MEMRES8 data loaded interrupt."]
        pub const MEMRESIFG8: Self = Self(0x11);
        #[doc = "MEMRES9 data loaded interrupt."]
        pub const MEMRESIFG9: Self = Self(0x12);
        #[doc = "MEMRES10 data loaded interrupt."]
        pub const MEMRESIFG10: Self = Self(0x13);
        #[doc = "MEMRES11 data loaded interrupt."]
        pub const MEMRESIFG11: Self = Self(0x14);
        #[doc = "MEMRES12 data loaded interrupt."]
        pub const MEMRESIFG12: Self = Self(0x15);
        #[doc = "MEMRES13 data loaded interrupt."]
        pub const MEMRESIFG13: Self = Self(0x16);
        #[doc = "MEMRES14 data loaded interrupt."]
        pub const MEMRESIFG14: Self = Self(0x17);
        #[doc = "MEMRES15 data loaded interrupt."]
        pub const MEMRESIFG15: Self = Self(0x18);
        #[doc = "MEMRES16 data loaded interrupt."]
        pub const MEMRESIFG16: Self = Self(0x19);
        #[doc = "MEMRES17 data loaded interrupt."]
        pub const MEMRESIFG17: Self = Self(0x1a);
        #[doc = "MEMRES18 data loaded interrupt."]
        pub const MEMRESIFG18: Self = Self(0x1b);
        #[doc = "MEMRES19 data loaded interrupt."]
        pub const MEMRESIFG19: Self = Self(0x1c);
        #[doc = "MEMRES20 data loaded interrupt."]
        pub const MEMRESIFG20: Self = Self(0x1d);
        #[doc = "MEMRES21 data loaded interrupt."]
        pub const MEMRESIFG21: Self = Self(0x1e);
        #[doc = "MEMRES22 data loaded interrupt."]
        pub const MEMRESIFG22: Self = Self(0x1f);
        #[doc = "MEMRES23 data loaded interrupt."]
        pub const MEMRESIFG23: Self = Self(0x20);
    }
    impl DmaTrigIidxStat {
        pub const fn from_bits(val: u16) -> DmaTrigIidxStat {
            Self(val & 0x03ff)
        }
        pub const fn to_bits(self) -> u16 {
            self.0
        }
    }
    impl From<u16> for DmaTrigIidxStat {
        #[inline(always)]
        fn from(val: u16) -> DmaTrigIidxStat {
            DmaTrigIidxStat::from_bits(val)
        }
    }
    impl From<DmaTrigIidxStat> for u16 {
        #[inline(always)]
        fn from(val: DmaTrigIidxStat) -> u16 {
            DmaTrigIidxStat::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Evt1Cfg {
        #[doc = "The interrupt or event line is disabled."]
        DISABLE = 0x0,
        #[doc = "The interrupt or event line is in software mode. Software must clear the RIS."]
        SOFTWARE = 0x01,
        #[doc = "The interrupt or event line is in hardware mode. The hardware (another module) clears automatically the associated RIS flag."]
        HARDWARE = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl Evt1Cfg {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Evt1Cfg {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Evt1Cfg {
        #[inline(always)]
        fn from(val: u8) -> Evt1Cfg {
            Evt1Cfg::from_bits(val)
        }
    }
    impl From<Evt1Cfg> for u8 {
        #[inline(always)]
        fn from(val: Evt1Cfg) -> u8 {
            Evt1Cfg::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Frange {
        #[doc = "1 to 4 MHz."]
        RANGE1TO4 = 0x0,
        #[doc = ">4 to 8 MHz."]
        RANGE4TO8 = 0x01,
        #[doc = ">8 to 16 MHz."]
        RANGE8TO16 = 0x02,
        #[doc = ">16 to 20 MHz."]
        RANGE16TO20 = 0x03,
        #[doc = ">20 to 24 MHz."]
        RANGE20TO24 = 0x04,
        #[doc = ">24 to 32 MHz."]
        RANGE24TO32 = 0x05,
        #[doc = ">32 to 40 MHz."]
        RANGE32TO40 = 0x06,
        #[doc = ">40 to 48 MHz."]
        RANGE40TO48 = 0x07,
    }
    impl Frange {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Frange {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Frange {
        #[inline(always)]
        fn from(val: u8) -> Frange {
            Frange::from_bits(val)
        }
    }
    impl From<Frange> for u8 {
        #[inline(always)]
        fn from(val: Frange) -> u8 {
            Frange::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct GenEventIidxStat(pub u16);
    impl GenEventIidxStat {
        #[doc = "No bit is set means there is no pending interrupt request."]
        pub const NO_INTR: Self = Self(0x0);
        #[doc = "High threshold compare interrupt."]
        pub const HIGHIFG: Self = Self(0x03);
        #[doc = "Low threshold compare interrupt."]
        pub const LOWIFG: Self = Self(0x04);
        #[doc = "Primary Sequence In range comparator interrupt."]
        pub const INIFG: Self = Self(0x05);
        #[doc = "MEMRES0 data loaded interrupt."]
        pub const MEMRESIFG0: Self = Self(0x09);
    }
    impl GenEventIidxStat {
        pub const fn from_bits(val: u16) -> GenEventIidxStat {
            Self(val & 0x03ff)
        }
        pub const fn to_bits(self) -> u16 {
            self.0
        }
    }
    impl From<u16> for GenEventIidxStat {
        #[inline(always)]
        fn from(val: u16) -> GenEventIidxStat {
            GenEventIidxStat::from_bits(val)
        }
    }
    impl From<GenEventIidxStat> for u16 {
        #[inline(always)]
        fn from(val: GenEventIidxStat) -> u16 {
            GenEventIidxStat::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum IntCfg {
        #[doc = "The interrupt or event line is disabled."]
        DISABLE = 0x0,
        #[doc = "The interrupt or event line is in software mode. Software must clear the RIS."]
        SOFTWARE = 0x01,
        #[doc = "The interrupt or event line is in hardware mode. The hardware (another module) clears automatically the associated RIS flag."]
        HARDWARE = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl IntCfg {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> IntCfg {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for IntCfg {
        #[inline(always)]
        fn from(val: u8) -> IntCfg {
            IntCfg::from_bits(val)
        }
    }
    impl From<IntCfg> for u8 {
        #[inline(always)]
        fn from(val: IntCfg) -> u8 {
            IntCfg::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Pwrdn {
        #[doc = "ADC is powered down on completion of a conversion if there is no pending trigger."]
        AUTO = 0x0,
        #[doc = "ADC remains powered on as long as it is enabled through software."]
        MANUAL = 0x01,
    }
    impl Pwrdn {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Pwrdn {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Pwrdn {
        #[inline(always)]
        fn from(val: u8) -> Pwrdn {
            Pwrdn::from_bits(val)
        }
    }
    impl From<Pwrdn> for u8 {
        #[inline(always)]
        fn from(val: Pwrdn) -> u8 {
            Pwrdn::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct PwrenKey(pub u8);
    impl PwrenKey {
        pub const KEY: Self = Self(0x26);
    }
    impl PwrenKey {
        pub const fn from_bits(val: u8) -> PwrenKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for PwrenKey {
        #[inline(always)]
        fn from(val: u8) -> PwrenKey {
            PwrenKey::from_bits(val)
        }
    }
    impl From<PwrenKey> for u8 {
        #[inline(always)]
        fn from(val: PwrenKey) -> u8 {
            PwrenKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Res {
        #[doc = "12-bits resolution."]
        BIT_12 = 0x0,
        #[doc = "10-bits resolution."]
        BIT_10 = 0x01,
        #[doc = "8-bits resolution."]
        BIT_8 = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl Res {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Res {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Res {
        #[inline(always)]
        fn from(val: u8) -> Res {
            Res::from_bits(val)
        }
    }
    impl From<Res> for u8 {
        #[inline(always)]
        fn from(val: Res) -> u8 {
            Res::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct ResetKey(pub u8);
    impl ResetKey {
        pub const KEY: Self = Self(0xb1);
    }
    impl ResetKey {
        pub const fn from_bits(val: u8) -> ResetKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for ResetKey {
        #[inline(always)]
        fn from(val: u8) -> ResetKey {
            ResetKey::from_bits(val)
        }
    }
    impl From<ResetKey> for u8 {
        #[inline(always)]
        fn from(val: ResetKey) -> u8 {
            ResetKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Sampclk {
        #[doc = "ULPCLK is the source of ADC sample clock."]
        ULPCLK = 0x0,
        #[doc = "SYSOSC is the source of ADC sample clock."]
        SYSOSC = 0x01,
        #[doc = "HFCLK clock is the source of ADC sample clock. Note : HFCLK may not be available on all the devices."]
        HFCLK = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl Sampclk {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Sampclk {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Sampclk {
        #[inline(always)]
        fn from(val: u8) -> Sampclk {
            Sampclk::from_bits(val)
        }
    }
    impl From<Sampclk> for u8 {
        #[inline(always)]
        fn from(val: Sampclk) -> u8 {
            Sampclk::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Sampcnt(pub u8);
    impl Sampcnt {
        #[doc = "Minimum value."]
        pub const MIN: Self = Self(0x0);
        #[doc = "Maximum value."]
        pub const MAX: Self = Self(0x18);
    }
    impl Sampcnt {
        pub const fn from_bits(val: u8) -> Sampcnt {
            Self(val & 0x1f)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for Sampcnt {
        #[inline(always)]
        fn from(val: u8) -> Sampcnt {
            Sampcnt::from_bits(val)
        }
    }
    impl From<Sampcnt> for u8 {
        #[inline(always)]
        fn from(val: Sampcnt) -> u8 {
            Sampcnt::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Sampmode {
        #[doc = "Sample timer high phase is used as sample signal."]
        AUTO = 0x0,
        #[doc = "Software trigger is used as sample signal."]
        MANUAL = 0x01,
    }
    impl Sampmode {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Sampmode {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Sampmode {
        #[inline(always)]
        fn from(val: u8) -> Sampmode {
            Sampmode::from_bits(val)
        }
    }
    impl From<Sampmode> for u8 {
        #[inline(always)]
        fn from(val: Sampmode) -> u8 {
            Sampmode::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Sc {
        #[doc = "When SAMPMODE is set to MANUAL, clearing this bit will end the sample phase and the conversion phase will start. When SAMPMODE is set to AUTO, writing 0 has no effect."]
        STOP = 0x0,
        #[doc = "When SAMPMODE is set to MANUAL, setting this bit will start the sample phase. Sample phase will last as long as this bit is set. When SAMPMODE is set to AUTO, setting this bit will trigger the timer based sample time."]
        START = 0x01,
    }
    impl Sc {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Sc {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Sc {
        #[inline(always)]
        fn from(val: u8) -> Sc {
            Sc::from_bits(val)
        }
    }
    impl From<Sc> for u8 {
        #[inline(always)]
        fn from(val: Sc) -> u8 {
            Sc::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Sclkdiv {
        #[doc = "Do not divide clock source."]
        DIV_BY_1 = 0x0,
        #[doc = "Divide clock source by 2."]
        DIV_BY_2 = 0x01,
        #[doc = "Divide clock source by 4."]
        DIV_BY_4 = 0x02,
        #[doc = "Divide clock source by 8."]
        DIV_BY_8 = 0x03,
        #[doc = "Divide clock source by 16."]
        DIV_BY_16 = 0x04,
        #[doc = "Divide clock source by 24."]
        DIV_BY_24 = 0x05,
        #[doc = "Divide clock source by 32."]
        DIV_BY_32 = 0x06,
        #[doc = "Divide clock source by 48."]
        DIV_BY_48 = 0x07,
    }
    impl Sclkdiv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Sclkdiv {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Sclkdiv {
        #[inline(always)]
        fn from(val: u8) -> Sclkdiv {
            Sclkdiv::from_bits(val)
        }
    }
    impl From<Sclkdiv> for u8 {
        #[inline(always)]
        fn from(val: Sclkdiv) -> u8 {
            Sclkdiv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Stime {
        #[doc = "Select SCOMP0."]
        SEL_SCOMP0 = 0x0,
        #[doc = "Select SCOMP1."]
        SEL_SCOMP1 = 0x01,
    }
    impl Stime {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Stime {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Stime {
        #[inline(always)]
        fn from(val: u8) -> Stime {
            Stime::from_bits(val)
        }
    }
    impl From<Stime> for u8 {
        #[inline(always)]
        fn from(val: Stime) -> u8 {
            Stime::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Trig {
        #[doc = "Next conversion is automatic."]
        AUTO_NEXT = 0x0,
        #[doc = "Next conversion requires a trigger."]
        TRIGGER_NEXT = 0x01,
    }
    impl Trig {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Trig {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Trig {
        #[inline(always)]
        fn from(val: u8) -> Trig {
            Trig::from_bits(val)
        }
    }
    impl From<Trig> for u8 {
        #[inline(always)]
        fn from(val: Trig) -> u8 {
            Trig::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Trigsrc {
        #[doc = "Software trigger."]
        SOFTWARE = 0x0,
        #[doc = "Hardware event trigger."]
        EVENT = 0x01,
    }
    impl Trigsrc {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Trigsrc {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Trigsrc {
        #[inline(always)]
        fn from(val: u8) -> Trigsrc {
            Trigsrc::from_bits(val)
        }
    }
    impl From<Trigsrc> for u8 {
        #[inline(always)]
        fn from(val: Trigsrc) -> u8 {
            Trigsrc::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Vrsel {
        #[doc = "VDDA reference."]
        VDDA_VSSA = 0x0,
        #[doc = "External reference from pin."]
        EXTREF_VREFM = 0x01,
        #[doc = "Internal reference."]
        INTREF_VSSA = 0x02,
        #[doc = "VDDA and VREFM connected to VREF+ and VREF- of ADC."]
        VDDA_VREFM = 0x03,
        #[doc = "INTREF and VREFM connected to VREF+ and VREF- of ADC."]
        INTREF_VREFM = 0x04,
        _RESERVED_5 = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl Vrsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Vrsel {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Vrsel {
        #[inline(always)]
        fn from(val: u8) -> Vrsel {
            Vrsel::from_bits(val)
        }
    }
    impl From<Vrsel> for u8 {
        #[inline(always)]
        fn from(val: Vrsel) -> u8 {
            Vrsel::to_bits(val)
        }
    }
}
