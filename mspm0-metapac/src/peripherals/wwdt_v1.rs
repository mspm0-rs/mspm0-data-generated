// This file is autogenerated by mspm0-metapac-gen: do not edit by hand.
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::identity_op)]
#![allow(clippy::unnecessary_cast)]
#![allow(clippy::erasing_op)]

#[derive(Copy, Clone, Eq, PartialEq)]
pub struct CpuInt {
    ptr: *mut u8,
}
unsafe impl Send for CpuInt {}
unsafe impl Sync for CpuInt {}
impl CpuInt {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Interrupt index."]
    #[inline(always)]
    pub const fn iidx(self) -> crate::common::Reg<regs::Iidx, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "Interrupt mask."]
    #[inline(always)]
    pub const fn imask(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
    }
    #[doc = "Raw interrupt status."]
    #[inline(always)]
    pub const fn ris(self) -> crate::common::Reg<regs::Int, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
    }
    #[doc = "Masked interrupt status."]
    #[inline(always)]
    pub const fn mis(self) -> crate::common::Reg<regs::Int, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
    }
    #[doc = "Interrupt set."]
    #[inline(always)]
    pub const fn iset(self) -> crate::common::Reg<regs::Int, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
    }
    #[doc = "Interrupt clear."]
    #[inline(always)]
    pub const fn iclr(self) -> crate::common::Reg<regs::Int, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
    }
}
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Gprcm {
    ptr: *mut u8,
}
unsafe impl Send for Gprcm {}
unsafe impl Sync for Gprcm {}
impl Gprcm {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Power enable."]
    #[inline(always)]
    pub const fn pwren(self) -> crate::common::Reg<regs::Pwren, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
    }
    #[doc = "Reset Control."]
    #[inline(always)]
    pub const fn rstctl(self) -> crate::common::Reg<regs::Rstctl, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
    }
    #[doc = "Status Register."]
    #[inline(always)]
    pub const fn stat(self) -> crate::common::Reg<regs::Stat, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
    }
}
#[doc = "WWDT."]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Wwdt {
    ptr: *mut u8,
}
unsafe impl Send for Wwdt {}
unsafe impl Sync for Wwdt {}
impl Wwdt {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[inline(always)]
    pub const fn gprcm(self, n: usize) -> Gprcm {
        assert!(n < 1usize);
        unsafe { Gprcm::from_ptr(self.ptr.add(0x0800usize + n * 24usize) as _) }
    }
    #[doc = "Peripheral Debug Control."]
    #[inline(always)]
    pub const fn pdbgctl(self) -> crate::common::Reg<regs::Pdbgctl, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1018usize) as _) }
    }
    #[inline(always)]
    pub const fn cpu_int(self, n: usize) -> CpuInt {
        assert!(n < 1usize);
        unsafe { CpuInt::from_ptr(self.ptr.add(0x1020usize + n * 44usize) as _) }
    }
    #[doc = "Event Mode."]
    #[inline(always)]
    pub const fn evt_mode(self) -> crate::common::Reg<regs::EvtMode, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10e0usize) as _) }
    }
    #[doc = "Module Description."]
    #[inline(always)]
    pub const fn desc(self) -> crate::common::Reg<regs::Desc, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10fcusize) as _) }
    }
    #[doc = "Window Watchdog Timer Control Register 0."]
    #[inline(always)]
    pub const fn wwdtctl0(self) -> crate::common::Reg<regs::Wwdtctl0, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1100usize) as _) }
    }
    #[doc = "Window Watchdog Timer Control Register 0."]
    #[inline(always)]
    pub const fn wwdtctl1(self) -> crate::common::Reg<regs::Wwdtctl1, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1104usize) as _) }
    }
    #[doc = "Window Watchdog Timer Counter Reset Register."]
    #[inline(always)]
    pub const fn wwdtcntrst(self) -> crate::common::Reg<regs::Wwdtcntrst, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1108usize) as _) }
    }
    #[doc = "Window Watchdog Timer Status Register."]
    #[inline(always)]
    pub const fn wwdtstat(self) -> crate::common::Reg<regs::Wwdtstat, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x110cusize) as _) }
    }
}
pub mod regs {
    #[doc = "Module Description."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Desc(pub u32);
    impl Desc {
        #[doc = "Minor rev of the IP."]
        #[inline(always)]
        pub const fn minrev(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x0f;
            val as u8
        }
        #[doc = "Minor rev of the IP."]
        #[inline(always)]
        pub fn set_minrev(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
        }
        #[doc = "Major rev of the IP."]
        #[inline(always)]
        pub const fn majrev(&self) -> u8 {
            let val = (self.0 >> 4usize) & 0x0f;
            val as u8
        }
        #[doc = "Major rev of the IP."]
        #[inline(always)]
        pub fn set_majrev(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
        }
        #[doc = "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances."]
        #[inline(always)]
        pub const fn instnum(&self) -> u8 {
            let val = (self.0 >> 8usize) & 0x0f;
            val as u8
        }
        #[doc = "Instance Number within the device. This will be a parameter to the RTL for modules that can have multiple instances."]
        #[inline(always)]
        pub fn set_instnum(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
        }
        #[doc = "Feature Set for the module *instance*."]
        #[inline(always)]
        pub const fn featurever(&self) -> u8 {
            let val = (self.0 >> 12usize) & 0x0f;
            val as u8
        }
        #[doc = "Feature Set for the module *instance*."]
        #[inline(always)]
        pub fn set_featurever(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
        }
        #[doc = "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness."]
        #[inline(always)]
        pub const fn moduleid(&self) -> u16 {
            let val = (self.0 >> 16usize) & 0xffff;
            val as u16
        }
        #[doc = "Module identification contains a unique peripheral identification number. The assignments are maintained in a central database for all of the platform modules to ensure uniqueness."]
        #[inline(always)]
        pub fn set_moduleid(&mut self, val: u16) {
            self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
        }
    }
    impl Default for Desc {
        #[inline(always)]
        fn default() -> Desc {
            Desc(0)
        }
    }
    #[doc = "Event Mode."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EvtMode(pub u32);
    impl EvtMode {
        #[doc = "Event line mode select for event corresponding to \\[IPSTANDARD.INT_EVENT\\]\\[0\\]."]
        #[inline(always)]
        pub const fn int0_cfg(&self) -> super::vals::IntCfg {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::IntCfg::from_bits(val as u8)
        }
        #[doc = "Event line mode select for event corresponding to \\[IPSTANDARD.INT_EVENT\\]\\[0\\]."]
        #[inline(always)]
        pub fn set_int0_cfg(&mut self, val: super::vals::IntCfg) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
    }
    impl Default for EvtMode {
        #[inline(always)]
        fn default() -> EvtMode {
            EvtMode(0)
        }
    }
    #[doc = "Interrupt index."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iidx(pub u32);
    impl Iidx {
        #[doc = "Module Interrupt Vector Value. This register provides the highest priority interrupt index. A read clears the corresponding interrupt flag in RIS and MISC."]
        #[inline(always)]
        pub const fn stat(&self) -> super::vals::Stat {
            let val = (self.0 >> 0usize) & 0x1f;
            super::vals::Stat::from_bits(val as u8)
        }
        #[doc = "Module Interrupt Vector Value. This register provides the highest priority interrupt index. A read clears the corresponding interrupt flag in RIS and MISC."]
        #[inline(always)]
        pub fn set_stat(&mut self, val: super::vals::Stat) {
            self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u32) & 0x1f) << 0usize);
        }
    }
    impl Default for Iidx {
        #[inline(always)]
        fn default() -> Iidx {
            Iidx(0)
        }
    }
    #[doc = "Interrupt clear."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Int(pub u32);
    impl Int {
        #[doc = "Interval Timer Interrupt."]
        #[inline(always)]
        pub const fn inttim(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Interval Timer Interrupt."]
        #[inline(always)]
        pub fn set_inttim(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Int {
        #[inline(always)]
        fn default() -> Int {
            Int(0)
        }
    }
    #[doc = "Peripheral Debug Control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pdbgctl(pub u32);
    impl Pdbgctl {
        #[doc = "Free run control."]
        #[inline(always)]
        pub const fn free(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Free run control."]
        #[inline(always)]
        pub fn set_free(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Pdbgctl {
        #[inline(always)]
        fn default() -> Pdbgctl {
            Pdbgctl(0)
        }
    }
    #[doc = "Power enable."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pwren(pub u32);
    impl Pwren {
        #[doc = "Enable the power Note: For safety devices the power cannot be disabled once enabled."]
        #[inline(always)]
        pub const fn enable(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Enable the power Note: For safety devices the power cannot be disabled once enabled."]
        #[inline(always)]
        pub fn set_enable(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "KEY to allow Power State Change 26h = KEY to allow write access to this register"]
        #[inline(always)]
        pub const fn key(&self) -> super::vals::PwrenKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::PwrenKey::from_bits(val as u8)
        }
        #[doc = "KEY to allow Power State Change 26h = KEY to allow write access to this register"]
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::PwrenKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Pwren {
        #[inline(always)]
        fn default() -> Pwren {
            Pwren(0)
        }
    }
    #[doc = "Reset Control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rstctl(pub u32);
    impl Rstctl {
        #[doc = "Assert reset to the peripheral Note: For safety devices a watchdog reset by software is not possible."]
        #[inline(always)]
        pub const fn resetassert(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Assert reset to the peripheral Note: For safety devices a watchdog reset by software is not possible."]
        #[inline(always)]
        pub fn set_resetassert(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Clear \\[GPRCM.STAT.RESETSTKY\\]."]
        #[inline(always)]
        pub const fn resetstkyclr(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Clear \\[GPRCM.STAT.RESETSTKY\\]."]
        #[inline(always)]
        pub fn set_resetstkyclr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Unlock key B1h = KEY to allow write access to this register"]
        #[inline(always)]
        pub const fn key(&self) -> super::vals::ResetKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::ResetKey::from_bits(val as u8)
        }
        #[doc = "Unlock key B1h = KEY to allow write access to this register"]
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::ResetKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Rstctl {
        #[inline(always)]
        fn default() -> Rstctl {
            Rstctl(0)
        }
    }
    #[doc = "Status Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Stat(pub u32);
    impl Stat {
        #[doc = "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register."]
        #[inline(always)]
        pub const fn resetstky(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "This bit indicates, if the peripheral was reset, since this bit was cleared by RESETSTKYCLR in the RSTCTL register."]
        #[inline(always)]
        pub fn set_resetstky(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
    }
    impl Default for Stat {
        #[inline(always)]
        fn default() -> Stat {
            Stat(0)
        }
    }
    #[doc = "Window Watchdog Timer Counter Reset Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Wwdtcntrst(pub u32);
    impl Wwdtcntrst {
        #[doc = "Window Watchdog Timer Counter Restart Writing 00A7h to this register restarts the WWDT Counter."]
        #[inline(always)]
        pub const fn restart(&self) -> super::vals::WwdtcntrstRestart {
            let val = (self.0 >> 0usize) & 0xffff_ffff;
            super::vals::WwdtcntrstRestart::from_bits(val as u32)
        }
        #[doc = "Window Watchdog Timer Counter Restart Writing 00A7h to this register restarts the WWDT Counter."]
        #[inline(always)]
        pub fn set_restart(&mut self, val: super::vals::WwdtcntrstRestart) {
            self.0 = (self.0 & !(0xffff_ffff << 0usize))
                | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
        }
    }
    impl Default for Wwdtcntrst {
        #[inline(always)]
        fn default() -> Wwdtcntrst {
            Wwdtcntrst(0)
        }
    }
    #[doc = "Window Watchdog Timer Control Register 0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Wwdtctl0(pub u32);
    impl Wwdtctl0 {
        #[doc = "Module Clock Divider, Divide the clock source by CLKDIV+1. Divider values from /1 to /8 are possible. The clock divider is currently 4 bits. Bit 4 has no effect and should always be written with 0."]
        #[inline(always)]
        pub const fn clkdiv(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x07;
            val as u8
        }
        #[doc = "Module Clock Divider, Divide the clock source by CLKDIV+1. Divider values from /1 to /8 are possible. The clock divider is currently 4 bits. Bit 4 has no effect and should always be written with 0."]
        #[inline(always)]
        pub fn set_clkdiv(&mut self, val: u8) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
        }
        #[doc = "Timer Period of the WWDT. These bits select the total watchdog timer count."]
        #[inline(always)]
        pub const fn per(&self) -> super::vals::Per {
            let val = (self.0 >> 4usize) & 0x07;
            super::vals::Per::from_bits(val as u8)
        }
        #[doc = "Timer Period of the WWDT. These bits select the total watchdog timer count."]
        #[inline(always)]
        pub fn set_per(&mut self, val: super::vals::Per) {
            self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u32) & 0x07) << 4usize);
        }
        #[doc = "Closed window period in percentage of the timer interval. WWDTCTL1.WINSEL determines the active window setting (WWDTCTL0.WINDOW0 or WWDTCTL0.WINDOW1)."]
        #[inline(always)]
        pub const fn window0(&self) -> super::vals::Window {
            let val = (self.0 >> 8usize) & 0x07;
            super::vals::Window::from_bits(val as u8)
        }
        #[doc = "Closed window period in percentage of the timer interval. WWDTCTL1.WINSEL determines the active window setting (WWDTCTL0.WINDOW0 or WWDTCTL0.WINDOW1)."]
        #[inline(always)]
        pub fn set_window0(&mut self, val: super::vals::Window) {
            self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
        }
        #[doc = "Closed window period in percentage of the timer interval. WWDTCTL1.WINSEL determines the active window setting (WWDTCTL0.WINDOW0 or WWDTCTL0.WINDOW1)."]
        #[inline(always)]
        pub const fn window1(&self) -> super::vals::Window {
            let val = (self.0 >> 12usize) & 0x07;
            super::vals::Window::from_bits(val as u8)
        }
        #[doc = "Closed window period in percentage of the timer interval. WWDTCTL1.WINSEL determines the active window setting (WWDTCTL0.WINDOW0 or WWDTCTL0.WINDOW1)."]
        #[inline(always)]
        pub fn set_window1(&mut self, val: super::vals::Window) {
            self.0 = (self.0 & !(0x07 << 12usize)) | (((val.to_bits() as u32) & 0x07) << 12usize);
        }
        #[doc = "Window Watchdog Timer Mode."]
        #[inline(always)]
        pub const fn mode(&self) -> super::vals::Mode {
            let val = (self.0 >> 16usize) & 0x01;
            super::vals::Mode::from_bits(val as u8)
        }
        #[doc = "Window Watchdog Timer Mode."]
        #[inline(always)]
        pub fn set_mode(&mut self, val: super::vals::Mode) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
        }
        #[doc = "Stop In Sleep Mode. The functionality of this bit requires that POLICY.HWCEN = 0. If POLICY.HWCEN = 1 the WWDT resets during sleep and needs re-configuration. Note: This bit has no effect for the global Window Watchdog as Sleep Mode is not supported."]
        #[inline(always)]
        pub const fn stism(&self) -> super::vals::Stism {
            let val = (self.0 >> 17usize) & 0x01;
            super::vals::Stism::from_bits(val as u8)
        }
        #[doc = "Stop In Sleep Mode. The functionality of this bit requires that POLICY.HWCEN = 0. If POLICY.HWCEN = 1 the WWDT resets during sleep and needs re-configuration. Note: This bit has no effect for the global Window Watchdog as Sleep Mode is not supported."]
        #[inline(always)]
        pub fn set_stism(&mut self, val: super::vals::Stism) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
        }
        #[doc = "KEY to allow write access to WWDTCTL0 = C9h."]
        #[inline(always)]
        pub const fn key(&self) -> super::vals::Wwdtctl0Key {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::Wwdtctl0Key::from_bits(val as u8)
        }
        #[doc = "KEY to allow write access to WWDTCTL0 = C9h."]
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::Wwdtctl0Key) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Wwdtctl0 {
        #[inline(always)]
        fn default() -> Wwdtctl0 {
            Wwdtctl0(0)
        }
    }
    #[doc = "Window Watchdog Timer Control Register 0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Wwdtctl1(pub u32);
    impl Wwdtctl1 {
        #[doc = "Close Window Select."]
        #[inline(always)]
        pub const fn winsel(&self) -> super::vals::Winsel {
            let val = (self.0 >> 0usize) & 0x01;
            super::vals::Winsel::from_bits(val as u8)
        }
        #[doc = "Close Window Select."]
        #[inline(always)]
        pub fn set_winsel(&mut self, val: super::vals::Winsel) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
        }
        #[doc = "KEY to allow write access to WWDTCTL1 = BEh."]
        #[inline(always)]
        pub const fn key(&self) -> super::vals::Wwdtctl1Key {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::Wwdtctl1Key::from_bits(val as u8)
        }
        #[doc = "KEY to allow write access to WWDTCTL1 = BEh."]
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::Wwdtctl1Key) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Wwdtctl1 {
        #[inline(always)]
        fn default() -> Wwdtctl1 {
            Wwdtctl1(0)
        }
    }
    #[doc = "Window Watchdog Timer Status Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Wwdtstat(pub u32);
    impl Wwdtstat {
        #[doc = "Watchdog running status flag."]
        #[inline(always)]
        pub const fn run(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Watchdog running status flag."]
        #[inline(always)]
        pub fn set_run(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Wwdtstat {
        #[inline(always)]
        fn default() -> Wwdtstat {
            Wwdtstat(0)
        }
    }
}
pub mod vals {
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum IntCfg {
        #[doc = "The interrupt or event line is disabled."]
        DISABLE = 0x0,
        #[doc = "The interrupt or event line is in software mode. Software must clear the RIS."]
        SOFTWARE = 0x01,
        #[doc = "The interrupt or event line is in hardware mode. The hardware (another module) clears automatically the associated RIS flag."]
        HARDWARE = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl IntCfg {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> IntCfg {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for IntCfg {
        #[inline(always)]
        fn from(val: u8) -> IntCfg {
            IntCfg::from_bits(val)
        }
    }
    impl From<IntCfg> for u8 {
        #[inline(always)]
        fn from(val: IntCfg) -> u8 {
            IntCfg::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Mode {
        #[doc = "Window Watchdog Timer Mode. The WWDT will generate a error signal to the ESM when following conditions occur: - Timer Expiration (Timeout) - Reset WWDT during the active window closed period - Keyword violation."]
        WINDOW = 0x0,
        #[doc = "Interval Timer Mode. The WWDT acts as an interval timer. It generates an interrupt on timeout."]
        INTERVAL = 0x01,
    }
    impl Mode {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Mode {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Mode {
        #[inline(always)]
        fn from(val: u8) -> Mode {
            Mode::from_bits(val)
        }
    }
    impl From<Mode> for u8 {
        #[inline(always)]
        fn from(val: Mode) -> u8 {
            Mode::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Per {
        #[doc = "Total timer count is 2^25."]
        EN_25 = 0x0,
        #[doc = "Total timer count is 2^21."]
        EN_21 = 0x01,
        #[doc = "Total timer count is 2^18."]
        EN_18 = 0x02,
        #[doc = "Total timer count is 2^15."]
        EN_15 = 0x03,
        #[doc = "Total timer count is 2^12 (default)."]
        EN_12 = 0x04,
        #[doc = "Total timer count is 2^10."]
        EN_10 = 0x05,
        #[doc = "Total timer count is 2^8."]
        EN_8 = 0x06,
        #[doc = "Total timer count is 2^6."]
        EN_6 = 0x07,
    }
    impl Per {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Per {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Per {
        #[inline(always)]
        fn from(val: u8) -> Per {
            Per::from_bits(val)
        }
    }
    impl From<Per> for u8 {
        #[inline(always)]
        fn from(val: Per) -> u8 {
            Per::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct PwrenKey(pub u8);
    impl PwrenKey {
        pub const KEY: Self = Self(0x26);
    }
    impl PwrenKey {
        pub const fn from_bits(val: u8) -> PwrenKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for PwrenKey {
        #[inline(always)]
        fn from(val: u8) -> PwrenKey {
            PwrenKey::from_bits(val)
        }
    }
    impl From<PwrenKey> for u8 {
        #[inline(always)]
        fn from(val: PwrenKey) -> u8 {
            PwrenKey::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct ResetKey(pub u8);
    impl ResetKey {
        pub const KEY: Self = Self(0xb1);
    }
    impl ResetKey {
        pub const fn from_bits(val: u8) -> ResetKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for ResetKey {
        #[inline(always)]
        fn from(val: u8) -> ResetKey {
            ResetKey::from_bits(val)
        }
    }
    impl From<ResetKey> for u8 {
        #[inline(always)]
        fn from(val: ResetKey) -> u8 {
            ResetKey::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Stat(pub u8);
    impl Stat {
        #[doc = "No interrupt pending."]
        pub const NO_INTR: Self = Self(0x0);
        #[doc = "Interval Timer Interrupt; Interrupt Flag: INTTIM; Interrupt Priority: Highest."]
        pub const INTTIM: Self = Self(0x01);
    }
    impl Stat {
        pub const fn from_bits(val: u8) -> Stat {
            Self(val & 0x1f)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for Stat {
        #[inline(always)]
        fn from(val: u8) -> Stat {
            Stat::from_bits(val)
        }
    }
    impl From<Stat> for u8 {
        #[inline(always)]
        fn from(val: Stat) -> u8 {
            Stat::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Stism {
        #[doc = "The WWDT continues to function in Sleep mode."]
        CONT = 0x0,
        #[doc = "The WWDT stops in Sleep mode and resumes where it was stopped after wakeup."]
        STOP = 0x01,
    }
    impl Stism {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Stism {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Stism {
        #[inline(always)]
        fn from(val: u8) -> Stism {
            Stism::from_bits(val)
        }
    }
    impl From<Stism> for u8 {
        #[inline(always)]
        fn from(val: Stism) -> u8 {
            Stism::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Window {
        #[doc = "0% (No closed Window)."]
        SIZE_0 = 0x0,
        #[doc = "12.50% of the total timer period is closed window."]
        SIZE_12 = 0x01,
        #[doc = "18.75% of the total timer period is closed window."]
        SIZE_18 = 0x02,
        #[doc = "25% of the total timer period is closed window."]
        SIZE_25 = 0x03,
        #[doc = "50% of the total timer period is closed window."]
        SIZE_50 = 0x04,
        #[doc = "75% of the total timer period is closed window."]
        SIZE_75 = 0x05,
        #[doc = "81.25% of the total timer period is closed window."]
        SIZE_81 = 0x06,
        #[doc = "87.50% of the total timer period is closed window."]
        SIZE_87 = 0x07,
    }
    impl Window {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Window {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Window {
        #[inline(always)]
        fn from(val: u8) -> Window {
            Window::from_bits(val)
        }
    }
    impl From<Window> for u8 {
        #[inline(always)]
        fn from(val: Window) -> u8 {
            Window::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Winsel {
        #[doc = "In window mode field WINDOW0 of WDDTCTL0 defines the closed window size."]
        WIN0 = 0x0,
        #[doc = "In window mode field WINDOW1 of WDDTCTL0 defines the closed window size."]
        WIN1 = 0x01,
    }
    impl Winsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Winsel {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Winsel {
        #[inline(always)]
        fn from(val: u8) -> Winsel {
            Winsel::from_bits(val)
        }
    }
    impl From<Winsel> for u8 {
        #[inline(always)]
        fn from(val: Winsel) -> u8 {
            Winsel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct WwdtcntrstRestart(pub u32);
    impl WwdtcntrstRestart {
        pub const RESTART: Self = Self(0xa7);
    }
    impl WwdtcntrstRestart {
        pub const fn from_bits(val: u32) -> WwdtcntrstRestart {
            Self(val & 0xffff_ffff)
        }
        pub const fn to_bits(self) -> u32 {
            self.0
        }
    }
    impl From<u32> for WwdtcntrstRestart {
        #[inline(always)]
        fn from(val: u32) -> WwdtcntrstRestart {
            WwdtcntrstRestart::from_bits(val)
        }
    }
    impl From<WwdtcntrstRestart> for u32 {
        #[inline(always)]
        fn from(val: WwdtcntrstRestart) -> u32 {
            WwdtcntrstRestart::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Wwdtctl0Key(pub u8);
    impl Wwdtctl0Key {
        pub const KEY: Self = Self(0xc9);
    }
    impl Wwdtctl0Key {
        pub const fn from_bits(val: u8) -> Wwdtctl0Key {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for Wwdtctl0Key {
        #[inline(always)]
        fn from(val: u8) -> Wwdtctl0Key {
            Wwdtctl0Key::from_bits(val)
        }
    }
    impl From<Wwdtctl0Key> for u8 {
        #[inline(always)]
        fn from(val: Wwdtctl0Key) -> u8 {
            Wwdtctl0Key::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Wwdtctl1Key(pub u8);
    impl Wwdtctl1Key {
        pub const KEY: Self = Self(0xbe);
    }
    impl Wwdtctl1Key {
        pub const fn from_bits(val: u8) -> Wwdtctl1Key {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for Wwdtctl1Key {
        #[inline(always)]
        fn from(val: u8) -> Wwdtctl1Key {
            Wwdtctl1Key::from_bits(val)
        }
    }
    impl From<Wwdtctl1Key> for u8 {
        #[inline(always)]
        fn from(val: Wwdtctl1Key) -> u8 {
            Wwdtctl1Key::to_bits(val)
        }
    }
}
