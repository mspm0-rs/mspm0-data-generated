// This file is autogenerated by mspm0-metapac-gen: do not edit by hand.
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::identity_op)]
#![allow(clippy::unnecessary_cast)]
#![allow(clippy::erasing_op)]

#[doc = "SYSCTL."]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Sysctl {
    ptr: *mut u8,
}
unsafe impl Send for Sysctl {}
unsafe impl Sync for Sysctl {}
impl Sysctl {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "Event IIDX."]
    #[inline(always)]
    pub const fn iidx(self) -> crate::common::Reg<regs::Iidx, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1020usize) as _) }
    }
    #[doc = "Event IMASK."]
    #[inline(always)]
    pub const fn imask(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1028usize) as _) }
    }
    #[doc = "Event RIS."]
    #[inline(always)]
    pub const fn ris(self) -> crate::common::Reg<regs::Int, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1030usize) as _) }
    }
    #[doc = "Event MIS."]
    #[inline(always)]
    pub const fn mis(self) -> crate::common::Reg<regs::Int, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1038usize) as _) }
    }
    #[doc = "Event ISET."]
    #[inline(always)]
    pub const fn iset(self) -> crate::common::Reg<regs::Int, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1040usize) as _) }
    }
    #[doc = "Event ICLR."]
    #[inline(always)]
    pub const fn iclr(self) -> crate::common::Reg<regs::Int, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1048usize) as _) }
    }
    #[inline(always)]
    pub const fn nmi_iidx(self) -> crate::common::Reg<regs::NmiIidx, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1050usize) as _) }
    }
    #[inline(always)]
    pub const fn nmi_ris(self) -> crate::common::Reg<regs::Nmi, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1060usize) as _) }
    }
    #[inline(always)]
    pub const fn nmi_iset(self) -> crate::common::Reg<regs::Nmi, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1070usize) as _) }
    }
    #[inline(always)]
    pub const fn nmi_iclr(self) -> crate::common::Reg<regs::Nmi, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1078usize) as _) }
    }
    #[doc = "SYSOSC Configuration."]
    #[inline(always)]
    pub const fn sysosccfg(self) -> crate::common::Reg<regs::Sysosccfg, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1100usize) as _) }
    }
    #[doc = "Configuration related to MCLK."]
    #[inline(always)]
    pub const fn mclkcfg(self) -> crate::common::Reg<regs::Mclkcfg, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1104usize) as _) }
    }
    #[doc = "High Speed Clock Configuration."]
    #[inline(always)]
    pub const fn hsclken(self) -> crate::common::Reg<regs::Hsclken, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1108usize) as _) }
    }
    #[doc = "General Clock Configuration."]
    #[inline(always)]
    pub const fn genclkcfg(self) -> crate::common::Reg<regs::Genclkcfg, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1138usize) as _) }
    }
    #[doc = "General Clock Enables."]
    #[inline(always)]
    pub const fn genclken(self) -> crate::common::Reg<regs::Genclken, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x113cusize) as _) }
    }
    #[doc = "Power Mode Configurations."]
    #[inline(always)]
    pub const fn pmodecfg(self) -> crate::common::Reg<regs::Pmodecfg, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1140usize) as _) }
    }
    #[inline(always)]
    pub const fn fcc(self) -> crate::common::Reg<regs::Fcc, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1150usize) as _) }
    }
    #[inline(always)]
    pub const fn sramboundary(self) -> crate::common::Reg<regs::Sramboundary, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1178usize) as _) }
    }
    #[doc = "SRAM Write Protect."]
    #[inline(always)]
    pub const fn systemcfg(self) -> crate::common::Reg<regs::Systemcfg, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1180usize) as _) }
    }
    #[doc = "SYSOSC Trim Values specified by user."]
    #[inline(always)]
    pub const fn writelock(self) -> crate::common::Reg<regs::Writelock, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1200usize) as _) }
    }
    #[doc = "Useful debug status of clock selections."]
    #[inline(always)]
    pub const fn clkstatus(self) -> crate::common::Reg<regs::Clkstatus, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1204usize) as _) }
    }
    #[doc = "Useful System Status Data."]
    #[inline(always)]
    pub const fn sysstatus(self) -> crate::common::Reg<regs::Sysstatus, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1208usize) as _) }
    }
    #[inline(always)]
    pub const fn rstcause(self) -> crate::common::Reg<regs::Rstcause, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1220usize) as _) }
    }
    #[doc = "Reset Level for Application Reset Command."]
    #[inline(always)]
    pub const fn resetlevel(self) -> crate::common::Reg<regs::Resetlevel, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1300usize) as _) }
    }
    #[doc = "Execute Reset Command."]
    #[inline(always)]
    pub const fn resetcmd(self) -> crate::common::Reg<regs::Resetcmd, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1304usize) as _) }
    }
    #[doc = "BOR Threshold Level."]
    #[inline(always)]
    pub const fn borthreshold(self) -> crate::common::Reg<regs::Borthreshold, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1308usize) as _) }
    }
    #[inline(always)]
    pub const fn borclrcmd(self) -> crate::common::Reg<regs::Borclrcmd, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x130cusize) as _) }
    }
    #[doc = "SYSOSC Frequency Control Loop with External Resistor."]
    #[inline(always)]
    pub const fn sysoscfclctl(self) -> crate::common::Reg<regs::Sysoscfclctl, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1310usize) as _) }
    }
    #[doc = "EX LF Control -- Only BOR Level Reset will clear."]
    #[inline(always)]
    pub const fn exlfctl(self) -> crate::common::Reg<regs::Exlfctl, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1318usize) as _) }
    }
    #[doc = "Shutdown IO Release Command."]
    #[inline(always)]
    pub const fn shdniorel(self) -> crate::common::Reg<regs::Shdniorel, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x131cusize) as _) }
    }
    #[doc = "Disable use of external Reset Pin."]
    #[inline(always)]
    pub const fn exrstpin(self) -> crate::common::Reg<regs::Exrstpin, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1320usize) as _) }
    }
    #[doc = "Clear sticky bits of SYSSTATUS."]
    #[inline(always)]
    pub const fn sysstatusclr(self) -> crate::common::Reg<regs::Sysstatusclr, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1324usize) as _) }
    }
    #[doc = "Disable SWD."]
    #[inline(always)]
    pub const fn swdcfg(self) -> crate::common::Reg<regs::Swdcfg, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1328usize) as _) }
    }
    #[inline(always)]
    pub const fn fcccmd(self) -> crate::common::Reg<regs::Fcccmd, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x132cusize) as _) }
    }
    #[doc = "Shutdown Storage Byte 0."]
    #[inline(always)]
    pub const fn shutdnstore(
        self,
        n: usize,
    ) -> crate::common::Reg<regs::Shutdnstore, crate::common::RW> {
        assert!(n < 4usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1400usize + n * 4usize) as _) }
    }
}
pub mod regs {
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Borclrcmd(pub u32);
    impl Borclrcmd {
        #[inline(always)]
        pub const fn go(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[inline(always)]
        pub fn set_go(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::BorclrcmdKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::BorclrcmdKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::BorclrcmdKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Borclrcmd {
        #[inline(always)]
        fn default() -> Borclrcmd {
            Borclrcmd(0)
        }
    }
    #[doc = "BOR Threshold Level."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Borthreshold(pub u32);
    impl Borthreshold {
        #[doc = "BOR Threshold Level 0: Full Re-boot This level is always enforced regardless of MMR seting 1-3: Generates interrupt."]
        #[inline(always)]
        pub const fn level(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x03;
            val as u8
        }
        #[doc = "BOR Threshold Level 0: Full Re-boot This level is always enforced regardless of MMR seting 1-3: Generates interrupt."]
        #[inline(always)]
        pub fn set_level(&mut self, val: u8) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
        }
    }
    impl Default for Borthreshold {
        #[inline(always)]
        fn default() -> Borthreshold {
            Borthreshold(0)
        }
    }
    #[doc = "Useful debug status of clock selections."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Clkstatus(pub u32);
    impl Clkstatus {
        #[doc = "Current SYSOSC frequency setting."]
        #[inline(always)]
        pub const fn sysoscfreq(&self) -> super::vals::Sysoscfreq {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::Sysoscfreq::from_bits(val as u8)
        }
        #[doc = "Current SYSOSC frequency setting."]
        #[inline(always)]
        pub fn set_sysoscfreq(&mut self, val: super::vals::Sysoscfreq) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
        #[doc = "High Speed Clock Selected for MCLK (HFCLK, PLL,...)."]
        #[inline(always)]
        pub const fn hsclkmux(&self) -> super::vals::Hsclkmux {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Hsclkmux::from_bits(val as u8)
        }
        #[doc = "High Speed Clock Selected for MCLK (HFCLK, PLL,...)."]
        #[inline(always)]
        pub fn set_hsclkmux(&mut self, val: super::vals::Hsclkmux) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
        #[doc = "Low Frequency Clock Selected."]
        #[inline(always)]
        pub const fn lfclkmux(&self) -> super::vals::Lfclkmux {
            let val = (self.0 >> 6usize) & 0x03;
            super::vals::Lfclkmux::from_bits(val as u8)
        }
        #[doc = "Low Frequency Clock Selected."]
        #[inline(always)]
        pub fn set_lfclkmux(&mut self, val: super::vals::Lfclkmux) {
            self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u32) & 0x03) << 6usize);
        }
        #[doc = "LFOSC is Valid."]
        #[inline(always)]
        pub const fn lfoscgood(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "LFOSC is Valid."]
        #[inline(always)]
        pub fn set_lfoscgood(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "All PLLs, HFCLKs are OFF or DEAD."]
        #[inline(always)]
        pub const fn hsclksoff(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "All PLLs, HFCLKs are OFF or DEAD."]
        #[inline(always)]
        pub fn set_hsclksoff(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "HFCLKs is OFF or DEAD."]
        #[inline(always)]
        pub const fn hfclkoff(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "HFCLKs is OFF or DEAD."]
        #[inline(always)]
        pub fn set_hfclkoff(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "MCLK Clock Source 0: NOT LFCLK, 1:LFCLK."]
        #[inline(always)]
        pub const fn curmclksel(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "MCLK Clock Source 0: NOT LFCLK, 1:LFCLK."]
        #[inline(always)]
        pub fn set_curmclksel(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "SYSOSC FCL MODE ON."]
        #[inline(always)]
        pub const fn fclmode(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "SYSOSC FCL MODE ON."]
        #[inline(always)]
        pub fn set_fclmode(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
        #[inline(always)]
        pub const fn fccdone(&self) -> bool {
            let val = (self.0 >> 25usize) & 0x01;
            val != 0
        }
        #[inline(always)]
        pub fn set_fccdone(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
        }
        #[doc = "Error with Anacomp High Speed CP Clock Generation - SYSOSC must not run at 4MHz."]
        #[inline(always)]
        pub const fn anaclkerr(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "Error with Anacomp High Speed CP Clock Generation - SYSOSC must not run at 4MHz."]
        #[inline(always)]
        pub fn set_anaclkerr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Clkstatus {
        #[inline(always)]
        fn default() -> Clkstatus {
            Clkstatus(0)
        }
    }
    #[doc = "EX LF Control -- Only BOR Level Reset will clear."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Exlfctl(pub u32);
    impl Exlfctl {
        #[doc = "Use external LF CLK IN."]
        #[inline(always)]
        pub const fn setuseexlf(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Use external LF CLK IN."]
        #[inline(always)]
        pub fn set_setuseexlf(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::ExlfctlKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::ExlfctlKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::ExlfctlKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Exlfctl {
        #[inline(always)]
        fn default() -> Exlfctl {
            Exlfctl(0)
        }
    }
    #[doc = "Disable use of external Reset Pin."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Exrstpin(pub u32);
    impl Exrstpin {
        #[doc = "Disable External Reset."]
        #[inline(always)]
        pub const fn disable(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Disable External Reset."]
        #[inline(always)]
        pub fn set_disable(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::ExrstpinKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::ExrstpinKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::ExrstpinKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Exrstpin {
        #[inline(always)]
        fn default() -> Exrstpin {
            Exrstpin(0)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Fcc(pub u32);
    impl Fcc {
        #[inline(always)]
        pub const fn data(&self) -> u32 {
            let val = (self.0 >> 0usize) & 0x003f_ffff;
            val as u32
        }
        #[inline(always)]
        pub fn set_data(&mut self, val: u32) {
            self.0 = (self.0 & !(0x003f_ffff << 0usize)) | (((val as u32) & 0x003f_ffff) << 0usize);
        }
    }
    impl Default for Fcc {
        #[inline(always)]
        fn default() -> Fcc {
            Fcc(0)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Fcccmd(pub u32);
    impl Fcccmd {
        #[inline(always)]
        pub const fn go(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[inline(always)]
        pub fn set_go(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::FcccmdKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::FcccmdKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::FcccmdKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Fcccmd {
        #[inline(always)]
        fn default() -> Fcccmd {
            Fcccmd(0)
        }
    }
    #[doc = "General Clock Configuration."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Genclkcfg(pub u32);
    impl Genclkcfg {
        #[doc = "External Clock Source Select."]
        #[inline(always)]
        pub const fn exclksrc(&self) -> super::vals::Exclksrc {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::Exclksrc::from_bits(val as u8)
        }
        #[doc = "External Clock Source Select."]
        #[inline(always)]
        pub fn set_exclksrc(&mut self, val: super::vals::Exclksrc) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
        #[inline(always)]
        pub const fn exclkdivval(&self) -> super::vals::Exclkdivval {
            let val = (self.0 >> 4usize) & 0x07;
            super::vals::Exclkdivval::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_exclkdivval(&mut self, val: super::vals::Exclkdivval) {
            self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u32) & 0x07) << 4usize);
        }
        #[doc = "1: Enable divide 0: Pass Src Clock Through."]
        #[inline(always)]
        pub const fn exclkdiven(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "1: Enable divide 0: Pass Src Clock Through."]
        #[inline(always)]
        pub fn set_exclkdiven(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "Source for MFPCLK Clock."]
        #[inline(always)]
        pub const fn mfpclksrc(&self) -> super::vals::Mfpclksrc {
            let val = (self.0 >> 9usize) & 0x01;
            super::vals::Mfpclksrc::from_bits(val as u8)
        }
        #[doc = "Source for MFPCLK Clock."]
        #[inline(always)]
        pub fn set_mfpclksrc(&mut self, val: super::vals::Mfpclksrc) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
        }
        #[doc = "HFCLK Divider 1..16."]
        #[inline(always)]
        pub const fn hfclk4mfpclkdiv(&self) -> u8 {
            let val = (self.0 >> 12usize) & 0x0f;
            val as u8
        }
        #[doc = "HFCLK Divider 1..16."]
        #[inline(always)]
        pub fn set_hfclk4mfpclkdiv(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
        }
        #[inline(always)]
        pub const fn fccselclk(&self) -> super::vals::Fccselclk {
            let val = (self.0 >> 16usize) & 0x0f;
            super::vals::Fccselclk::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_fccselclk(&mut self, val: super::vals::Fccselclk) {
            self.0 = (self.0 & !(0x0f << 16usize)) | (((val.to_bits() as u32) & 0x0f) << 16usize);
        }
        #[inline(always)]
        pub const fn fcctrigsrc(&self) -> super::vals::Fcctrigsrc {
            let val = (self.0 >> 20usize) & 0x01;
            super::vals::Fcctrigsrc::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_fcctrigsrc(&mut self, val: super::vals::Fcctrigsrc) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
        }
        #[inline(always)]
        pub const fn fcclvltrig(&self) -> super::vals::Fcclvltrig {
            let val = (self.0 >> 21usize) & 0x01;
            super::vals::Fcclvltrig::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_fcclvltrig(&mut self, val: super::vals::Fcclvltrig) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
        }
        #[inline(always)]
        pub const fn anacpumpcfg(&self) -> super::vals::Anacpumpcfg {
            let val = (self.0 >> 22usize) & 0x03;
            super::vals::Anacpumpcfg::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_anacpumpcfg(&mut self, val: super::vals::Anacpumpcfg) {
            self.0 = (self.0 & !(0x03 << 22usize)) | (((val.to_bits() as u32) & 0x03) << 22usize);
        }
        #[inline(always)]
        pub const fn fcctrigcnt(&self) -> u8 {
            let val = (self.0 >> 24usize) & 0x1f;
            val as u8
        }
        #[inline(always)]
        pub fn set_fcctrigcnt(&mut self, val: u8) {
            self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
        }
    }
    impl Default for Genclkcfg {
        #[inline(always)]
        fn default() -> Genclkcfg {
            Genclkcfg(0)
        }
    }
    #[doc = "General Clock Enables."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Genclken(pub u32);
    impl Genclken {
        #[doc = "Enable the External Clock Output."]
        #[inline(always)]
        pub const fn exclken(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Enable the External Clock Output."]
        #[inline(always)]
        pub fn set_exclken(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Enable the MFCLK."]
        #[inline(always)]
        pub const fn mfpclken(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "Enable the MFCLK."]
        #[inline(always)]
        pub fn set_mfpclken(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
    }
    impl Default for Genclken {
        #[inline(always)]
        fn default() -> Genclken {
            Genclken(0)
        }
    }
    #[doc = "High Speed Clock Configuration."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Hsclken(pub u32);
    impl Hsclken {
        #[doc = "Use External Pin as High Frequency Oscillator Source(HFCLK)."]
        #[inline(always)]
        pub const fn useexthfclk(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "Use External Pin as High Frequency Oscillator Source(HFCLK)."]
        #[inline(always)]
        pub fn set_useexthfclk(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
    }
    impl Default for Hsclken {
        #[inline(always)]
        fn default() -> Hsclken {
            Hsclken(0)
        }
    }
    #[doc = "Event IIDX."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iidx(pub u32);
    impl Iidx {
        #[doc = "Interrupt Index Register -- Read Only."]
        #[inline(always)]
        pub const fn stat(&self) -> super::vals::Stat {
            let val = (self.0 >> 0usize) & 0x0f;
            super::vals::Stat::from_bits(val as u8)
        }
        #[doc = "Interrupt Index Register -- Read Only."]
        #[inline(always)]
        pub fn set_stat(&mut self, val: super::vals::Stat) {
            self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
        }
    }
    impl Default for Iidx {
        #[inline(always)]
        fn default() -> Iidx {
            Iidx(0)
        }
    }
    #[doc = "Event ICLR."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Int(pub u32);
    impl Int {
        #[doc = "LFOSC GOOD."]
        #[inline(always)]
        pub const fn lfoscgood(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "LFOSC GOOD."]
        #[inline(always)]
        pub fn set_lfoscgood(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn anaclkerr(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[inline(always)]
        pub fn set_anaclkerr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
    }
    impl Default for Int {
        #[inline(always)]
        fn default() -> Int {
            Int(0)
        }
    }
    #[doc = "Configuration related to MCLK."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Mclkcfg(pub u32);
    impl Mclkcfg {
        #[doc = "MDIV Divider 1..16 when RUN-SLEEP."]
        #[inline(always)]
        pub const fn mdiv(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x0f;
            val as u8
        }
        #[doc = "MDIV Divider 1..16 when RUN-SLEEP."]
        #[inline(always)]
        pub fn set_mdiv(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
        }
        #[doc = "USE the MFTICK feature (this will limit MDIV options)."]
        #[inline(always)]
        pub const fn usemftick(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "USE the MFTICK feature (this will limit MDIV options)."]
        #[inline(always)]
        pub fn set_usemftick(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "High Speed Clock Selected for MCLK (HFCLK, PLL,...)."]
        #[inline(always)]
        pub const fn usehsclk(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "High Speed Clock Selected for MCLK (HFCLK, PLL,...)."]
        #[inline(always)]
        pub fn set_usehsclk(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "Low Frequency Clock Selected for MCLK."]
        #[inline(always)]
        pub const fn uselfclk(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "Low Frequency Clock Selected for MCLK."]
        #[inline(always)]
        pub fn set_uselfclk(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "STOP ULPCLK Root during STANDBY, Only wake on ASYNC IO Events."]
        #[inline(always)]
        pub const fn stopclkstby(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "STOP ULPCLK Root during STANDBY, Only wake on ASYNC IO Events."]
        #[inline(always)]
        pub fn set_stopclkstby(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
        #[inline(always)]
        pub const fn mclkdeadchk(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[inline(always)]
        pub fn set_mclkdeadchk(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
    }
    impl Default for Mclkcfg {
        #[inline(always)]
        fn default() -> Mclkcfg {
            Mclkcfg(0)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Nmi(pub u32);
    impl Nmi {
        #[inline(always)]
        pub const fn borlvl(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[inline(always)]
        pub fn set_borlvl(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn wwdt0(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[inline(always)]
        pub fn set_wwdt0(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
    }
    impl Default for Nmi {
        #[inline(always)]
        fn default() -> Nmi {
            Nmi(0)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct NmiIidx(pub u32);
    impl NmiIidx {
        #[inline(always)]
        pub const fn stat(&self) -> super::vals::NmiStat {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::NmiStat::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_stat(&mut self, val: super::vals::NmiStat) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
    }
    impl Default for NmiIidx {
        #[inline(always)]
        fn default() -> NmiIidx {
            NmiIidx(0)
        }
    }
    #[doc = "Power Mode Configurations."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pmodecfg(pub u32);
    impl Pmodecfg {
        #[doc = "Action to be taken on DEEPSLEEP 0: STOP, 1:STANDBY, 2: SHUTDOWN 3: Reserved."]
        #[inline(always)]
        pub const fn dsleep(&self) -> super::vals::Dsleep {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::Dsleep::from_bits(val as u8)
        }
        #[doc = "Action to be taken on DEEPSLEEP 0: STOP, 1:STANDBY, 2: SHUTDOWN 3: Reserved."]
        #[inline(always)]
        pub fn set_dsleep(&mut self, val: super::vals::Dsleep) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
    }
    impl Default for Pmodecfg {
        #[inline(always)]
        fn default() -> Pmodecfg {
            Pmodecfg(0)
        }
    }
    #[doc = "Execute Reset Command."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Resetcmd(pub u32);
    impl Resetcmd {
        #[doc = "Execute Reset defined in RESETLEVEL."]
        #[inline(always)]
        pub const fn go(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Execute Reset defined in RESETLEVEL."]
        #[inline(always)]
        pub fn set_go(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::ResetcmdKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::ResetcmdKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::ResetcmdKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Resetcmd {
        #[inline(always)]
        fn default() -> Resetcmd {
            Resetcmd(0)
        }
    }
    #[doc = "Reset Level for Application Reset Command."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Resetlevel(pub u32);
    impl Resetlevel {
        #[doc = "Reset Level 0: CPU plus peripherals, 1: BOR level reset to BOOTCODE, 2: Do CPU plus Peripheral reset then BOOTLOADER, 3: Full Power On Reset -- vcore disabled."]
        #[inline(always)]
        pub const fn level(&self) -> super::vals::ResetlevelLevel {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::ResetlevelLevel::from_bits(val as u8)
        }
        #[doc = "Reset Level 0: CPU plus peripherals, 1: BOR level reset to BOOTCODE, 2: Do CPU plus Peripheral reset then BOOTLOADER, 3: Full Power On Reset -- vcore disabled."]
        #[inline(always)]
        pub fn set_level(&mut self, val: super::vals::ResetlevelLevel) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
    }
    impl Default for Resetlevel {
        #[inline(always)]
        fn default() -> Resetlevel {
            Resetlevel(0)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rstcause(pub u32);
    impl Rstcause {
        #[inline(always)]
        pub const fn id(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x1f;
            val as u8
        }
        #[inline(always)]
        pub fn set_id(&mut self, val: u8) {
            self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
        }
    }
    impl Default for Rstcause {
        #[inline(always)]
        fn default() -> Rstcause {
            Rstcause(0)
        }
    }
    #[doc = "Shutdown IO Release Command."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Shdniorel(pub u32);
    impl Shdniorel {
        #[doc = "Release IO after Shutdown."]
        #[inline(always)]
        pub const fn release(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Release IO after Shutdown."]
        #[inline(always)]
        pub fn set_release(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::ShdniorelKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::ShdniorelKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::ShdniorelKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Shdniorel {
        #[inline(always)]
        fn default() -> Shdniorel {
            Shdniorel(0)
        }
    }
    #[doc = "Shutdown Storage Byte 0."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Shutdnstore(pub u32);
    impl Shutdnstore {
        #[doc = "Shutdown Storage Byte 0."]
        #[inline(always)]
        pub const fn data(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0xff;
            val as u8
        }
        #[doc = "Shutdown Storage Byte 0."]
        #[inline(always)]
        pub fn set_data(&mut self, val: u8) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
        }
    }
    impl Default for Shutdnstore {
        #[inline(always)]
        fn default() -> Shutdnstore {
            Shutdnstore(0)
        }
    }
    #[doc = "SRAM Write Boundary"]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sramboundary(pub u32);
    impl Sramboundary {
        #[inline(always)]
        pub const fn addr(&self) -> u16 {
            let val = (self.0 >> 5usize) & 0x7fff;
            val as u16
        }
        #[inline(always)]
        pub fn set_addr(&mut self, val: u16) {
            self.0 = (self.0 & !(0x7fff << 5usize)) | (((val as u32) & 0x7fff) << 5usize);
        }
    }
    impl Default for Sramboundary {
        #[inline(always)]
        fn default() -> Sramboundary {
            Sramboundary(0)
        }
    }
    #[doc = "Disable SWD."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Swdcfg(pub u32);
    impl Swdcfg {
        #[inline(always)]
        pub const fn disable(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[inline(always)]
        pub fn set_disable(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::SwdcfgKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::SwdcfgKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::SwdcfgKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Swdcfg {
        #[inline(always)]
        fn default() -> Swdcfg {
            Swdcfg(0)
        }
    }
    #[doc = "SYSOSC Configuration."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sysosccfg(pub u32);
    impl Sysosccfg {
        #[doc = "Freq Target: 0: BASE 1: 4M 2: USER 3: Reserved for Turbo 48MHz."]
        #[inline(always)]
        pub const fn freq(&self) -> super::vals::SysosccfgFreq {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::SysosccfgFreq::from_bits(val as u8)
        }
        #[doc = "Freq Target: 0: BASE 1: 4M 2: USER 3: Reserved for Turbo 48MHz."]
        #[inline(always)]
        pub fn set_freq(&mut self, val: super::vals::SysosccfgFreq) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
        #[doc = "Disable SYSOSC when in STOP mode to allow STOP with LFCLK."]
        #[inline(always)]
        pub const fn disablestop(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "Disable SYSOSC when in STOP mode to allow STOP with LFCLK."]
        #[inline(always)]
        pub fn set_disablestop(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "Disable SYSOSC to run all power modes with LFCLK."]
        #[inline(always)]
        pub const fn disable(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "Disable SYSOSC to run all power modes with LFCLK."]
        #[inline(always)]
        pub fn set_disable(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "Block all async requests from enabling SYSOSC via hardware, ie keep running from LFCLK."]
        #[inline(always)]
        pub const fn blockasyncall(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "Block all async requests from enabling SYSOSC via hardware, ie keep running from LFCLK."]
        #[inline(always)]
        pub fn set_blockasyncall(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "Block all UART async requests from enabling SYSOSC via hardware, ie keep running from LFCLK if UART is requester."]
        #[inline(always)]
        pub const fn fastcpuevent(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "Block all UART async requests from enabling SYSOSC via hardware, ie keep running from LFCLK if UART is requester."]
        #[inline(always)]
        pub fn set_fastcpuevent(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
    }
    impl Default for Sysosccfg {
        #[inline(always)]
        fn default() -> Sysosccfg {
            Sysosccfg(0)
        }
    }
    #[doc = "SYSOSC Frequency Control Loop with External Resistor."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sysoscfclctl(pub u32);
    impl Sysoscfclctl {
        #[doc = "Use Freq Control Loop."]
        #[inline(always)]
        pub const fn setusefcl(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Use Freq Control Loop."]
        #[inline(always)]
        pub fn set_setusefcl(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::SysoscfclctlKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::SysoscfclctlKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::SysoscfclctlKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Sysoscfclctl {
        #[inline(always)]
        fn default() -> Sysoscfclctl {
            Sysoscfclctl(0)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sysstatus(pub u32);
    impl Sysstatus {
        #[inline(always)]
        pub const fn borcurthreshold(&self) -> u8 {
            let val = (self.0 >> 2usize) & 0x03;
            val as u8
        }
        #[inline(always)]
        pub fn set_borcurthreshold(&mut self, val: u8) {
            self.0 = (self.0 & !(0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize);
        }
        #[inline(always)]
        pub const fn borlvl(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[inline(always)]
        pub fn set_borlvl(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[inline(always)]
        pub const fn anacpumpgood(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[inline(always)]
        pub fn set_anacpumpgood(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[inline(always)]
        pub const fn pmuirefgood(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[inline(always)]
        pub fn set_pmuirefgood(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[inline(always)]
        pub const fn extrstpindis(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[inline(always)]
        pub fn set_extrstpindis(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[inline(always)]
        pub const fn swdcfgdis(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[inline(always)]
        pub fn set_swdcfgdis(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[inline(always)]
        pub const fn shdniolock(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[inline(always)]
        pub fn set_shdniolock(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[inline(always)]
        pub const fn rebootattempts(&self) -> u8 {
            let val = (self.0 >> 30usize) & 0x03;
            val as u8
        }
        #[inline(always)]
        pub fn set_rebootattempts(&mut self, val: u8) {
            self.0 = (self.0 & !(0x03 << 30usize)) | (((val as u32) & 0x03) << 30usize);
        }
    }
    impl Default for Sysstatus {
        #[inline(always)]
        fn default() -> Sysstatus {
            Sysstatus(0)
        }
    }
    #[doc = "Clear sticky bits of SYSSTATUS."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sysstatusclr(pub u32);
    impl Sysstatusclr {
        #[doc = "Clear ALL ECC related SYSSTATUS indicators."]
        #[inline(always)]
        pub const fn allecc(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Clear ALL ECC related SYSSTATUS indicators."]
        #[inline(always)]
        pub fn set_allecc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::SysstatusclrKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::SysstatusclrKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::SysstatusclrKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Sysstatusclr {
        #[inline(always)]
        fn default() -> Sysstatusclr {
            Sysstatusclr(0)
        }
    }
    #[doc = "System configuration"]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Systemcfg(pub u32);
    impl Systemcfg {
        #[inline(always)]
        pub const fn wwdtlp0rstdis(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[inline(always)]
        pub fn set_wwdtlp0rstdis(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::SystemcfgKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::SystemcfgKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::SystemcfgKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Systemcfg {
        #[inline(always)]
        fn default() -> Systemcfg {
            Systemcfg(0)
        }
    }
    #[doc = "SYSOSC Trim Values specified by user."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Writelock(pub u32);
    impl Writelock {
        #[doc = "LOCK configuration MMRs from write."]
        #[inline(always)]
        pub const fn active(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "LOCK configuration MMRs from write."]
        #[inline(always)]
        pub fn set_active(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Writelock {
        #[inline(always)]
        fn default() -> Writelock {
            Writelock(0)
        }
    }
}
pub mod vals {
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Anacpumpcfg {
        #[doc = "VBOOST is enabled on request from a COMP, GPAMP, or OPA."]
        ONDEMAND = 0x0,
        #[doc = "VBOOST is enabled when the device is in RUN or SLEEP mode, or when a COMP/GPAMP/OPA is enabled."]
        ONACTIVE = 0x01,
        #[doc = "VBOOST is always enabled."]
        ONALWAYS = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl Anacpumpcfg {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Anacpumpcfg {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Anacpumpcfg {
        #[inline(always)]
        fn from(val: u8) -> Anacpumpcfg {
            Anacpumpcfg::from_bits(val)
        }
    }
    impl From<Anacpumpcfg> for u8 {
        #[inline(always)]
        fn from(val: Anacpumpcfg) -> u8 {
            Anacpumpcfg::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct BorclrcmdKey(pub u8);
    impl BorclrcmdKey {
        pub const KEY: Self = Self(0xc7);
    }
    impl BorclrcmdKey {
        pub const fn from_bits(val: u8) -> BorclrcmdKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for BorclrcmdKey {
        #[inline(always)]
        fn from(val: u8) -> BorclrcmdKey {
            BorclrcmdKey::from_bits(val)
        }
    }
    impl From<BorclrcmdKey> for u8 {
        #[inline(always)]
        fn from(val: BorclrcmdKey) -> u8 {
            BorclrcmdKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Dsleep {
        STOP = 0x0,
        STANDBY = 0x01,
        SHUTDOWN = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl Dsleep {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Dsleep {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Dsleep {
        #[inline(always)]
        fn from(val: u8) -> Dsleep {
            Dsleep::from_bits(val)
        }
    }
    impl From<Dsleep> for u8 {
        #[inline(always)]
        fn from(val: Dsleep) -> u8 {
            Dsleep::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Exclkdivval {
        DIV2 = 0x0,
        DIV4 = 0x01,
        DIV6 = 0x02,
        DIV8 = 0x03,
        DIV10 = 0x04,
        DIV12 = 0x05,
        DIV14 = 0x06,
        DIV16 = 0x07,
    }
    impl Exclkdivval {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Exclkdivval {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Exclkdivval {
        #[inline(always)]
        fn from(val: u8) -> Exclkdivval {
            Exclkdivval::from_bits(val)
        }
    }
    impl From<Exclkdivval> for u8 {
        #[inline(always)]
        fn from(val: Exclkdivval) -> u8 {
            Exclkdivval::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Exclksrc {
        SYSOSC = 0x0,
        #[doc = "NOTE: This must be divided in post divider."]
        ULPCLK = 0x01,
        LFCLK = 0x02,
        #[doc = "NOTE: This must be divided in post divider."]
        MFCLK = 0x03,
        HFCLK = 0x04,
        #[doc = "NOTE: Must be 48MHz or below."]
        SYSPLLOUT1 = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl Exclksrc {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Exclksrc {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Exclksrc {
        #[inline(always)]
        fn from(val: u8) -> Exclksrc {
            Exclksrc::from_bits(val)
        }
    }
    impl From<Exclksrc> for u8 {
        #[inline(always)]
        fn from(val: Exclksrc) -> u8 {
            Exclksrc::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct ExlfctlKey(pub u8);
    impl ExlfctlKey {
        pub const KEY: Self = Self(0x36);
    }
    impl ExlfctlKey {
        pub const fn from_bits(val: u8) -> ExlfctlKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for ExlfctlKey {
        #[inline(always)]
        fn from(val: u8) -> ExlfctlKey {
            ExlfctlKey::from_bits(val)
        }
    }
    impl From<ExlfctlKey> for u8 {
        #[inline(always)]
        fn from(val: ExlfctlKey) -> u8 {
            ExlfctlKey::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct ExrstpinKey(pub u8);
    impl ExrstpinKey {
        pub const KEY: Self = Self(0x1e);
    }
    impl ExrstpinKey {
        pub const fn from_bits(val: u8) -> ExrstpinKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for ExrstpinKey {
        #[inline(always)]
        fn from(val: u8) -> ExrstpinKey {
            ExrstpinKey::from_bits(val)
        }
    }
    impl From<ExrstpinKey> for u8 {
        #[inline(always)]
        fn from(val: ExrstpinKey) -> u8 {
            ExrstpinKey::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct FcccmdKey(pub u8);
    impl FcccmdKey {
        pub const KEY: Self = Self(0x0e);
    }
    impl FcccmdKey {
        pub const fn from_bits(val: u8) -> FcccmdKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for FcccmdKey {
        #[inline(always)]
        fn from(val: u8) -> FcccmdKey {
            FcccmdKey::from_bits(val)
        }
    }
    impl From<FcccmdKey> for u8 {
        #[inline(always)]
        fn from(val: FcccmdKey) -> u8 {
            FcccmdKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Fcclvltrig {
        RISING = 0x0,
        LEVEL = 0x01,
    }
    impl Fcclvltrig {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Fcclvltrig {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Fcclvltrig {
        #[inline(always)]
        fn from(val: u8) -> Fcclvltrig {
            Fcclvltrig::from_bits(val)
        }
    }
    impl From<Fcclvltrig> for u8 {
        #[inline(always)]
        fn from(val: Fcclvltrig) -> u8 {
            Fcclvltrig::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Fccselclk {
        MCLK = 0x0,
        SYSOSC = 0x01,
        HFCLK = 0x02,
        CLK_OUT = 0x03,
        _RESERVED_4 = 0x04,
        _RESERVED_5 = 0x05,
        _RESERVED_6 = 0x06,
        FCCIN = 0x07,
        _RESERVED_8 = 0x08,
        _RESERVED_9 = 0x09,
        _RESERVED_a = 0x0a,
        _RESERVED_b = 0x0b,
        _RESERVED_c = 0x0c,
        _RESERVED_d = 0x0d,
        _RESERVED_e = 0x0e,
        _RESERVED_f = 0x0f,
    }
    impl Fccselclk {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Fccselclk {
            unsafe { core::mem::transmute(val & 0x0f) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Fccselclk {
        #[inline(always)]
        fn from(val: u8) -> Fccselclk {
            Fccselclk::from_bits(val)
        }
    }
    impl From<Fccselclk> for u8 {
        #[inline(always)]
        fn from(val: Fccselclk) -> u8 {
            Fccselclk::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Fcctrigsrc {
        EXTERNAL = 0x0,
        LFCLK = 0x01,
    }
    impl Fcctrigsrc {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Fcctrigsrc {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Fcctrigsrc {
        #[inline(always)]
        fn from(val: u8) -> Fcctrigsrc {
            Fcctrigsrc::from_bits(val)
        }
    }
    impl From<Fcctrigsrc> for u8 {
        #[inline(always)]
        fn from(val: Fcctrigsrc) -> u8 {
            Fcctrigsrc::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Hsclkmux {
        SYSOSC = 0x0,
        HSCLK = 0x01,
    }
    impl Hsclkmux {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsclkmux {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsclkmux {
        #[inline(always)]
        fn from(val: u8) -> Hsclkmux {
            Hsclkmux::from_bits(val)
        }
    }
    impl From<Hsclkmux> for u8 {
        #[inline(always)]
        fn from(val: Hsclkmux) -> u8 {
            Hsclkmux::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Lfclkmux {
        #[doc = "Internal LFOSC."]
        LFOSC = 0x0,
        #[doc = "LF Crystal."]
        LFXT = 0x01,
        #[doc = "External LFCLK IN."]
        EXLF = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl Lfclkmux {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lfclkmux {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lfclkmux {
        #[inline(always)]
        fn from(val: u8) -> Lfclkmux {
            Lfclkmux::from_bits(val)
        }
    }
    impl From<Lfclkmux> for u8 {
        #[inline(always)]
        fn from(val: Lfclkmux) -> u8 {
            Lfclkmux::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Mfpclksrc {
        SYSOSC = 0x0,
        HFCLK = 0x01,
    }
    impl Mfpclksrc {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Mfpclksrc {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Mfpclksrc {
        #[inline(always)]
        fn from(val: u8) -> Mfpclksrc {
            Mfpclksrc::from_bits(val)
        }
    }
    impl From<Mfpclksrc> for u8 {
        #[inline(always)]
        fn from(val: Mfpclksrc) -> u8 {
            Mfpclksrc::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum NmiStat {
        #[doc = "No Interrupt."]
        NO_INTR = 0x0,
        BORLVL = 0x01,
        WWDT0 = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl NmiStat {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> NmiStat {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for NmiStat {
        #[inline(always)]
        fn from(val: u8) -> NmiStat {
            NmiStat::from_bits(val)
        }
    }
    impl From<NmiStat> for u8 {
        #[inline(always)]
        fn from(val: NmiStat) -> u8 {
            NmiStat::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct ResetcmdKey(pub u8);
    impl ResetcmdKey {
        pub const KEY: Self = Self(0xe4);
    }
    impl ResetcmdKey {
        pub const fn from_bits(val: u8) -> ResetcmdKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for ResetcmdKey {
        #[inline(always)]
        fn from(val: u8) -> ResetcmdKey {
            ResetcmdKey::from_bits(val)
        }
    }
    impl From<ResetcmdKey> for u8 {
        #[inline(always)]
        fn from(val: ResetcmdKey) -> u8 {
            ResetcmdKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum ResetlevelLevel {
        #[doc = "Reset CPU plus peripherals only."]
        CPU = 0x0,
        #[doc = "Reset Main Infrastructure including TRIM."]
        BOOT = 0x01,
        #[doc = "Reset Main Infrastructure and Run BOOTLOADER."]
        BOOTLOADER = 0x02,
        #[doc = "Reset as a Power On Reset."]
        POR = 0x03,
    }
    impl ResetlevelLevel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> ResetlevelLevel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for ResetlevelLevel {
        #[inline(always)]
        fn from(val: u8) -> ResetlevelLevel {
            ResetlevelLevel::from_bits(val)
        }
    }
    impl From<ResetlevelLevel> for u8 {
        #[inline(always)]
        fn from(val: ResetlevelLevel) -> u8 {
            ResetlevelLevel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct ShdniorelKey(pub u8);
    impl ShdniorelKey {
        pub const KEY: Self = Self(0x91);
    }
    impl ShdniorelKey {
        pub const fn from_bits(val: u8) -> ShdniorelKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for ShdniorelKey {
        #[inline(always)]
        fn from(val: u8) -> ShdniorelKey {
            ShdniorelKey::from_bits(val)
        }
    }
    impl From<ShdniorelKey> for u8 {
        #[inline(always)]
        fn from(val: ShdniorelKey) -> u8 {
            ShdniorelKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Stat {
        #[doc = "No Interrupt."]
        NO_INTR = 0x0,
        LFOSCGOOD = 0x01,
        ANACLKERR = 0x02,
        _RESERVED_3 = 0x03,
        _RESERVED_4 = 0x04,
        _RESERVED_5 = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
        _RESERVED_8 = 0x08,
        _RESERVED_9 = 0x09,
        _RESERVED_a = 0x0a,
        _RESERVED_b = 0x0b,
        _RESERVED_c = 0x0c,
        _RESERVED_d = 0x0d,
        _RESERVED_e = 0x0e,
        _RESERVED_f = 0x0f,
    }
    impl Stat {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Stat {
            unsafe { core::mem::transmute(val & 0x0f) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Stat {
        #[inline(always)]
        fn from(val: u8) -> Stat {
            Stat::from_bits(val)
        }
    }
    impl From<Stat> for u8 {
        #[inline(always)]
        fn from(val: Stat) -> u8 {
            Stat::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct SwdcfgKey(pub u8);
    impl SwdcfgKey {
        pub const KEY: Self = Self(0x62);
    }
    impl SwdcfgKey {
        pub const fn from_bits(val: u8) -> SwdcfgKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for SwdcfgKey {
        #[inline(always)]
        fn from(val: u8) -> SwdcfgKey {
            SwdcfgKey::from_bits(val)
        }
    }
    impl From<SwdcfgKey> for u8 {
        #[inline(always)]
        fn from(val: SwdcfgKey) -> u8 {
            SwdcfgKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum SysosccfgFreq {
        SYSOSCBASE = 0x0,
        SYSOSC4M = 0x01,
        SYSOSCUSER = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl SysosccfgFreq {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> SysosccfgFreq {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for SysosccfgFreq {
        #[inline(always)]
        fn from(val: u8) -> SysosccfgFreq {
            SysosccfgFreq::from_bits(val)
        }
    }
    impl From<SysosccfgFreq> for u8 {
        #[inline(always)]
        fn from(val: SysosccfgFreq) -> u8 {
            SysosccfgFreq::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct SysoscfclctlKey(pub u8);
    impl SysoscfclctlKey {
        pub const KEY: Self = Self(0x2a);
    }
    impl SysoscfclctlKey {
        pub const fn from_bits(val: u8) -> SysoscfclctlKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for SysoscfclctlKey {
        #[inline(always)]
        fn from(val: u8) -> SysoscfclctlKey {
            SysoscfclctlKey::from_bits(val)
        }
    }
    impl From<SysoscfclctlKey> for u8 {
        #[inline(always)]
        fn from(val: SysoscfclctlKey) -> u8 {
            SysoscfclctlKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Sysoscfreq {
        SYSOSC32M = 0x0,
        SYSOSC4M = 0x01,
        SYSOSCUSER = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl Sysoscfreq {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Sysoscfreq {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Sysoscfreq {
        #[inline(always)]
        fn from(val: u8) -> Sysoscfreq {
            Sysoscfreq::from_bits(val)
        }
    }
    impl From<Sysoscfreq> for u8 {
        #[inline(always)]
        fn from(val: Sysoscfreq) -> u8 {
            Sysoscfreq::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct SysstatusclrKey(pub u8);
    impl SysstatusclrKey {
        pub const KEY: Self = Self(0xce);
    }
    impl SysstatusclrKey {
        pub const fn from_bits(val: u8) -> SysstatusclrKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for SysstatusclrKey {
        #[inline(always)]
        fn from(val: u8) -> SysstatusclrKey {
            SysstatusclrKey::from_bits(val)
        }
    }
    impl From<SysstatusclrKey> for u8 {
        #[inline(always)]
        fn from(val: SysstatusclrKey) -> u8 {
            SysstatusclrKey::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct SystemcfgKey(pub u8);
    impl SystemcfgKey {
        pub const KEY: Self = Self(0x1b);
    }
    impl SystemcfgKey {
        pub const fn from_bits(val: u8) -> SystemcfgKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for SystemcfgKey {
        #[inline(always)]
        fn from(val: u8) -> SystemcfgKey {
            SystemcfgKey::from_bits(val)
        }
    }
    impl From<SystemcfgKey> for u8 {
        #[inline(always)]
        fn from(val: SystemcfgKey) -> u8 {
            SystemcfgKey::to_bits(val)
        }
    }
}
