// This file is autogenerated by mspm0-metapac-gen: do not edit by hand.
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::identity_op)]
#![allow(clippy::unnecessary_cast)]
#![allow(clippy::erasing_op)]

#[doc = "mem_map."]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Sysctl {
    ptr: *mut u8,
}
unsafe impl Send for Sysctl {}
unsafe impl Sync for Sysctl {}
impl Sysctl {
    #[inline(always)]
    pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
        Self { ptr: ptr as _ }
    }
    #[inline(always)]
    pub const fn as_ptr(&self) -> *mut () {
        self.ptr as _
    }
    #[doc = "SYSCTL interrupt index."]
    #[inline(always)]
    pub const fn iidx(self) -> crate::common::Reg<regs::Iidx, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1020usize) as _) }
    }
    #[doc = "SYSCTL interrupt mask."]
    #[inline(always)]
    pub const fn imask(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1028usize) as _) }
    }
    #[doc = "SYSCTL raw interrupt status."]
    #[inline(always)]
    pub const fn ris(self) -> crate::common::Reg<regs::Int, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1030usize) as _) }
    }
    #[doc = "SYSCTL masked interrupt status."]
    #[inline(always)]
    pub const fn mis(self) -> crate::common::Reg<regs::Int, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1038usize) as _) }
    }
    #[doc = "SYSCTL interrupt set."]
    #[inline(always)]
    pub const fn iset(self) -> crate::common::Reg<regs::Int, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1040usize) as _) }
    }
    #[doc = "SYSCTL interrupt clear."]
    #[inline(always)]
    pub const fn iclr(self) -> crate::common::Reg<regs::Int, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1048usize) as _) }
    }
    #[doc = "NMI interrupt index."]
    #[inline(always)]
    pub const fn nmiiidx(self) -> crate::common::Reg<regs::Nmiiidx, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1050usize) as _) }
    }
    #[doc = "NMI raw interrupt status."]
    #[inline(always)]
    pub const fn nmiris(self) -> crate::common::Reg<regs::Nmi, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1060usize) as _) }
    }
    #[doc = "NMI interrupt set."]
    #[inline(always)]
    pub const fn nmiiset(self) -> crate::common::Reg<regs::Nmi, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1070usize) as _) }
    }
    #[doc = "NMI interrupt clear."]
    #[inline(always)]
    pub const fn nmiiclr(self) -> crate::common::Reg<regs::Nmi, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1078usize) as _) }
    }
    #[doc = "SYSOSC configuration."]
    #[inline(always)]
    pub const fn sysosccfg(self) -> crate::common::Reg<regs::Sysosccfg, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1100usize) as _) }
    }
    #[doc = "Main clock (MCLK) configuration."]
    #[inline(always)]
    pub const fn mclkcfg(self) -> crate::common::Reg<regs::Mclkcfg, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1104usize) as _) }
    }
    #[doc = "High-speed clock (HSCLK) source enable/disable."]
    #[inline(always)]
    pub const fn hsclken(self) -> crate::common::Reg<regs::Hsclken, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1108usize) as _) }
    }
    #[doc = "High-speed clock (HSCLK) source selection."]
    #[inline(always)]
    pub const fn hsclkcfg(self) -> crate::common::Reg<regs::Hsclkcfg, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x110cusize) as _) }
    }
    #[doc = "High-frequency clock (HFCLK) configuration."]
    #[inline(always)]
    pub const fn hfclkclkcfg(self) -> crate::common::Reg<regs::Hfclkclkcfg, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1110usize) as _) }
    }
    #[doc = "Low frequency crystal oscillator (LFXT) configuration."]
    #[inline(always)]
    pub const fn lfclkcfg(self) -> crate::common::Reg<regs::Lfclkcfg, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1114usize) as _) }
    }
    #[doc = "General clock configuration."]
    #[inline(always)]
    pub const fn genclkcfg(self) -> crate::common::Reg<regs::Genclkcfg, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1138usize) as _) }
    }
    #[doc = "General clock enable control."]
    #[inline(always)]
    pub const fn genclken(self) -> crate::common::Reg<regs::Genclken, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x113cusize) as _) }
    }
    #[doc = "Power mode configuration."]
    #[inline(always)]
    pub const fn pmodecfg(self) -> crate::common::Reg<regs::Pmodecfg, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1140usize) as _) }
    }
    #[doc = "Frequency clock counter (FCC) count."]
    #[inline(always)]
    pub const fn fcc(self) -> crate::common::Reg<regs::Fcc, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1150usize) as _) }
    }
    #[doc = "SYSOSC user-specified trim."]
    #[inline(always)]
    pub const fn sysosctrimuser(
        self,
    ) -> crate::common::Reg<regs::Sysosctrimuser, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1170usize) as _) }
    }
    #[doc = "SRAM Write Boundary."]
    #[inline(always)]
    pub const fn sramboundary(self) -> crate::common::Reg<regs::Sramboundary, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1178usize) as _) }
    }
    #[doc = "System configuration."]
    #[inline(always)]
    pub const fn systemcfg(self) -> crate::common::Reg<regs::Systemcfg, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1180usize) as _) }
    }
    #[doc = "SYSCTL register write lockout."]
    #[inline(always)]
    pub const fn writelock(self) -> crate::common::Reg<regs::Writelock, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1200usize) as _) }
    }
    #[doc = "Clock module (CKM) status."]
    #[inline(always)]
    pub const fn clkstatus(self) -> crate::common::Reg<regs::Clkstatus, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1204usize) as _) }
    }
    #[doc = "System status information."]
    #[inline(always)]
    pub const fn sysstatus(self) -> crate::common::Reg<regs::Sysstatus, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1208usize) as _) }
    }
    #[doc = "Memory DED Address."]
    #[inline(always)]
    pub const fn dederraddr(self) -> crate::common::Reg<u32, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x120cusize) as _) }
    }
    #[doc = "Reset cause."]
    #[inline(always)]
    pub const fn rstcause(self) -> crate::common::Reg<regs::Rstcause, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1220usize) as _) }
    }
    #[doc = "Reset level for application-triggered reset command."]
    #[inline(always)]
    pub const fn resetlevel(self) -> crate::common::Reg<regs::Resetlevel, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1300usize) as _) }
    }
    #[doc = "Execute an application-triggered reset command."]
    #[inline(always)]
    pub const fn resetcmd(self) -> crate::common::Reg<regs::Resetcmd, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1304usize) as _) }
    }
    #[doc = "BOR threshold selection."]
    #[inline(always)]
    pub const fn borthreshold(self) -> crate::common::Reg<regs::Borthreshold, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1308usize) as _) }
    }
    #[doc = "Set the BOR threshold."]
    #[inline(always)]
    pub const fn borclrcmd(self) -> crate::common::Reg<regs::Borclrcmd, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x130cusize) as _) }
    }
    #[doc = "SYSOSC frequency correction loop (FCL) ROSC enable."]
    #[inline(always)]
    pub const fn sysoscfclctl(self) -> crate::common::Reg<regs::Sysoscfclctl, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1310usize) as _) }
    }
    #[doc = "LFXT and LFCLK control."]
    #[inline(always)]
    pub const fn lfxtctl(self) -> crate::common::Reg<regs::Lfxtctl, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1314usize) as _) }
    }
    #[doc = "LFCLK_IN and LFCLK control."]
    #[inline(always)]
    pub const fn exlfctl(self) -> crate::common::Reg<regs::Exlfctl, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1318usize) as _) }
    }
    #[doc = "SHUTDOWN IO release control."]
    #[inline(always)]
    pub const fn shdniorel(self) -> crate::common::Reg<regs::Shdniorel, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x131cusize) as _) }
    }
    #[doc = "Disable the reset function of the NRST pin."]
    #[inline(always)]
    pub const fn exrstpin(self) -> crate::common::Reg<regs::Exrstpin, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1320usize) as _) }
    }
    #[doc = "Clear sticky bits of SYSSTATUS."]
    #[inline(always)]
    pub const fn sysstatusclr(self) -> crate::common::Reg<regs::Sysstatusclr, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1324usize) as _) }
    }
    #[doc = "Disable the SWD function on the SWD pins."]
    #[inline(always)]
    pub const fn swdcfg(self) -> crate::common::Reg<regs::Swdcfg, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1328usize) as _) }
    }
    #[doc = "Frequency clock counter start capture."]
    #[inline(always)]
    pub const fn fcccmd(self) -> crate::common::Reg<regs::Fcccmd, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x132cusize) as _) }
    }
    #[doc = "Shutdown storage memory (byte 0)."]
    #[inline(always)]
    pub const fn shutdnstore(
        self,
        n: usize,
    ) -> crate::common::Reg<regs::Shutdnstore, crate::common::RW> {
        assert!(n < 4usize);
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1400usize + n * 4usize) as _) }
    }
    #[doc = "1 Sector Write-Erase per bit starting at address 0x0 of flash."]
    #[inline(always)]
    pub const fn fweprotmain(self) -> crate::common::Reg<u32, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3000usize) as _) }
    }
    #[doc = "Flash RX Protection Start Address."]
    #[inline(always)]
    pub const fn frxprotmainstart(
        self,
    ) -> crate::common::Reg<regs::Frxprotmainstart, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3018usize) as _) }
    }
    #[doc = "Flash RX Protection End Address."]
    #[inline(always)]
    pub const fn frxprotmainend(
        self,
    ) -> crate::common::Reg<regs::Frxprotmainend, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x301cusize) as _) }
    }
    #[doc = "Flash IP Protection Start Address."]
    #[inline(always)]
    pub const fn fipprotmainstart(
        self,
    ) -> crate::common::Reg<regs::Fipprotmainstart, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3020usize) as _) }
    }
    #[doc = "Flash IP Protection End Address."]
    #[inline(always)]
    pub const fn fipprotmainend(
        self,
    ) -> crate::common::Reg<regs::Fipprotmainend, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3024usize) as _) }
    }
    #[doc = "Flash Bank Swap Policy."]
    #[inline(always)]
    pub const fn flbankswppolicy(
        self,
    ) -> crate::common::Reg<regs::Flbankswppolicy, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3038usize) as _) }
    }
    #[doc = "Flash MAIN bank address swap."]
    #[inline(always)]
    pub const fn flbankswp(self) -> crate::common::Reg<regs::Flbankswp, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x303cusize) as _) }
    }
    #[doc = "Security Firewall Enable Register."]
    #[inline(always)]
    pub const fn fwenable(self) -> crate::common::Reg<regs::Fwenable, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3044usize) as _) }
    }
    #[doc = "Security Configuration status."]
    #[inline(always)]
    pub const fn secstatus(self) -> crate::common::Reg<regs::Secstatus, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3048usize) as _) }
    }
    #[doc = "INITCODE PASS."]
    #[inline(always)]
    pub const fn initdone(self) -> crate::common::Reg<regs::Initdone, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3060usize) as _) }
    }
}
pub mod regs {
    #[doc = "Set the BOR threshold."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Borclrcmd(pub u32);
    impl Borclrcmd {
        #[doc = "GO clears any prior BOR violation status indications and attempts to change the active BOR mode to that specified in the LEVEL field of the BORTHRESHOLD register."]
        #[inline(always)]
        pub const fn go(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "GO clears any prior BOR violation status indications and attempts to change the active BOR mode to that specified in the LEVEL field of the BORTHRESHOLD register."]
        #[inline(always)]
        pub fn set_go(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::BorclrcmdKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::BorclrcmdKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::BorclrcmdKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Borclrcmd {
        #[inline(always)]
        fn default() -> Borclrcmd {
            Borclrcmd(0)
        }
    }
    #[doc = "BOR threshold selection."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Borthreshold(pub u32);
    impl Borthreshold {
        #[doc = "LEVEL specifies the desired BOR threshold and BOR mode."]
        #[inline(always)]
        pub const fn level(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x03;
            val as u8
        }
        #[doc = "LEVEL specifies the desired BOR threshold and BOR mode."]
        #[inline(always)]
        pub fn set_level(&mut self, val: u8) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
        }
    }
    impl Default for Borthreshold {
        #[inline(always)]
        fn default() -> Borthreshold {
            Borthreshold(0)
        }
    }
    #[doc = "Clock module (CKM) status."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Clkstatus(pub u32);
    impl Clkstatus {
        #[doc = "SYSOSCFREQ indicates the current SYSOSC operating frequency."]
        #[inline(always)]
        pub const fn sysoscfreq(&self) -> super::vals::Sysoscfreq {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::Sysoscfreq::from_bits(val as u8)
        }
        #[doc = "SYSOSCFREQ indicates the current SYSOSC operating frequency."]
        #[inline(always)]
        pub fn set_sysoscfreq(&mut self, val: super::vals::Sysoscfreq) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
        #[doc = "HSCLKMUX indicates if MCLK is currently sourced from the high-speed clock (HSCLK)."]
        #[inline(always)]
        pub const fn hsclkmux(&self) -> super::vals::Hsclkmux {
            let val = (self.0 >> 4usize) & 0x01;
            super::vals::Hsclkmux::from_bits(val as u8)
        }
        #[doc = "HSCLKMUX indicates if MCLK is currently sourced from the high-speed clock (HSCLK)."]
        #[inline(always)]
        pub fn set_hsclkmux(&mut self, val: super::vals::Hsclkmux) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
        }
        #[doc = "LFCLKMUX indicates if LFCLK is sourced from the internal LFOSC, the low frequency crystal (LFXT), or the LFCLK_IN digital clock input."]
        #[inline(always)]
        pub const fn lfclkmux(&self) -> super::vals::Lfclkmux {
            let val = (self.0 >> 6usize) & 0x03;
            super::vals::Lfclkmux::from_bits(val as u8)
        }
        #[doc = "LFCLKMUX indicates if LFCLK is sourced from the internal LFOSC, the low frequency crystal (LFXT), or the LFCLK_IN digital clock input."]
        #[inline(always)]
        pub fn set_lfclkmux(&mut self, val: super::vals::Lfclkmux) {
            self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u32) & 0x03) << 6usize);
        }
        #[doc = "HFCLKGOOD indicates that the HFCLK started correctly. When the HFXT is started or HFCLK_IN is selected as the HFCLK source, this bit will be set by hardware if a valid HFCLK is detected, and cleared if HFCLK is not operating within the expected range."]
        #[inline(always)]
        pub const fn hfclkgood(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "HFCLKGOOD indicates that the HFCLK started correctly. When the HFXT is started or HFCLK_IN is selected as the HFCLK source, this bit will be set by hardware if a valid HFCLK is detected, and cleared if HFCLK is not operating within the expected range."]
        #[inline(always)]
        pub fn set_hfclkgood(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "LFXTGOOD indicates if the LFXT started correctly. When the LFXT is started, LFXTGOOD is cleared by hardware. After the startup settling time has expired, the LFXT status is tested. If the LFXT started successfully the LFXTGOOD bit is set, else it is left cleared."]
        #[inline(always)]
        pub const fn lfxtgood(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "LFXTGOOD indicates if the LFXT started correctly. When the LFXT is started, LFXTGOOD is cleared by hardware. After the startup settling time has expired, the LFXT status is tested. If the LFXT started successfully the LFXTGOOD bit is set, else it is left cleared."]
        #[inline(always)]
        pub fn set_lfxtgood(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "LFOSCGOOD indicates when the LFOSC startup has completed and the LFOSC is ready for use."]
        #[inline(always)]
        pub const fn lfoscgood(&self) -> bool {
            let val = (self.0 >> 11usize) & 0x01;
            val != 0
        }
        #[doc = "LFOSCGOOD indicates when the LFOSC startup has completed and the LFOSC is ready for use."]
        #[inline(always)]
        pub fn set_lfoscgood(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
        }
        #[doc = "HSCLKSOFF is set when the high speed clock sources (SYSPLL, HFCLK) are disabled or dead. It is the logical AND of HFCLKOFF and SYSPLLOFF."]
        #[inline(always)]
        pub const fn hsclksoff(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "HSCLKSOFF is set when the high speed clock sources (SYSPLL, HFCLK) are disabled or dead. It is the logical AND of HFCLKOFF and SYSPLLOFF."]
        #[inline(always)]
        pub fn set_hsclksoff(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "HFCLKOFF indicates if the HFCLK is disabled or was dead at startup. When the HFCLK is started, HFCLKOFF is cleared by hardware. Following startup of the HFCLK, if the HFCLK startup monitor determines that the HFCLK was not started correctly, HFCLKOFF is set."]
        #[inline(always)]
        pub const fn hfclkoff(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "HFCLKOFF indicates if the HFCLK is disabled or was dead at startup. When the HFCLK is started, HFCLKOFF is cleared by hardware. Following startup of the HFCLK, if the HFCLK startup monitor determines that the HFCLK was not started correctly, HFCLKOFF is set."]
        #[inline(always)]
        pub fn set_hfclkoff(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "CURHSCLKSEL indicates the current clock source for HSCLK."]
        #[inline(always)]
        pub const fn curhsclksel(&self) -> super::vals::Curhsclksel {
            let val = (self.0 >> 16usize) & 0x01;
            super::vals::Curhsclksel::from_bits(val as u8)
        }
        #[doc = "CURHSCLKSEL indicates the current clock source for HSCLK."]
        #[inline(always)]
        pub fn set_curhsclksel(&mut self, val: super::vals::Curhsclksel) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
        }
        #[doc = "CURMCLKSEL indicates if MCLK is currently sourced from LFCLK."]
        #[inline(always)]
        pub const fn curmclksel(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "CURMCLKSEL indicates if MCLK is currently sourced from LFCLK."]
        #[inline(always)]
        pub fn set_curmclksel(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
        #[doc = "HSCLKDEAD is set by hardware if the selected source for HSCLK was started but did not start successfully."]
        #[inline(always)]
        pub const fn hsclkdead(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "HSCLKDEAD is set by hardware if the selected source for HSCLK was started but did not start successfully."]
        #[inline(always)]
        pub fn set_hsclkdead(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "HSCLKGOOD is set by hardware if the selected clock source for HSCLK started successfully."]
        #[inline(always)]
        pub const fn hsclkgood(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "HSCLKGOOD is set by hardware if the selected clock source for HSCLK started successfully."]
        #[inline(always)]
        pub fn set_hsclkgood(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
        #[doc = "LFCLKFAIL indicates when the continous LFCLK monitor detects a LFXT or LFCLK_IN clock stuck failure."]
        #[inline(always)]
        pub const fn lfclkfail(&self) -> bool {
            let val = (self.0 >> 23usize) & 0x01;
            val != 0
        }
        #[doc = "LFCLKFAIL indicates when the continous LFCLK monitor detects a LFXT or LFCLK_IN clock stuck failure."]
        #[inline(always)]
        pub fn set_lfclkfail(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
        }
        #[doc = "FCLMODE indicates if the SYSOSC frequency correction loop (FCL) is enabled."]
        #[inline(always)]
        pub const fn fclmode(&self) -> bool {
            let val = (self.0 >> 24usize) & 0x01;
            val != 0
        }
        #[doc = "FCLMODE indicates if the SYSOSC frequency correction loop (FCL) is enabled."]
        #[inline(always)]
        pub fn set_fclmode(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
        }
        #[doc = "FCCDONE indicates when a frequency clock counter capture is complete."]
        #[inline(always)]
        pub const fn fccdone(&self) -> bool {
            let val = (self.0 >> 25usize) & 0x01;
            val != 0
        }
        #[doc = "FCCDONE indicates when a frequency clock counter capture is complete."]
        #[inline(always)]
        pub fn set_fccdone(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
        }
        #[doc = "HFCLKBLKUPD indicates when writes to the HFCLKCLKCFG register are blocked."]
        #[inline(always)]
        pub const fn hfclkblkupd(&self) -> bool {
            let val = (self.0 >> 28usize) & 0x01;
            val != 0
        }
        #[doc = "HFCLKBLKUPD indicates when writes to the HFCLKCLKCFG register are blocked."]
        #[inline(always)]
        pub fn set_hfclkblkupd(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
        }
        #[doc = "ANACLKERR is set when the device clock configuration does not support an enabled analog peripheral mode and the analog peripheral may not be functioning as expected."]
        #[inline(always)]
        pub const fn anaclkerr(&self) -> bool {
            let val = (self.0 >> 31usize) & 0x01;
            val != 0
        }
        #[doc = "ANACLKERR is set when the device clock configuration does not support an enabled analog peripheral mode and the analog peripheral may not be functioning as expected."]
        #[inline(always)]
        pub fn set_anaclkerr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
        }
    }
    impl Default for Clkstatus {
        #[inline(always)]
        fn default() -> Clkstatus {
            Clkstatus(0)
        }
    }
    #[doc = "LFCLK_IN and LFCLK control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Exlfctl(pub u32);
    impl Exlfctl {
        #[doc = "Set SETUSEEXLF to switch LFCLK to the LFCLK_IN digital clock input. Once set, SETUSEEXLF remains set until the next BOOTRST."]
        #[inline(always)]
        pub const fn setuseexlf(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Set SETUSEEXLF to switch LFCLK to the LFCLK_IN digital clock input. Once set, SETUSEEXLF remains set until the next BOOTRST."]
        #[inline(always)]
        pub fn set_setuseexlf(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Exlfctl {
        #[inline(always)]
        fn default() -> Exlfctl {
            Exlfctl(0)
        }
    }
    #[doc = "Disable the reset function of the NRST pin."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Exrstpin(pub u32);
    impl Exrstpin {
        #[doc = "Set DISABLE to disable the reset function of the NRST pin. Once set, this configuration is locked until the next POR."]
        #[inline(always)]
        pub const fn disable(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Set DISABLE to disable the reset function of the NRST pin. Once set, this configuration is locked until the next POR."]
        #[inline(always)]
        pub fn set_disable(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::ExrstpinKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::ExrstpinKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::ExrstpinKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Exrstpin {
        #[inline(always)]
        fn default() -> Exrstpin {
            Exrstpin(0)
        }
    }
    #[doc = "Frequency clock counter (FCC) count."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Fcc(pub u32);
    impl Fcc {
        #[doc = "Frequency clock counter (FCC) count value."]
        #[inline(always)]
        pub const fn data(&self) -> u32 {
            let val = (self.0 >> 0usize) & 0x003f_ffff;
            val as u32
        }
        #[doc = "Frequency clock counter (FCC) count value."]
        #[inline(always)]
        pub fn set_data(&mut self, val: u32) {
            self.0 = (self.0 & !(0x003f_ffff << 0usize)) | (((val as u32) & 0x003f_ffff) << 0usize);
        }
    }
    impl Default for Fcc {
        #[inline(always)]
        fn default() -> Fcc {
            Fcc(0)
        }
    }
    #[doc = "Frequency clock counter start capture."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Fcccmd(pub u32);
    impl Fcccmd {
        #[doc = "Set GO to start a capture with the frequency clock counter (FCC)."]
        #[inline(always)]
        pub const fn go(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Set GO to start a capture with the frequency clock counter (FCC)."]
        #[inline(always)]
        pub fn set_go(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::FcccmdKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::FcccmdKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::FcccmdKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Fcccmd {
        #[inline(always)]
        fn default() -> Fcccmd {
            Fcccmd(0)
        }
    }
    #[doc = "Flash IP Protection End Address."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Fipprotmainend(pub u32);
    impl Fipprotmainend {
        #[doc = "Flash IP Protection End Address 64B granularity."]
        #[inline(always)]
        pub const fn addr(&self) -> u16 {
            let val = (self.0 >> 6usize) & 0xffff;
            val as u16
        }
        #[doc = "Flash IP Protection End Address 64B granularity."]
        #[inline(always)]
        pub fn set_addr(&mut self, val: u16) {
            self.0 = (self.0 & !(0xffff << 6usize)) | (((val as u32) & 0xffff) << 6usize);
        }
    }
    impl Default for Fipprotmainend {
        #[inline(always)]
        fn default() -> Fipprotmainend {
            Fipprotmainend(0)
        }
    }
    #[doc = "Flash IP Protection Start Address."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Fipprotmainstart(pub u32);
    impl Fipprotmainstart {
        #[doc = "Flash IP Protection Start Address 64B granularity."]
        #[inline(always)]
        pub const fn addr(&self) -> u16 {
            let val = (self.0 >> 6usize) & 0xffff;
            val as u16
        }
        #[doc = "Flash IP Protection Start Address 64B granularity."]
        #[inline(always)]
        pub fn set_addr(&mut self, val: u16) {
            self.0 = (self.0 & !(0xffff << 6usize)) | (((val as u32) & 0xffff) << 6usize);
        }
    }
    impl Default for Fipprotmainstart {
        #[inline(always)]
        fn default() -> Fipprotmainstart {
            Fipprotmainstart(0)
        }
    }
    #[doc = "Flash MAIN bank address swap."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Flbankswp(pub u32);
    impl Flbankswp {
        #[doc = "1: Use Upper Bank as Logical 0."]
        #[inline(always)]
        pub const fn useupper(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "1: Use Upper Bank as Logical 0."]
        #[inline(always)]
        pub fn set_useupper(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Flbankswp {
        #[inline(always)]
        fn default() -> Flbankswp {
            Flbankswp(0)
        }
    }
    #[doc = "Flash Bank Swap Policy."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Flbankswppolicy(pub u32);
    impl Flbankswppolicy {
        #[doc = "1: Disables Policy To Allow Flash Bank Swapping."]
        #[inline(always)]
        pub const fn disable(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "1: Disables Policy To Allow Flash Bank Swapping."]
        #[inline(always)]
        pub fn set_disable(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Flbankswppolicy {
        #[inline(always)]
        fn default() -> Flbankswppolicy {
            Flbankswppolicy(0)
        }
    }
    #[doc = "Flash RX Protection End Address."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Frxprotmainend(pub u32);
    impl Frxprotmainend {
        #[doc = "Flash RX Protection End Address 64B granularity."]
        #[inline(always)]
        pub const fn addr(&self) -> u16 {
            let val = (self.0 >> 6usize) & 0xffff;
            val as u16
        }
        #[doc = "Flash RX Protection End Address 64B granularity."]
        #[inline(always)]
        pub fn set_addr(&mut self, val: u16) {
            self.0 = (self.0 & !(0xffff << 6usize)) | (((val as u32) & 0xffff) << 6usize);
        }
    }
    impl Default for Frxprotmainend {
        #[inline(always)]
        fn default() -> Frxprotmainend {
            Frxprotmainend(0)
        }
    }
    #[doc = "Flash RX Protection Start Address."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Frxprotmainstart(pub u32);
    impl Frxprotmainstart {
        #[doc = "Flash RX Protection Start Address 64B granularity."]
        #[inline(always)]
        pub const fn addr(&self) -> u16 {
            let val = (self.0 >> 6usize) & 0xffff;
            val as u16
        }
        #[doc = "Flash RX Protection Start Address 64B granularity."]
        #[inline(always)]
        pub fn set_addr(&mut self, val: u16) {
            self.0 = (self.0 & !(0xffff << 6usize)) | (((val as u32) & 0xffff) << 6usize);
        }
    }
    impl Default for Frxprotmainstart {
        #[inline(always)]
        fn default() -> Frxprotmainstart {
            Frxprotmainstart(0)
        }
    }
    #[doc = "Security Firewall Enable Register."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Fwenable(pub u32);
    impl Fwenable {
        #[doc = "1: Flash Read Execute Protection Active."]
        #[inline(always)]
        pub const fn flrxprot(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "1: Flash Read Execute Protection Active."]
        #[inline(always)]
        pub fn set_flrxprot(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "1: Flash Read IP ProtectionActive."]
        #[inline(always)]
        pub const fn flipprot(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "1: Flash Read IP ProtectionActive."]
        #[inline(always)]
        pub fn set_flipprot(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "1: Blocks Writes from Changing SRAMBOUNDARY MMR."]
        #[inline(always)]
        pub const fn sramboundarylock(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "1: Blocks Writes from Changing SRAMBOUNDARY MMR."]
        #[inline(always)]
        pub fn set_sramboundarylock(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
    }
    impl Default for Fwenable {
        #[inline(always)]
        fn default() -> Fwenable {
            Fwenable(0)
        }
    }
    #[doc = "General clock configuration."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Genclkcfg(pub u32);
    impl Genclkcfg {
        #[doc = "EXCLKSRC selects the source for the CLK_OUT external clock output block. ULPCLK and MFPCLK require the CLK_OUT divider (EXCLKDIVEN) to be enabled."]
        #[inline(always)]
        pub const fn exclksrc(&self) -> super::vals::Exclksrc {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::Exclksrc::from_bits(val as u8)
        }
        #[doc = "EXCLKSRC selects the source for the CLK_OUT external clock output block. ULPCLK and MFPCLK require the CLK_OUT divider (EXCLKDIVEN) to be enabled."]
        #[inline(always)]
        pub fn set_exclksrc(&mut self, val: super::vals::Exclksrc) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
        #[doc = "EXCLKDIVVAL selects the divider value for the divider in the CLK_OUT external clock output block."]
        #[inline(always)]
        pub const fn exclkdivval(&self) -> super::vals::Exclkdivval {
            let val = (self.0 >> 4usize) & 0x07;
            super::vals::Exclkdivval::from_bits(val as u8)
        }
        #[doc = "EXCLKDIVVAL selects the divider value for the divider in the CLK_OUT external clock output block."]
        #[inline(always)]
        pub fn set_exclkdivval(&mut self, val: super::vals::Exclkdivval) {
            self.0 = (self.0 & !(0x07 << 4usize)) | (((val.to_bits() as u32) & 0x07) << 4usize);
        }
        #[doc = "EXCLKDIVEN enables or disables the divider function of the CLK_OUT external clock output block."]
        #[inline(always)]
        pub const fn exclkdiven(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "EXCLKDIVEN enables or disables the divider function of the CLK_OUT external clock output block."]
        #[inline(always)]
        pub fn set_exclkdiven(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "MFPCLKSRC selects the MFPCLK (middle frequency precision clock) source."]
        #[inline(always)]
        pub const fn mfpclksrc(&self) -> super::vals::Mfpclksrc {
            let val = (self.0 >> 9usize) & 0x01;
            super::vals::Mfpclksrc::from_bits(val as u8)
        }
        #[doc = "MFPCLKSRC selects the MFPCLK (middle frequency precision clock) source."]
        #[inline(always)]
        pub fn set_mfpclksrc(&mut self, val: super::vals::Mfpclksrc) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
        }
        #[doc = "HFCLK4MFPCLKDIV selects the divider applied to HFCLK when HFCLK is used as the MFPCLK source. Integer dividers from /1 to /16 may be selected."]
        #[inline(always)]
        pub const fn hfclk4mfpclkdiv(&self) -> super::vals::Hfclk4mfpclkdiv {
            let val = (self.0 >> 12usize) & 0x0f;
            super::vals::Hfclk4mfpclkdiv::from_bits(val as u8)
        }
        #[doc = "HFCLK4MFPCLKDIV selects the divider applied to HFCLK when HFCLK is used as the MFPCLK source. Integer dividers from /1 to /16 may be selected."]
        #[inline(always)]
        pub fn set_hfclk4mfpclkdiv(&mut self, val: super::vals::Hfclk4mfpclkdiv) {
            self.0 = (self.0 & !(0x0f << 12usize)) | (((val.to_bits() as u32) & 0x0f) << 12usize);
        }
        #[doc = "FCCSELCLK selectes the frequency clock counter (FCC) clock source."]
        #[inline(always)]
        pub const fn fccselclk(&self) -> super::vals::Fccselclk {
            let val = (self.0 >> 16usize) & 0x0f;
            super::vals::Fccselclk::from_bits(val as u8)
        }
        #[doc = "FCCSELCLK selectes the frequency clock counter (FCC) clock source."]
        #[inline(always)]
        pub fn set_fccselclk(&mut self, val: super::vals::Fccselclk) {
            self.0 = (self.0 & !(0x0f << 16usize)) | (((val.to_bits() as u32) & 0x0f) << 16usize);
        }
        #[doc = "FCCTRIGSRC selects the frequency clock counter (FCC) trigger source."]
        #[inline(always)]
        pub const fn fcctrigsrc(&self) -> super::vals::Fcctrigsrc {
            let val = (self.0 >> 20usize) & 0x01;
            super::vals::Fcctrigsrc::from_bits(val as u8)
        }
        #[doc = "FCCTRIGSRC selects the frequency clock counter (FCC) trigger source."]
        #[inline(always)]
        pub fn set_fcctrigsrc(&mut self, val: super::vals::Fcctrigsrc) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
        }
        #[doc = "FCCLVLTRIG selects the frequency clock counter (FCC) trigger mode."]
        #[inline(always)]
        pub const fn fcclvltrig(&self) -> super::vals::Fcclvltrig {
            let val = (self.0 >> 21usize) & 0x01;
            super::vals::Fcclvltrig::from_bits(val as u8)
        }
        #[doc = "FCCLVLTRIG selects the frequency clock counter (FCC) trigger mode."]
        #[inline(always)]
        pub fn set_fcclvltrig(&mut self, val: super::vals::Fcclvltrig) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
        }
        #[doc = "ANACPUMPCFG selects the analog mux charge pump (VBOOST) enable method."]
        #[inline(always)]
        pub const fn anacpumpcfg(&self) -> super::vals::Anacpumpcfg {
            let val = (self.0 >> 22usize) & 0x03;
            super::vals::Anacpumpcfg::from_bits(val as u8)
        }
        #[doc = "ANACPUMPCFG selects the analog mux charge pump (VBOOST) enable method."]
        #[inline(always)]
        pub fn set_anacpumpcfg(&mut self, val: super::vals::Anacpumpcfg) {
            self.0 = (self.0 & !(0x03 << 22usize)) | (((val.to_bits() as u32) & 0x03) << 22usize);
        }
        #[doc = "FCCTRIGCNT specifies the number of trigger clock periods in the trigger window. FCCTRIGCNT=0h (one trigger clock period) up to 1Fh (32 trigger clock periods) may be specified."]
        #[inline(always)]
        pub const fn fcctrigcnt(&self) -> u8 {
            let val = (self.0 >> 24usize) & 0x1f;
            val as u8
        }
        #[doc = "FCCTRIGCNT specifies the number of trigger clock periods in the trigger window. FCCTRIGCNT=0h (one trigger clock period) up to 1Fh (32 trigger clock periods) may be specified."]
        #[inline(always)]
        pub fn set_fcctrigcnt(&mut self, val: u8) {
            self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
        }
    }
    impl Default for Genclkcfg {
        #[inline(always)]
        fn default() -> Genclkcfg {
            Genclkcfg(0)
        }
    }
    #[doc = "General clock enable control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Genclken(pub u32);
    impl Genclken {
        #[doc = "EXCLKEN enables the CLK_OUT external clock output block."]
        #[inline(always)]
        pub const fn exclken(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "EXCLKEN enables the CLK_OUT external clock output block."]
        #[inline(always)]
        pub fn set_exclken(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "MFPCLKEN enables the middle frequency precision clock (MFPCLK)."]
        #[inline(always)]
        pub const fn mfpclken(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "MFPCLKEN enables the middle frequency precision clock (MFPCLK)."]
        #[inline(always)]
        pub fn set_mfpclken(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
    }
    impl Default for Genclken {
        #[inline(always)]
        fn default() -> Genclken {
            Genclken(0)
        }
    }
    #[doc = "High-frequency clock (HFCLK) configuration."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Hfclkclkcfg(pub u32);
    impl Hfclkclkcfg {
        #[doc = "HFXTTIME specifies the HFXT startup time in 64us resolution. If the HFCLK startup monitor is enabled (HFCLKFLTCHK), HFXT will be checked after this time expires."]
        #[inline(always)]
        pub const fn hfxttime(&self) -> super::vals::Hfxttime {
            let val = (self.0 >> 0usize) & 0xff;
            super::vals::Hfxttime::from_bits(val as u8)
        }
        #[doc = "HFXTTIME specifies the HFXT startup time in 64us resolution. If the HFCLK startup monitor is enabled (HFCLKFLTCHK), HFXT will be checked after this time expires."]
        #[inline(always)]
        pub fn set_hfxttime(&mut self, val: super::vals::Hfxttime) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val.to_bits() as u32) & 0xff) << 0usize);
        }
        #[doc = "HFXT Range Select."]
        #[inline(always)]
        pub const fn hfxtrsel(&self) -> super::vals::Hfxtrsel {
            let val = (self.0 >> 12usize) & 0x03;
            super::vals::Hfxtrsel::from_bits(val as u8)
        }
        #[doc = "HFXT Range Select."]
        #[inline(always)]
        pub fn set_hfxtrsel(&mut self, val: super::vals::Hfxtrsel) {
            self.0 = (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
        }
        #[doc = "HFCLKFLTCHK enables or disables the HFCLK startup monitor."]
        #[inline(always)]
        pub const fn hfclkfltchk(&self) -> bool {
            let val = (self.0 >> 28usize) & 0x01;
            val != 0
        }
        #[doc = "HFCLKFLTCHK enables or disables the HFCLK startup monitor."]
        #[inline(always)]
        pub fn set_hfclkfltchk(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
        }
    }
    impl Default for Hfclkclkcfg {
        #[inline(always)]
        fn default() -> Hfclkclkcfg {
            Hfclkclkcfg(0)
        }
    }
    #[doc = "High-speed clock (HSCLK) source selection."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Hsclkcfg(pub u32);
    impl Hsclkcfg {
        #[doc = "HSCLKSEL selects the HSCLK source (SYSPLL or HFCLK)."]
        #[inline(always)]
        pub const fn hsclksel(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "HSCLKSEL selects the HSCLK source (SYSPLL or HFCLK)."]
        #[inline(always)]
        pub fn set_hsclksel(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Hsclkcfg {
        #[inline(always)]
        fn default() -> Hsclkcfg {
            Hsclkcfg(0)
        }
    }
    #[doc = "High-speed clock (HSCLK) source enable/disable."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Hsclken(pub u32);
    impl Hsclken {
        #[doc = "HFXTEN enables or disables the high frequency crystal oscillator (HFXT)."]
        #[inline(always)]
        pub const fn hfxten(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "HFXTEN enables or disables the high frequency crystal oscillator (HFXT)."]
        #[inline(always)]
        pub fn set_hfxten(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "USEEXTHFCLK selects the HFCLK_IN digital clock input to be the source for HFCLK. When disabled, HFXT is the HFCLK source and HFXTEN may be set. Do not set HFXTEN and USEEXTHFCLK simultaneously."]
        #[inline(always)]
        pub const fn useexthfclk(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "USEEXTHFCLK selects the HFCLK_IN digital clock input to be the source for HFCLK. When disabled, HFXT is the HFCLK source and HFXTEN may be set. Do not set HFXTEN and USEEXTHFCLK simultaneously."]
        #[inline(always)]
        pub fn set_useexthfclk(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
    }
    impl Default for Hsclken {
        #[inline(always)]
        fn default() -> Hsclken {
            Hsclken(0)
        }
    }
    #[doc = "SYSCTL interrupt index."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iidx(pub u32);
    impl Iidx {
        #[doc = "The SYSCTL interrupt index (IIDX) register generates a value corresponding to the highest priority pending interrupt source. This value may be used as an address offset for fast, deterministic handling in the interrupt service routine. A read of the IIDX register will clear the corresponding interrupt status in the RIS and MIS registers."]
        #[inline(always)]
        pub const fn stat(&self) -> super::vals::IidxStat {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::IidxStat::from_bits(val as u8)
        }
        #[doc = "The SYSCTL interrupt index (IIDX) register generates a value corresponding to the highest priority pending interrupt source. This value may be used as an address offset for fast, deterministic handling in the interrupt service routine. A read of the IIDX register will clear the corresponding interrupt status in the RIS and MIS registers."]
        #[inline(always)]
        pub fn set_stat(&mut self, val: super::vals::IidxStat) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
    }
    impl Default for Iidx {
        #[inline(always)]
        fn default() -> Iidx {
            Iidx(0)
        }
    }
    #[doc = "INITCODE PASS."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Initdone(pub u32);
    impl Initdone {
        #[doc = "INITCODE writes 1 for PASS, left unwritten a timeout will occur if not blocked."]
        #[inline(always)]
        pub const fn pass(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "INITCODE writes 1 for PASS, left unwritten a timeout will occur if not blocked."]
        #[inline(always)]
        pub fn set_pass(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Initdone {
        #[inline(always)]
        fn default() -> Initdone {
            Initdone(0)
        }
    }
    #[doc = "SYSCTL interrupt clear."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Int(pub u32);
    impl Int {
        #[doc = "Clear the LFOSCGOOD interrupt."]
        #[inline(always)]
        pub const fn lfoscgood(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Clear the LFOSCGOOD interrupt."]
        #[inline(always)]
        pub fn set_lfoscgood(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Analog Clocking Consistency Error."]
        #[inline(always)]
        pub const fn anaclkerr(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Analog Clocking Consistency Error."]
        #[inline(always)]
        pub fn set_anaclkerr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "Flash Single Error Correct."]
        #[inline(always)]
        pub const fn flashsec(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "Flash Single Error Correct."]
        #[inline(always)]
        pub fn set_flashsec(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "SRAM Single Error Correct."]
        #[inline(always)]
        pub const fn sramsec(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "SRAM Single Error Correct."]
        #[inline(always)]
        pub fn set_sramsec(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "LFXT GOOD."]
        #[inline(always)]
        pub const fn lfxtgood(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "LFXT GOOD."]
        #[inline(always)]
        pub fn set_lfxtgood(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "HFCLK GOOD."]
        #[inline(always)]
        pub const fn hfclkgood(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "HFCLK GOOD."]
        #[inline(always)]
        pub fn set_hfclkgood(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "HSCLK GOOD."]
        #[inline(always)]
        pub const fn hsclkgood(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "HSCLK GOOD."]
        #[inline(always)]
        pub fn set_hsclkgood(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Int {
        #[inline(always)]
        fn default() -> Int {
            Int(0)
        }
    }
    #[doc = "Low frequency crystal oscillator (LFXT) configuration."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Lfclkcfg(pub u32);
    impl Lfclkcfg {
        #[doc = "XT1DRIVE selects the low frequency crystal oscillator (LFXT) drive strength."]
        #[inline(always)]
        pub const fn xt1drive(&self) -> super::vals::Xt1drive {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::Xt1drive::from_bits(val as u8)
        }
        #[doc = "XT1DRIVE selects the low frequency crystal oscillator (LFXT) drive strength."]
        #[inline(always)]
        pub fn set_xt1drive(&mut self, val: super::vals::Xt1drive) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
        #[doc = "MONITOR enables or disables the LFCLK monitor, which continuously checks LFXT or LFCLK_IN for a clock stuck fault."]
        #[inline(always)]
        pub const fn monitor(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "MONITOR enables or disables the LFCLK monitor, which continuously checks LFXT or LFCLK_IN for a clock stuck fault."]
        #[inline(always)]
        pub fn set_monitor(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "LOWCAP controls the low-power LFXT mode. When the LFXT load capacitance is less than 3pf, LOWCAP may be set for reduced power consumption."]
        #[inline(always)]
        pub const fn lowcap(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "LOWCAP controls the low-power LFXT mode. When the LFXT load capacitance is less than 3pf, LOWCAP may be set for reduced power consumption."]
        #[inline(always)]
        pub fn set_lowcap(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
    }
    impl Default for Lfclkcfg {
        #[inline(always)]
        fn default() -> Lfclkcfg {
            Lfclkcfg(0)
        }
    }
    #[doc = "LFXT and LFCLK control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Lfxtctl(pub u32);
    impl Lfxtctl {
        #[doc = "Set STARTLFXT to start the low frequency crystal oscillator (LFXT). Once set, STARTLFXT remains set until the next BOOTRST."]
        #[inline(always)]
        pub const fn startlfxt(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Set STARTLFXT to start the low frequency crystal oscillator (LFXT). Once set, STARTLFXT remains set until the next BOOTRST."]
        #[inline(always)]
        pub fn set_startlfxt(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Set SETUSELFXT to switch LFCLK to LFXT. Once set, SETUSELFXT remains set until the next BOOTRST."]
        #[inline(always)]
        pub const fn setuselfxt(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Set SETUSELFXT to switch LFCLK to LFXT. Once set, SETUSELFXT remains set until the next BOOTRST."]
        #[inline(always)]
        pub fn set_setuselfxt(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
    }
    impl Default for Lfxtctl {
        #[inline(always)]
        fn default() -> Lfxtctl {
            Lfxtctl(0)
        }
    }
    #[doc = "Main clock (MCLK) configuration."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Mclkcfg(pub u32);
    impl Mclkcfg {
        #[doc = "MDIV may be used to divide the MCLK frequency when MCLK is sourced from SYSOSC. MDIV=0h corresponds to /1 (no divider). MDIV=1h corresponds to /2 (divide-by-2). MDIV=Fh corresponds to /16 (divide-by-16). MDIV may be set between /1 and /16 on an integer basis."]
        #[inline(always)]
        pub const fn mdiv(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0x0f;
            val as u8
        }
        #[doc = "MDIV may be used to divide the MCLK frequency when MCLK is sourced from SYSOSC. MDIV=0h corresponds to /1 (no divider). MDIV=1h corresponds to /2 (divide-by-2). MDIV=Fh corresponds to /16 (divide-by-16). MDIV may be set between /1 and /16 on an integer basis."]
        #[inline(always)]
        pub fn set_mdiv(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
        }
        #[doc = "FLASHWAIT specifies the number of flash wait states when MCLK is sourced from HSCLK. FLASHWAIT has no effect when MCLK is sourced from SYSOSC or LFCLK."]
        #[inline(always)]
        pub const fn flashwait(&self) -> super::vals::Flashwait {
            let val = (self.0 >> 8usize) & 0x0f;
            super::vals::Flashwait::from_bits(val as u8)
        }
        #[doc = "FLASHWAIT specifies the number of flash wait states when MCLK is sourced from HSCLK. FLASHWAIT has no effect when MCLK is sourced from SYSOSC or LFCLK."]
        #[inline(always)]
        pub fn set_flashwait(&mut self, val: super::vals::Flashwait) {
            self.0 = (self.0 & !(0x0f << 8usize)) | (((val.to_bits() as u32) & 0x0f) << 8usize);
        }
        #[doc = "USEMFTICK specifies whether the 4MHz constant-rate clock (MFCLK) to peripherals is enabled or disabled. When enabled, MDIV must be disabled (set to 0h=/1)."]
        #[inline(always)]
        pub const fn usemftick(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "USEMFTICK specifies whether the 4MHz constant-rate clock (MFCLK) to peripherals is enabled or disabled. When enabled, MDIV must be disabled (set to 0h=/1)."]
        #[inline(always)]
        pub fn set_usemftick(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "USEHSCLK, together with USELFCLK, sets the MCLK source policy. Set USEHSCLK to use HSCLK (HFCLK or SYSPLL) as the MCLK source in RUN and SLEEP modes."]
        #[inline(always)]
        pub const fn usehsclk(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "USEHSCLK, together with USELFCLK, sets the MCLK source policy. Set USEHSCLK to use HSCLK (HFCLK or SYSPLL) as the MCLK source in RUN and SLEEP modes."]
        #[inline(always)]
        pub fn set_usehsclk(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "USELFCLK sets the MCLK source policy. Set USELFCLK to use LFCLK as the MCLK source. Note that setting USELFCLK does not disable SYSOSC, and SYSOSC remains available for direct use by analog modules."]
        #[inline(always)]
        pub const fn uselfclk(&self) -> bool {
            let val = (self.0 >> 20usize) & 0x01;
            val != 0
        }
        #[doc = "USELFCLK sets the MCLK source policy. Set USELFCLK to use LFCLK as the MCLK source. Note that setting USELFCLK does not disable SYSOSC, and SYSOSC remains available for direct use by analog modules."]
        #[inline(always)]
        pub fn set_uselfclk(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
        }
        #[doc = "STOPCLKSTBY sets the STANDBY mode policy (STANDBY0 or STANDBY1). When set, ULPCLK and LFCLK are disabled to all peripherals in STANDBY mode, with the exception of TIMG0 and TIMG1 which continue to run. Wake-up is only possible via an asynchronous fast clock request."]
        #[inline(always)]
        pub const fn stopclkstby(&self) -> bool {
            let val = (self.0 >> 21usize) & 0x01;
            val != 0
        }
        #[doc = "STOPCLKSTBY sets the STANDBY mode policy (STANDBY0 or STANDBY1). When set, ULPCLK and LFCLK are disabled to all peripherals in STANDBY mode, with the exception of TIMG0 and TIMG1 which continue to run. Wake-up is only possible via an asynchronous fast clock request."]
        #[inline(always)]
        pub fn set_stopclkstby(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
        }
        #[doc = "MCLKDEADCHK enables or disables the continuous MCLK dead check monitor. LFCLK must be running before MCLKDEADCHK is enabled."]
        #[inline(always)]
        pub const fn mclkdeadchk(&self) -> bool {
            let val = (self.0 >> 22usize) & 0x01;
            val != 0
        }
        #[doc = "MCLKDEADCHK enables or disables the continuous MCLK dead check monitor. LFCLK must be running before MCLKDEADCHK is enabled."]
        #[inline(always)]
        pub fn set_mclkdeadchk(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
        }
    }
    impl Default for Mclkcfg {
        #[inline(always)]
        fn default() -> Mclkcfg {
            Mclkcfg(0)
        }
    }
    #[doc = "NMI interrupt clear."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Nmi(pub u32);
    impl Nmi {
        #[doc = "Clr the BORLVL NMI."]
        #[inline(always)]
        pub const fn borlvl(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Clr the BORLVL NMI."]
        #[inline(always)]
        pub fn set_borlvl(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Watch Dog 0 Fault."]
        #[inline(always)]
        pub const fn wwdt0(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Watch Dog 0 Fault."]
        #[inline(always)]
        pub fn set_wwdt0(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "LFXT-EXLF Monitor Fail."]
        #[inline(always)]
        pub const fn lfclkfail(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "LFXT-EXLF Monitor Fail."]
        #[inline(always)]
        pub fn set_lfclkfail(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "Flash Double Error Detect."]
        #[inline(always)]
        pub const fn flashded(&self) -> bool {
            let val = (self.0 >> 3usize) & 0x01;
            val != 0
        }
        #[doc = "Flash Double Error Detect."]
        #[inline(always)]
        pub fn set_flashded(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
        }
        #[doc = "SRAM Double Error Detect."]
        #[inline(always)]
        pub const fn sramded(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "SRAM Double Error Detect."]
        #[inline(always)]
        pub fn set_sramded(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "VBAT Power Off."]
        #[inline(always)]
        pub const fn vbatdn(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "VBAT Power Off."]
        #[inline(always)]
        pub fn set_vbatdn(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "VBAT Power On."]
        #[inline(always)]
        pub const fn vbatup(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "VBAT Power On."]
        #[inline(always)]
        pub fn set_vbatup(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
    }
    impl Default for Nmi {
        #[inline(always)]
        fn default() -> Nmi {
            Nmi(0)
        }
    }
    #[doc = "NMI interrupt index."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Nmiiidx(pub u32);
    impl Nmiiidx {
        #[doc = "The NMI interrupt index (NMIIIDX) register generates a value corresponding to the highest priority pending NMI source. This value may be used as an address offset for fast, deterministic handling in the NMI service routine. A read of the NMIIIDX register will clear the corresponding interrupt status in the NMIRIS register."]
        #[inline(always)]
        pub const fn stat(&self) -> super::vals::NmiiidxStat {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::NmiiidxStat::from_bits(val as u8)
        }
        #[doc = "The NMI interrupt index (NMIIIDX) register generates a value corresponding to the highest priority pending NMI source. This value may be used as an address offset for fast, deterministic handling in the NMI service routine. A read of the NMIIIDX register will clear the corresponding interrupt status in the NMIRIS register."]
        #[inline(always)]
        pub fn set_stat(&mut self, val: super::vals::NmiiidxStat) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
    }
    impl Default for Nmiiidx {
        #[inline(always)]
        fn default() -> Nmiiidx {
            Nmiiidx(0)
        }
    }
    #[doc = "Power mode configuration."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pmodecfg(pub u32);
    impl Pmodecfg {
        #[doc = "DSLEEP selects the operating mode to enter upon a DEEPSLEEP request from the CPU."]
        #[inline(always)]
        pub const fn dsleep(&self) -> super::vals::Dsleep {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::Dsleep::from_bits(val as u8)
        }
        #[doc = "DSLEEP selects the operating mode to enter upon a DEEPSLEEP request from the CPU."]
        #[inline(always)]
        pub fn set_dsleep(&mut self, val: super::vals::Dsleep) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
    }
    impl Default for Pmodecfg {
        #[inline(always)]
        fn default() -> Pmodecfg {
            Pmodecfg(0)
        }
    }
    #[doc = "Execute an application-triggered reset command."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Resetcmd(pub u32);
    impl Resetcmd {
        #[doc = "Execute the reset specified in RESETLEVEL.LEVEL. Must be written together with the KEY."]
        #[inline(always)]
        pub const fn go(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Execute the reset specified in RESETLEVEL.LEVEL. Must be written together with the KEY."]
        #[inline(always)]
        pub fn set_go(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::ResetcmdKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::ResetcmdKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::ResetcmdKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Resetcmd {
        #[inline(always)]
        fn default() -> Resetcmd {
            Resetcmd(0)
        }
    }
    #[doc = "Reset level for application-triggered reset command."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Resetlevel(pub u32);
    impl Resetlevel {
        #[doc = "LEVEL is used to specify the type of reset to be issued when RESETCMD is set to generate a software triggered reset."]
        #[inline(always)]
        pub const fn level(&self) -> super::vals::ResetlevelLevel {
            let val = (self.0 >> 0usize) & 0x07;
            super::vals::ResetlevelLevel::from_bits(val as u8)
        }
        #[doc = "LEVEL is used to specify the type of reset to be issued when RESETCMD is set to generate a software triggered reset."]
        #[inline(always)]
        pub fn set_level(&mut self, val: super::vals::ResetlevelLevel) {
            self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
        }
    }
    impl Default for Resetlevel {
        #[inline(always)]
        fn default() -> Resetlevel {
            Resetlevel(0)
        }
    }
    #[doc = "Reset cause."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rstcause(pub u32);
    impl Rstcause {
        #[doc = "ID is a read-to-clear field which indicates the lowest level reset cause since the last read."]
        #[inline(always)]
        pub const fn id(&self) -> super::vals::Id {
            let val = (self.0 >> 0usize) & 0x1f;
            super::vals::Id::from_bits(val as u8)
        }
        #[doc = "ID is a read-to-clear field which indicates the lowest level reset cause since the last read."]
        #[inline(always)]
        pub fn set_id(&mut self, val: super::vals::Id) {
            self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u32) & 0x1f) << 0usize);
        }
    }
    impl Default for Rstcause {
        #[inline(always)]
        fn default() -> Rstcause {
            Rstcause(0)
        }
    }
    #[doc = "Security Configuration status."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Secstatus(pub u32);
    impl Secstatus {
        #[doc = "1: CSC has been completed."]
        #[inline(always)]
        pub const fn initdone(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "1: CSC has been completed."]
        #[inline(always)]
        pub fn set_initdone(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "1: CSC Exists in the system."]
        #[inline(always)]
        pub const fn cscexists(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "1: CSC Exists in the system."]
        #[inline(always)]
        pub fn set_cscexists(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "1: Flash Read Execute Protection Active."]
        #[inline(always)]
        pub const fn flrxprot(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "1: Flash Read Execute Protection Active."]
        #[inline(always)]
        pub fn set_flrxprot(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "1: Flash IP Protection Active."]
        #[inline(always)]
        pub const fn flipprot(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "1: Flash IP Protection Active."]
        #[inline(always)]
        pub fn set_flipprot(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "1: SRAM Boundary MMR Locked."]
        #[inline(always)]
        pub const fn sramboundarylock(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "1: SRAM Boundary MMR Locked."]
        #[inline(always)]
        pub fn set_sramboundarylock(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "1: Upper and Lower Banks allowed to be swapped."]
        #[inline(always)]
        pub const fn flbankswppolicy(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "1: Upper and Lower Banks allowed to be swapped."]
        #[inline(always)]
        pub fn set_flbankswppolicy(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "1: Upper and Lower Banks have been swapped."]
        #[inline(always)]
        pub const fn flbankswp(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "1: Upper and Lower Banks have been swapped."]
        #[inline(always)]
        pub fn set_flbankswp(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
    }
    impl Default for Secstatus {
        #[inline(always)]
        fn default() -> Secstatus {
            Secstatus(0)
        }
    }
    #[doc = "SHUTDOWN IO release control."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Shdniorel(pub u32);
    impl Shdniorel {
        #[doc = "Set RELEASE to release the IO after a SHUTDOWN mode exit."]
        #[inline(always)]
        pub const fn release(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Set RELEASE to release the IO after a SHUTDOWN mode exit."]
        #[inline(always)]
        pub fn set_release(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::ShdniorelKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::ShdniorelKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::ShdniorelKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Shdniorel {
        #[inline(always)]
        fn default() -> Shdniorel {
            Shdniorel(0)
        }
    }
    #[doc = "Shutdown storage memory (byte 0)."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Shutdnstore(pub u32);
    impl Shutdnstore {
        #[doc = "Shutdown storage byte 0."]
        #[inline(always)]
        pub const fn data(&self) -> u8 {
            let val = (self.0 >> 0usize) & 0xff;
            val as u8
        }
        #[doc = "Shutdown storage byte 0."]
        #[inline(always)]
        pub fn set_data(&mut self, val: u8) {
            self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
        }
        #[inline(always)]
        pub const fn parity(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[inline(always)]
        pub fn set_parity(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[inline(always)]
        pub const fn parityerr(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[inline(always)]
        pub fn set_parityerr(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
    }
    impl Default for Shutdnstore {
        #[inline(always)]
        fn default() -> Shutdnstore {
            Shutdnstore(0)
        }
    }
    #[doc = "SRAM Write Boundary."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sramboundary(pub u32);
    impl Sramboundary {
        #[doc = "SRAM boundary configuration. The value configured into this acts such that: SRAM accesses to addresses less than or equal value will be RW only. SRAM accesses to addresses greater than value will be RX only. Value of 0 is not valid (system will have no stack). If set to 0, the system acts as if the entire SRAM is RWX. Any non-zero value can be configured, including a value = SRAM size."]
        #[inline(always)]
        pub const fn addr(&self) -> u16 {
            let val = (self.0 >> 5usize) & 0x7fff;
            val as u16
        }
        #[doc = "SRAM boundary configuration. The value configured into this acts such that: SRAM accesses to addresses less than or equal value will be RW only. SRAM accesses to addresses greater than value will be RX only. Value of 0 is not valid (system will have no stack). If set to 0, the system acts as if the entire SRAM is RWX. Any non-zero value can be configured, including a value = SRAM size."]
        #[inline(always)]
        pub fn set_addr(&mut self, val: u16) {
            self.0 = (self.0 & !(0x7fff << 5usize)) | (((val as u32) & 0x7fff) << 5usize);
        }
    }
    impl Default for Sramboundary {
        #[inline(always)]
        fn default() -> Sramboundary {
            Sramboundary(0)
        }
    }
    #[doc = "Disable the SWD function on the SWD pins."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Swdcfg(pub u32);
    impl Swdcfg {
        #[doc = "Set DISABLE to disable the SWD function on SWD pins, allowing the SWD pins to be used as GPIO."]
        #[inline(always)]
        pub const fn disable(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Set DISABLE to disable the SWD function on SWD pins, allowing the SWD pins to be used as GPIO."]
        #[inline(always)]
        pub fn set_disable(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::SwdcfgKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::SwdcfgKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::SwdcfgKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Swdcfg {
        #[inline(always)]
        fn default() -> Swdcfg {
            Swdcfg(0)
        }
    }
    #[doc = "SYSOSC configuration."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sysosccfg(pub u32);
    impl Sysosccfg {
        #[doc = "Target operating frequency for the system oscillator (SYSOSC)."]
        #[inline(always)]
        pub const fn freq(&self) -> super::vals::SysosccfgFreq {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::SysosccfgFreq::from_bits(val as u8)
        }
        #[doc = "Target operating frequency for the system oscillator (SYSOSC)."]
        #[inline(always)]
        pub fn set_freq(&mut self, val: super::vals::SysosccfgFreq) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
        #[doc = "USE4MHZSTOP sets the SYSOSC stop mode frequency policy. When entering STOP mode, the SYSOSC frequency may be automatically switched to 4MHz to reduce SYSOSC power consumption."]
        #[inline(always)]
        pub const fn use4mhzstop(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "USE4MHZSTOP sets the SYSOSC stop mode frequency policy. When entering STOP mode, the SYSOSC frequency may be automatically switched to 4MHz to reduce SYSOSC power consumption."]
        #[inline(always)]
        pub fn set_use4mhzstop(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
        #[doc = "DISABLESTOP sets the SYSOSC stop mode enable/disable policy. When operating in STOP mode, the SYSOSC may be automatically disabled. When set, ULPCLK will run from LFCLK in STOP mode and SYSOSC will be disabled to reduce power consumption."]
        #[inline(always)]
        pub const fn disablestop(&self) -> bool {
            let val = (self.0 >> 9usize) & 0x01;
            val != 0
        }
        #[doc = "DISABLESTOP sets the SYSOSC stop mode enable/disable policy. When operating in STOP mode, the SYSOSC may be automatically disabled. When set, ULPCLK will run from LFCLK in STOP mode and SYSOSC will be disabled to reduce power consumption."]
        #[inline(always)]
        pub fn set_disablestop(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
        }
        #[doc = "DISABLE sets the SYSOSC enable/disable policy. SYSOSC may be powered off in RUN, SLEEP, and STOP modes to reduce power consumption. When SYSOSC is disabled, MCLK and ULPCLK are sourced from LFCLK."]
        #[inline(always)]
        pub const fn disable(&self) -> bool {
            let val = (self.0 >> 10usize) & 0x01;
            val != 0
        }
        #[doc = "DISABLE sets the SYSOSC enable/disable policy. SYSOSC may be powered off in RUN, SLEEP, and STOP modes to reduce power consumption. When SYSOSC is disabled, MCLK and ULPCLK are sourced from LFCLK."]
        #[inline(always)]
        pub fn set_disable(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
        }
        #[doc = "BLOCKASYNCALL may be used to mask block all asynchronous fast clock requests, preventing hardware from dynamically changing the active clock configuration when operating in a given mode."]
        #[inline(always)]
        pub const fn blockasyncall(&self) -> bool {
            let val = (self.0 >> 16usize) & 0x01;
            val != 0
        }
        #[doc = "BLOCKASYNCALL may be used to mask block all asynchronous fast clock requests, preventing hardware from dynamically changing the active clock configuration when operating in a given mode."]
        #[inline(always)]
        pub fn set_blockasyncall(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
        }
        #[doc = "FASTCPUEVENT may be used to assert a fast clock request when an interrupt is asserted to the CPU, reducing interrupt latency."]
        #[inline(always)]
        pub const fn fastcpuevent(&self) -> bool {
            let val = (self.0 >> 17usize) & 0x01;
            val != 0
        }
        #[doc = "FASTCPUEVENT may be used to assert a fast clock request when an interrupt is asserted to the CPU, reducing interrupt latency."]
        #[inline(always)]
        pub fn set_fastcpuevent(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
        }
    }
    impl Default for Sysosccfg {
        #[inline(always)]
        fn default() -> Sysosccfg {
            Sysosccfg(0)
        }
    }
    #[doc = "SYSOSC frequency correction loop (FCL) ROSC enable."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sysoscfclctl(pub u32);
    impl Sysoscfclctl {
        #[doc = "Set SETUSEFCL to enable the frequency correction loop in SYSOSC. Once enabled, this state is locked until the next BOOTRST."]
        #[inline(always)]
        pub const fn setusefcl(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Set SETUSEFCL to enable the frequency correction loop in SYSOSC. Once enabled, this state is locked until the next BOOTRST."]
        #[inline(always)]
        pub fn set_setusefcl(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "Set SETUSEEXRES to specify that an external resistor will be used for the FCL. An appropriate resistor must be populated on the ROSC pin. This state is locked until the next BOOTRST."]
        #[inline(always)]
        pub const fn setuseexres(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "Set SETUSEEXRES to specify that an external resistor will be used for the FCL. An appropriate resistor must be populated on the ROSC pin. This state is locked until the next BOOTRST."]
        #[inline(always)]
        pub fn set_setuseexres(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::SysoscfclctlKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::SysoscfclctlKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::SysoscfclctlKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Sysoscfclctl {
        #[inline(always)]
        fn default() -> Sysoscfclctl {
            Sysoscfclctl(0)
        }
    }
    #[doc = "SYSOSC user-specified trim."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sysosctrimuser(pub u32);
    impl Sysosctrimuser {
        #[doc = "FREQ specifies the target user-trimmed frequency for SYSOSC."]
        #[inline(always)]
        pub const fn freq(&self) -> super::vals::SysosctrimuserFreq {
            let val = (self.0 >> 0usize) & 0x03;
            super::vals::SysosctrimuserFreq::from_bits(val as u8)
        }
        #[doc = "FREQ specifies the target user-trimmed frequency for SYSOSC."]
        #[inline(always)]
        pub fn set_freq(&mut self, val: super::vals::SysosctrimuserFreq) {
            self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
        }
        #[doc = "CAP specifies the SYSOSC capacitor trim. This value changes with the target frequency."]
        #[inline(always)]
        pub const fn cap(&self) -> u8 {
            let val = (self.0 >> 4usize) & 0x07;
            val as u8
        }
        #[doc = "CAP specifies the SYSOSC capacitor trim. This value changes with the target frequency."]
        #[inline(always)]
        pub fn set_cap(&mut self, val: u8) {
            self.0 = (self.0 & !(0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize);
        }
        #[doc = "RESCOARSE specifies the resister coarse trim. This value changes with the target frequency."]
        #[inline(always)]
        pub const fn rescoarse(&self) -> u8 {
            let val = (self.0 >> 8usize) & 0x3f;
            val as u8
        }
        #[doc = "RESCOARSE specifies the resister coarse trim. This value changes with the target frequency."]
        #[inline(always)]
        pub fn set_rescoarse(&mut self, val: u8) {
            self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
        }
        #[doc = "RESFINE specifies the resister fine trim. This value changes with the target frequency."]
        #[inline(always)]
        pub const fn resfine(&self) -> u8 {
            let val = (self.0 >> 16usize) & 0x0f;
            val as u8
        }
        #[doc = "RESFINE specifies the resister fine trim. This value changes with the target frequency."]
        #[inline(always)]
        pub fn set_resfine(&mut self, val: u8) {
            self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
        }
        #[doc = "RDIV specifies the frequency correction loop (FCL) resistor trim. This value changes with the target frequency."]
        #[inline(always)]
        pub const fn rdiv(&self) -> u16 {
            let val = (self.0 >> 20usize) & 0x01ff;
            val as u16
        }
        #[doc = "RDIV specifies the frequency correction loop (FCL) resistor trim. This value changes with the target frequency."]
        #[inline(always)]
        pub fn set_rdiv(&mut self, val: u16) {
            self.0 = (self.0 & !(0x01ff << 20usize)) | (((val as u32) & 0x01ff) << 20usize);
        }
    }
    impl Default for Sysosctrimuser {
        #[inline(always)]
        fn default() -> Sysosctrimuser {
            Sysosctrimuser(0)
        }
    }
    #[doc = "System status information."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sysstatus(pub u32);
    impl Sysstatus {
        #[doc = "FLASHDED indicates if a flash ECC double bit error was detected (DED)."]
        #[inline(always)]
        pub const fn flashded(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "FLASHDED indicates if a flash ECC double bit error was detected (DED)."]
        #[inline(always)]
        pub fn set_flashded(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "FLASHSEC indicates if a flash ECC single bit error was detected and corrected (SEC)."]
        #[inline(always)]
        pub const fn flashsec(&self) -> bool {
            let val = (self.0 >> 1usize) & 0x01;
            val != 0
        }
        #[doc = "FLASHSEC indicates if a flash ECC single bit error was detected and corrected (SEC)."]
        #[inline(always)]
        pub fn set_flashsec(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
        }
        #[doc = "BORCURTHRESHOLD indicates the active brown-out reset supply monitor configuration."]
        #[inline(always)]
        pub const fn borcurthreshold(&self) -> super::vals::Borcurthreshold {
            let val = (self.0 >> 2usize) & 0x03;
            super::vals::Borcurthreshold::from_bits(val as u8)
        }
        #[doc = "BORCURTHRESHOLD indicates the active brown-out reset supply monitor configuration."]
        #[inline(always)]
        pub fn set_borcurthreshold(&mut self, val: super::vals::Borcurthreshold) {
            self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
        }
        #[doc = "BORLVL indicates if a BOR event occured and the BOR threshold was switched to BOR0 by hardware."]
        #[inline(always)]
        pub const fn borlvl(&self) -> bool {
            let val = (self.0 >> 4usize) & 0x01;
            val != 0
        }
        #[doc = "BORLVL indicates if a BOR event occured and the BOR threshold was switched to BOR0 by hardware."]
        #[inline(always)]
        pub fn set_borlvl(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
        }
        #[doc = "ANACPUMPGOOD is set by hardware when the VBOOST analog mux charge pump is ready."]
        #[inline(always)]
        pub const fn anacpumpgood(&self) -> bool {
            let val = (self.0 >> 5usize) & 0x01;
            val != 0
        }
        #[doc = "ANACPUMPGOOD is set by hardware when the VBOOST analog mux charge pump is ready."]
        #[inline(always)]
        pub fn set_anacpumpgood(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
        }
        #[doc = "PMUIREFGOOD is set by hardware when the PMU current reference is ready."]
        #[inline(always)]
        pub const fn pmuirefgood(&self) -> bool {
            let val = (self.0 >> 6usize) & 0x01;
            val != 0
        }
        #[doc = "PMUIREFGOOD is set by hardware when the PMU current reference is ready."]
        #[inline(always)]
        pub fn set_pmuirefgood(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
        }
        #[doc = "VBATGOOD is set by hardware when the VBAT Power Domain is valid."]
        #[inline(always)]
        pub const fn vbatgood(&self) -> bool {
            let val = (self.0 >> 7usize) & 0x01;
            val != 0
        }
        #[doc = "VBATGOOD is set by hardware when the VBAT Power Domain is valid."]
        #[inline(always)]
        pub fn set_vbatgood(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
        }
        #[doc = "EXTRSTPINDIS indicates when user has disabled the use of external reset pin."]
        #[inline(always)]
        pub const fn extrstpindis(&self) -> bool {
            let val = (self.0 >> 12usize) & 0x01;
            val != 0
        }
        #[doc = "EXTRSTPINDIS indicates when user has disabled the use of external reset pin."]
        #[inline(always)]
        pub fn set_extrstpindis(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
        }
        #[doc = "SWDCFGDIS indicates when user has disabled the use of SWD Port."]
        #[inline(always)]
        pub const fn swdcfgdis(&self) -> bool {
            let val = (self.0 >> 13usize) & 0x01;
            val != 0
        }
        #[doc = "SWDCFGDIS indicates when user has disabled the use of SWD Port."]
        #[inline(always)]
        pub fn set_swdcfgdis(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
        }
        #[doc = "SHDNIOLOCK indicates when IO is locked due to SHUTDOWN."]
        #[inline(always)]
        pub const fn shdniolock(&self) -> bool {
            let val = (self.0 >> 14usize) & 0x01;
            val != 0
        }
        #[doc = "SHDNIOLOCK indicates when IO is locked due to SHUTDOWN."]
        #[inline(always)]
        pub fn set_shdniolock(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
        }
        #[doc = "REBOOTATTEMPTS indicates the number of boot attempts taken before the user application starts."]
        #[inline(always)]
        pub const fn rebootattempts(&self) -> u8 {
            let val = (self.0 >> 30usize) & 0x03;
            val as u8
        }
        #[doc = "REBOOTATTEMPTS indicates the number of boot attempts taken before the user application starts."]
        #[inline(always)]
        pub fn set_rebootattempts(&mut self, val: u8) {
            self.0 = (self.0 & !(0x03 << 30usize)) | (((val as u32) & 0x03) << 30usize);
        }
    }
    impl Default for Sysstatus {
        #[inline(always)]
        fn default() -> Sysstatus {
            Sysstatus(0)
        }
    }
    #[doc = "Clear sticky bits of SYSSTATUS."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sysstatusclr(pub u32);
    impl Sysstatusclr {
        #[doc = "Set ALLECC to clear all ECC related SYSSTATUS indicators."]
        #[inline(always)]
        pub const fn allecc(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "Set ALLECC to clear all ECC related SYSSTATUS indicators."]
        #[inline(always)]
        pub fn set_allecc(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[inline(always)]
        pub const fn key(&self) -> super::vals::SysstatusclrKey {
            let val = (self.0 >> 24usize) & 0xff;
            super::vals::SysstatusclrKey::from_bits(val as u8)
        }
        #[inline(always)]
        pub fn set_key(&mut self, val: super::vals::SysstatusclrKey) {
            self.0 = (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
        }
    }
    impl Default for Sysstatusclr {
        #[inline(always)]
        fn default() -> Sysstatusclr {
            Sysstatusclr(0)
        }
    }
    #[doc = "System configuration."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Systemcfg(pub u32);
    impl Systemcfg {
        #[doc = "WWDTLP0RSTDIS specifies whether a WWDT Error Event will trigger a BOOTRST or an NMI."]
        #[inline(always)]
        pub const fn wwdtlp0rstdis(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "WWDTLP0RSTDIS specifies whether a WWDT Error Event will trigger a BOOTRST or an NMI."]
        #[inline(always)]
        pub fn set_wwdtlp0rstdis(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
        #[doc = "FLASHECCRSTDIS specifies whether a flash ECC double error detect (DED) will trigger a SYSRST or an NMI."]
        #[inline(always)]
        pub const fn flasheccrstdis(&self) -> bool {
            let val = (self.0 >> 2usize) & 0x01;
            val != 0
        }
        #[doc = "FLASHECCRSTDIS specifies whether a flash ECC double error detect (DED) will trigger a SYSRST or an NMI."]
        #[inline(always)]
        pub fn set_flasheccrstdis(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
        }
        #[doc = "SUPERCAP specifies whether the battery backup system can be powered by a SUPERCAP."]
        #[inline(always)]
        pub const fn supercapen(&self) -> bool {
            let val = (self.0 >> 8usize) & 0x01;
            val != 0
        }
        #[doc = "SUPERCAP specifies whether the battery backup system can be powered by a SUPERCAP."]
        #[inline(always)]
        pub fn set_supercapen(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
        }
    }
    impl Default for Systemcfg {
        #[inline(always)]
        fn default() -> Systemcfg {
            Systemcfg(0)
        }
    }
    #[doc = "SYSCTL register write lockout."]
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Writelock(pub u32);
    impl Writelock {
        #[doc = "ACTIVE controls whether critical SYSCTL registers are write protected or not."]
        #[inline(always)]
        pub const fn active(&self) -> bool {
            let val = (self.0 >> 0usize) & 0x01;
            val != 0
        }
        #[doc = "ACTIVE controls whether critical SYSCTL registers are write protected or not."]
        #[inline(always)]
        pub fn set_active(&mut self, val: bool) {
            self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
        }
    }
    impl Default for Writelock {
        #[inline(always)]
        fn default() -> Writelock {
            Writelock(0)
        }
    }
}
pub mod vals {
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Anacpumpcfg {
        #[doc = "VBOOST is enabled on request from a COMP, GPAMP, or OPA."]
        ONDEMAND = 0x0,
        #[doc = "VBOOST is enabled when the device is in RUN or SLEEP mode, or when a COMP/GPAMP/OPA is enabled."]
        ONACTIVE = 0x01,
        #[doc = "VBOOST is always enabled."]
        ONALWAYS = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl Anacpumpcfg {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Anacpumpcfg {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Anacpumpcfg {
        #[inline(always)]
        fn from(val: u8) -> Anacpumpcfg {
            Anacpumpcfg::from_bits(val)
        }
    }
    impl From<Anacpumpcfg> for u8 {
        #[inline(always)]
        fn from(val: Anacpumpcfg) -> u8 {
            Anacpumpcfg::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct BorclrcmdKey(pub u8);
    impl BorclrcmdKey {
        pub const KEY: Self = Self(0xc7);
    }
    impl BorclrcmdKey {
        pub const fn from_bits(val: u8) -> BorclrcmdKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for BorclrcmdKey {
        #[inline(always)]
        fn from(val: u8) -> BorclrcmdKey {
            BorclrcmdKey::from_bits(val)
        }
    }
    impl From<BorclrcmdKey> for u8 {
        #[inline(always)]
        fn from(val: BorclrcmdKey) -> u8 {
            BorclrcmdKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Borcurthreshold {
        #[doc = "Default minimum threshold; a BOR0- violation triggers a BOR."]
        BORMIN = 0x0,
        #[doc = "A BOR1- violation generates a BORLVL interrupt."]
        BORLEVEL1 = 0x01,
        #[doc = "A BOR2- violation generates a BORLVL interrupt."]
        BORLEVEL2 = 0x02,
        #[doc = "A BOR3- violation generates a BORLVL interrupt."]
        BORLEVEL3 = 0x03,
    }
    impl Borcurthreshold {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Borcurthreshold {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Borcurthreshold {
        #[inline(always)]
        fn from(val: u8) -> Borcurthreshold {
            Borcurthreshold::from_bits(val)
        }
    }
    impl From<Borcurthreshold> for u8 {
        #[inline(always)]
        fn from(val: Borcurthreshold) -> u8 {
            Borcurthreshold::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Curhsclksel {
        #[doc = "HSCLK is currently sourced from the SYSPLL."]
        SYSPLL = 0x0,
        #[doc = "HSCLK is currently sourced from the HFCLK."]
        HFCLK = 0x01,
    }
    impl Curhsclksel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Curhsclksel {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Curhsclksel {
        #[inline(always)]
        fn from(val: u8) -> Curhsclksel {
            Curhsclksel::from_bits(val)
        }
    }
    impl From<Curhsclksel> for u8 {
        #[inline(always)]
        fn from(val: Curhsclksel) -> u8 {
            Curhsclksel::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Dsleep {
        #[doc = "STOP mode is entered."]
        STOP = 0x0,
        #[doc = "STANDBY mode is entered."]
        STANDBY = 0x01,
        #[doc = "SHUTDOWN mode is entered."]
        SHUTDOWN = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl Dsleep {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Dsleep {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Dsleep {
        #[inline(always)]
        fn from(val: u8) -> Dsleep {
            Dsleep::from_bits(val)
        }
    }
    impl From<Dsleep> for u8 {
        #[inline(always)]
        fn from(val: Dsleep) -> u8 {
            Dsleep::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Exclkdivval {
        #[doc = "CLK_OUT source is divided by 2."]
        DIV2 = 0x0,
        #[doc = "CLK_OUT source is divided by 4."]
        DIV4 = 0x01,
        #[doc = "CLK_OUT source is divided by 6."]
        DIV6 = 0x02,
        #[doc = "CLK_OUT source is divided by 8."]
        DIV8 = 0x03,
        #[doc = "CLK_OUT source is divided by 10."]
        DIV10 = 0x04,
        #[doc = "CLK_OUT source is divided by 12."]
        DIV12 = 0x05,
        #[doc = "CLK_OUT source is divided by 14."]
        DIV14 = 0x06,
        #[doc = "CLK_OUT source is divided by 16."]
        DIV16 = 0x07,
    }
    impl Exclkdivval {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Exclkdivval {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Exclkdivval {
        #[inline(always)]
        fn from(val: u8) -> Exclkdivval {
            Exclkdivval::from_bits(val)
        }
    }
    impl From<Exclkdivval> for u8 {
        #[inline(always)]
        fn from(val: Exclkdivval) -> u8 {
            Exclkdivval::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Exclksrc {
        #[doc = "CLK_OUT is SYSOSC."]
        SYSOSC = 0x0,
        #[doc = "CLK_OUT is ULPCLK (EXCLKDIVEN must be enabled)."]
        ULPCLK = 0x01,
        #[doc = "CLK_OUT is LFCLK."]
        LFCLK = 0x02,
        #[doc = "CLK_OUT is MFPCLK (EXCLKDIVEN must be enabled)."]
        MFPCLK = 0x03,
        #[doc = "CLK_OUT is HFCLK."]
        HFCLK = 0x04,
        _RESERVED_5 = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl Exclksrc {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Exclksrc {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Exclksrc {
        #[inline(always)]
        fn from(val: u8) -> Exclksrc {
            Exclksrc::from_bits(val)
        }
    }
    impl From<Exclksrc> for u8 {
        #[inline(always)]
        fn from(val: Exclksrc) -> u8 {
            Exclksrc::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct ExrstpinKey(pub u8);
    impl ExrstpinKey {
        pub const KEY: Self = Self(0x1e);
    }
    impl ExrstpinKey {
        pub const fn from_bits(val: u8) -> ExrstpinKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for ExrstpinKey {
        #[inline(always)]
        fn from(val: u8) -> ExrstpinKey {
            ExrstpinKey::from_bits(val)
        }
    }
    impl From<ExrstpinKey> for u8 {
        #[inline(always)]
        fn from(val: ExrstpinKey) -> u8 {
            ExrstpinKey::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct FcccmdKey(pub u8);
    impl FcccmdKey {
        pub const KEY: Self = Self(0x0e);
    }
    impl FcccmdKey {
        pub const fn from_bits(val: u8) -> FcccmdKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for FcccmdKey {
        #[inline(always)]
        fn from(val: u8) -> FcccmdKey {
            FcccmdKey::from_bits(val)
        }
    }
    impl From<FcccmdKey> for u8 {
        #[inline(always)]
        fn from(val: FcccmdKey) -> u8 {
            FcccmdKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Fcclvltrig {
        #[doc = "Rising edge to rising edge triggered."]
        RISE2RISE = 0x0,
        #[doc = "Level triggered."]
        LEVEL = 0x01,
    }
    impl Fcclvltrig {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Fcclvltrig {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Fcclvltrig {
        #[inline(always)]
        fn from(val: u8) -> Fcclvltrig {
            Fcclvltrig::from_bits(val)
        }
    }
    impl From<Fcclvltrig> for u8 {
        #[inline(always)]
        fn from(val: Fcclvltrig) -> u8 {
            Fcclvltrig::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Fccselclk {
        #[doc = "FCC clock is MCLK."]
        MCLK = 0x0,
        #[doc = "FCC clock is SYSOSC."]
        SYSOSC = 0x01,
        #[doc = "FCC clock is HFCLK."]
        HFCLK = 0x02,
        #[doc = "FCC clock is the CLK_OUT selection."]
        EXTCLK = 0x03,
        _RESERVED_4 = 0x04,
        _RESERVED_5 = 0x05,
        _RESERVED_6 = 0x06,
        #[doc = "FCC clock is the FCCIN external input."]
        FCCIN = 0x07,
        _RESERVED_8 = 0x08,
        _RESERVED_9 = 0x09,
        _RESERVED_a = 0x0a,
        _RESERVED_b = 0x0b,
        _RESERVED_c = 0x0c,
        _RESERVED_d = 0x0d,
        _RESERVED_e = 0x0e,
        _RESERVED_f = 0x0f,
    }
    impl Fccselclk {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Fccselclk {
            unsafe { core::mem::transmute(val & 0x0f) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Fccselclk {
        #[inline(always)]
        fn from(val: u8) -> Fccselclk {
            Fccselclk::from_bits(val)
        }
    }
    impl From<Fccselclk> for u8 {
        #[inline(always)]
        fn from(val: Fccselclk) -> u8 {
            Fccselclk::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Fcctrigsrc {
        #[doc = "FCC trigger is the external pin."]
        EXTPIN = 0x0,
        #[doc = "FCC trigger is the LFCLK."]
        LFCLK = 0x01,
    }
    impl Fcctrigsrc {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Fcctrigsrc {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Fcctrigsrc {
        #[inline(always)]
        fn from(val: u8) -> Fcctrigsrc {
            Fcctrigsrc::from_bits(val)
        }
    }
    impl From<Fcctrigsrc> for u8 {
        #[inline(always)]
        fn from(val: Fcctrigsrc) -> u8 {
            Fcctrigsrc::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Flashwait {
        #[doc = "No flash wait states are applied."]
        WAIT0 = 0x0,
        #[doc = "One flash wait state is applied."]
        WAIT1 = 0x01,
        #[doc = "2 flash wait states are applied."]
        WAIT2 = 0x02,
        _RESERVED_3 = 0x03,
        _RESERVED_4 = 0x04,
        _RESERVED_5 = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
        _RESERVED_8 = 0x08,
        _RESERVED_9 = 0x09,
        _RESERVED_a = 0x0a,
        _RESERVED_b = 0x0b,
        _RESERVED_c = 0x0c,
        _RESERVED_d = 0x0d,
        _RESERVED_e = 0x0e,
        _RESERVED_f = 0x0f,
    }
    impl Flashwait {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Flashwait {
            unsafe { core::mem::transmute(val & 0x0f) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Flashwait {
        #[inline(always)]
        fn from(val: u8) -> Flashwait {
            Flashwait::from_bits(val)
        }
    }
    impl From<Flashwait> for u8 {
        #[inline(always)]
        fn from(val: Flashwait) -> u8 {
            Flashwait::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Hfclk4mfpclkdiv {
        #[doc = "HFCLK is not divided before being used for MFPCLK."]
        DIV1 = 0x0,
        #[doc = "HFCLK is divided by 2 before being used for MFPCLK."]
        DIV2 = 0x01,
        #[doc = "HFCLK is divided by 3 before being used for MFPCLK."]
        DIV3 = 0x02,
        #[doc = "HFCLK is divided by 4 before being used for MFPCLK."]
        DIV4 = 0x03,
        #[doc = "HFCLK is divided by 5 before being used for MFPCLK."]
        DIV5 = 0x04,
        #[doc = "HFCLK is divided by 6 before being used for MFPCLK."]
        DIV6 = 0x05,
        #[doc = "HFCLK is divided by 7 before being used for MFPCLK."]
        DIV7 = 0x06,
        #[doc = "HFCLK is divided by 8 before being used for MFPCLK."]
        DIV8 = 0x07,
        #[doc = "HFCLK is divided by 9 before being used for MFPCLK."]
        DIV9 = 0x08,
        #[doc = "HFCLK is divided by 10 before being used for MFPCLK."]
        DIV10 = 0x09,
        #[doc = "HFCLK is divided by 11 before being used for MFPCLK."]
        DIV11 = 0x0a,
        #[doc = "HFCLK is divided by 12 before being used for MFPCLK."]
        DIV12 = 0x0b,
        #[doc = "HFCLK is divided by 13 before being used for MFPCLK."]
        DIV13 = 0x0c,
        #[doc = "HFCLK is divided by 14 before being used for MFPCLK."]
        DIV14 = 0x0d,
        #[doc = "HFCLK is divided by 15 before being used for MFPCLK."]
        DIV15 = 0x0e,
        #[doc = "HFCLK is divided by 16 before being used for MFPCLK."]
        DIV16 = 0x0f,
    }
    impl Hfclk4mfpclkdiv {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hfclk4mfpclkdiv {
            unsafe { core::mem::transmute(val & 0x0f) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hfclk4mfpclkdiv {
        #[inline(always)]
        fn from(val: u8) -> Hfclk4mfpclkdiv {
            Hfclk4mfpclkdiv::from_bits(val)
        }
    }
    impl From<Hfclk4mfpclkdiv> for u8 {
        #[inline(always)]
        fn from(val: Hfclk4mfpclkdiv) -> u8 {
            Hfclk4mfpclkdiv::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Hfxtrsel {
        #[doc = "4MHz &lt;= HFXT frequency &lt;= 8MHz."]
        RANGE4TO8 = 0x0,
        #[doc = "8MHz &lt; HFXT frequency &lt;= 16MHz."]
        RANGE8TO16 = 0x01,
        #[doc = "16MHz &lt; HFXT frequency &lt;= 32MHz."]
        RANGE16TO32 = 0x02,
        #[doc = "32MHz &lt; HFXT frequency &lt;= 48MHz."]
        RANGE32TO48 = 0x03,
    }
    impl Hfxtrsel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hfxtrsel {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hfxtrsel {
        #[inline(always)]
        fn from(val: u8) -> Hfxtrsel {
            Hfxtrsel::from_bits(val)
        }
    }
    impl From<Hfxtrsel> for u8 {
        #[inline(always)]
        fn from(val: Hfxtrsel) -> u8 {
            Hfxtrsel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct Hfxttime(pub u8);
    impl Hfxttime {
        #[doc = "Minimum startup time (approximatly zero)."]
        pub const MINSTARTTIME: Self = Self(0x0);
        #[doc = "Maximum startup time (approximatly 16.32ms)."]
        pub const MAXSTARTTIME: Self = Self(0xff);
    }
    impl Hfxttime {
        pub const fn from_bits(val: u8) -> Hfxttime {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for Hfxttime {
        #[inline(always)]
        fn from(val: u8) -> Hfxttime {
            Hfxttime::from_bits(val)
        }
    }
    impl From<Hfxttime> for u8 {
        #[inline(always)]
        fn from(val: Hfxttime) -> u8 {
            Hfxttime::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Hsclkmux {
        #[doc = "MCLK is not sourced from HSCLK."]
        SYSOSC = 0x0,
        #[doc = "MCLK is sourced from HSCLK."]
        HSCLK = 0x01,
    }
    impl Hsclkmux {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Hsclkmux {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Hsclkmux {
        #[inline(always)]
        fn from(val: u8) -> Hsclkmux {
            Hsclkmux::from_bits(val)
        }
    }
    impl From<Hsclkmux> for u8 {
        #[inline(always)]
        fn from(val: Hsclkmux) -> u8 {
            Hsclkmux::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Id {
        #[doc = "No reset since last read."]
        NORST = 0x0,
        #[doc = "POR- violation, SHUTDNSTOREx or PMU trim parity fault."]
        PORHWFAIL = 0x01,
        #[doc = "NRST triggered POR (&gt;1s hold)."]
        POREXNRST = 0x02,
        #[doc = "Software triggered POR."]
        PORSW = 0x03,
        #[doc = "BOR0- violation."]
        BORSUPPLY = 0x04,
        #[doc = "SHUTDOWN mode exit."]
        BORWAKESHUTDN = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
        #[doc = "Non-PMU trim parity fault."]
        BOOTNONPMUPARITY = 0x08,
        #[doc = "Fatal clock failure."]
        BOOTCLKFAIL = 0x09,
        _RESERVED_a = 0x0a,
        _RESERVED_b = 0x0b,
        #[doc = "NRST triggered BOOTRST (&lt;1s hold)."]
        BOOTEXNRST = 0x0c,
        #[doc = "Software triggered BOOTRST."]
        BOOTSW = 0x0d,
        #[doc = "WWDT0 violation."]
        SYSWWDT0 = 0x0e,
        _RESERVED_f = 0x0f,
        #[doc = "BSL exit."]
        SYSBSLEXIT = 0x10,
        #[doc = "BSL entry."]
        SYSBSLENTRY = 0x11,
        _RESERVED_12 = 0x12,
        #[doc = "WWDT1 violation."]
        SYSWWDT1 = 0x13,
        #[doc = "Flash uncorrectable ECC error."]
        SYSFLASHECC = 0x14,
        #[doc = "CPULOCK violation."]
        SYSCPULOCK = 0x15,
        _RESERVED_16 = 0x16,
        _RESERVED_17 = 0x17,
        _RESERVED_18 = 0x18,
        _RESERVED_19 = 0x19,
        #[doc = "Debug triggered SYSRST."]
        SYSDBG = 0x1a,
        #[doc = "Software triggered SYSRST."]
        SYSSW = 0x1b,
        #[doc = "Debug triggered CPURST."]
        CPUDBG = 0x1c,
        #[doc = "Software triggered CPURST."]
        CPUSW = 0x1d,
        _RESERVED_1e = 0x1e,
        _RESERVED_1f = 0x1f,
    }
    impl Id {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Id {
            unsafe { core::mem::transmute(val & 0x1f) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Id {
        #[inline(always)]
        fn from(val: u8) -> Id {
            Id::from_bits(val)
        }
    }
    impl From<Id> for u8 {
        #[inline(always)]
        fn from(val: Id) -> u8 {
            Id::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum IidxStat {
        #[doc = "No interrupt pending."]
        NO_INTR = 0x0,
        #[doc = "LFOSCGOOD interrupt pending."]
        LFOSCGOOD = 0x01,
        ANACLKERR = 0x02,
        FLASHSEC = 0x03,
        SRAMSEC = 0x04,
        LFXTGOOD = 0x05,
        HFCLKGOOD = 0x06,
        HSCLKGOOD = 0x07,
    }
    impl IidxStat {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> IidxStat {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for IidxStat {
        #[inline(always)]
        fn from(val: u8) -> IidxStat {
            IidxStat::from_bits(val)
        }
    }
    impl From<IidxStat> for u8 {
        #[inline(always)]
        fn from(val: IidxStat) -> u8 {
            IidxStat::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Lfclkmux {
        #[doc = "LFCLK is sourced from the internal LFOSC."]
        LFOSC = 0x0,
        #[doc = "LFCLK is sourced from the LFXT (crystal)."]
        LFXT = 0x01,
        #[doc = "LFCLK is sourced from LFCLK_IN (external digital clock input)."]
        EXLF = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl Lfclkmux {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Lfclkmux {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Lfclkmux {
        #[inline(always)]
        fn from(val: u8) -> Lfclkmux {
            Lfclkmux::from_bits(val)
        }
    }
    impl From<Lfclkmux> for u8 {
        #[inline(always)]
        fn from(val: Lfclkmux) -> u8 {
            Lfclkmux::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Mfpclksrc {
        #[doc = "MFPCLK is sourced from SYSOSC."]
        SYSOSC = 0x0,
        #[doc = "MFPCLK is sourced from HFCLK."]
        HFCLK = 0x01,
    }
    impl Mfpclksrc {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Mfpclksrc {
            unsafe { core::mem::transmute(val & 0x01) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Mfpclksrc {
        #[inline(always)]
        fn from(val: u8) -> Mfpclksrc {
            Mfpclksrc::from_bits(val)
        }
    }
    impl From<Mfpclksrc> for u8 {
        #[inline(always)]
        fn from(val: Mfpclksrc) -> u8 {
            Mfpclksrc::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum NmiiidxStat {
        #[doc = "No NMI pending."]
        NO_INTR = 0x0,
        #[doc = "BOR Threshold NMI pending."]
        BORLVL = 0x01,
        WWDT0 = 0x02,
        LFCLKFAIL = 0x03,
        FLASHDED = 0x04,
        SRAMDED = 0x05,
        VBATDN = 0x06,
        VBATUP = 0x07,
    }
    impl NmiiidxStat {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> NmiiidxStat {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for NmiiidxStat {
        #[inline(always)]
        fn from(val: u8) -> NmiiidxStat {
            NmiiidxStat::from_bits(val)
        }
    }
    impl From<NmiiidxStat> for u8 {
        #[inline(always)]
        fn from(val: NmiiidxStat) -> u8 {
            NmiiidxStat::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct ResetcmdKey(pub u8);
    impl ResetcmdKey {
        pub const KEY: Self = Self(0xe4);
    }
    impl ResetcmdKey {
        pub const fn from_bits(val: u8) -> ResetcmdKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for ResetcmdKey {
        #[inline(always)]
        fn from(val: u8) -> ResetcmdKey {
            ResetcmdKey::from_bits(val)
        }
    }
    impl From<ResetcmdKey> for u8 {
        #[inline(always)]
        fn from(val: ResetcmdKey) -> u8 {
            ResetcmdKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum ResetlevelLevel {
        #[doc = "Issue a SYSRST (CPU plus peripherals only)."]
        CPU = 0x0,
        #[doc = "Issue a BOOTRST (CPU, peripherals, and boot configuration routine)."]
        BOOT = 0x01,
        #[doc = "Issue a SYSRST and enter the boot strap loader (BSL)."]
        BOOTLOADERENTRY = 0x02,
        #[doc = "Issue a power-on reset (POR)."]
        POR = 0x03,
        #[doc = "Issue a SYSRST and exit the boot strap loader (BSL)."]
        BOOTLOADEREXIT = 0x04,
        _RESERVED_5 = 0x05,
        _RESERVED_6 = 0x06,
        _RESERVED_7 = 0x07,
    }
    impl ResetlevelLevel {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> ResetlevelLevel {
            unsafe { core::mem::transmute(val & 0x07) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for ResetlevelLevel {
        #[inline(always)]
        fn from(val: u8) -> ResetlevelLevel {
            ResetlevelLevel::from_bits(val)
        }
    }
    impl From<ResetlevelLevel> for u8 {
        #[inline(always)]
        fn from(val: ResetlevelLevel) -> u8 {
            ResetlevelLevel::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct ShdniorelKey(pub u8);
    impl ShdniorelKey {
        pub const KEY: Self = Self(0x91);
    }
    impl ShdniorelKey {
        pub const fn from_bits(val: u8) -> ShdniorelKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for ShdniorelKey {
        #[inline(always)]
        fn from(val: u8) -> ShdniorelKey {
            ShdniorelKey::from_bits(val)
        }
    }
    impl From<ShdniorelKey> for u8 {
        #[inline(always)]
        fn from(val: ShdniorelKey) -> u8 {
            ShdniorelKey::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct SwdcfgKey(pub u8);
    impl SwdcfgKey {
        pub const KEY: Self = Self(0x62);
    }
    impl SwdcfgKey {
        pub const fn from_bits(val: u8) -> SwdcfgKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for SwdcfgKey {
        #[inline(always)]
        fn from(val: u8) -> SwdcfgKey {
            SwdcfgKey::from_bits(val)
        }
    }
    impl From<SwdcfgKey> for u8 {
        #[inline(always)]
        fn from(val: SwdcfgKey) -> u8 {
            SwdcfgKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum SysosccfgFreq {
        #[doc = "Base frequency (32MHz)."]
        SYSOSCBASE = 0x0,
        #[doc = "Low frequency (4MHz)."]
        SYSOSC4M = 0x01,
        #[doc = "User-trimmed frequency (16 or 24 MHz)."]
        SYSOSCUSER = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl SysosccfgFreq {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> SysosccfgFreq {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for SysosccfgFreq {
        #[inline(always)]
        fn from(val: u8) -> SysosccfgFreq {
            SysosccfgFreq::from_bits(val)
        }
    }
    impl From<SysosccfgFreq> for u8 {
        #[inline(always)]
        fn from(val: SysosccfgFreq) -> u8 {
            SysosccfgFreq::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct SysoscfclctlKey(pub u8);
    impl SysoscfclctlKey {
        pub const KEY: Self = Self(0x2a);
    }
    impl SysoscfclctlKey {
        pub const fn from_bits(val: u8) -> SysoscfclctlKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for SysoscfclctlKey {
        #[inline(always)]
        fn from(val: u8) -> SysoscfclctlKey {
            SysoscfclctlKey::from_bits(val)
        }
    }
    impl From<SysoscfclctlKey> for u8 {
        #[inline(always)]
        fn from(val: SysoscfclctlKey) -> u8 {
            SysoscfclctlKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Sysoscfreq {
        #[doc = "SYSOSC is at base frequency (32MHz)."]
        SYSOSC32M = 0x0,
        #[doc = "SYSOSC is at low frequency (4MHz)."]
        SYSOSC4M = 0x01,
        #[doc = "SYSOSC is at the user-trimmed frequency (16 or 24MHz)."]
        SYSOSCUSER = 0x02,
        #[doc = "Reserved."]
        SYSOSCTURBO = 0x03,
    }
    impl Sysoscfreq {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Sysoscfreq {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Sysoscfreq {
        #[inline(always)]
        fn from(val: u8) -> Sysoscfreq {
            Sysoscfreq::from_bits(val)
        }
    }
    impl From<Sysoscfreq> for u8 {
        #[inline(always)]
        fn from(val: Sysoscfreq) -> u8 {
            Sysoscfreq::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum SysosctrimuserFreq {
        _RESERVED_0 = 0x0,
        #[doc = "16MHz user frequency."]
        SYSOSC16M = 0x01,
        #[doc = "24MHz user frequency."]
        SYSOSC24M = 0x02,
        _RESERVED_3 = 0x03,
    }
    impl SysosctrimuserFreq {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> SysosctrimuserFreq {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for SysosctrimuserFreq {
        #[inline(always)]
        fn from(val: u8) -> SysosctrimuserFreq {
            SysosctrimuserFreq::from_bits(val)
        }
    }
    impl From<SysosctrimuserFreq> for u8 {
        #[inline(always)]
        fn from(val: SysosctrimuserFreq) -> u8 {
            SysosctrimuserFreq::to_bits(val)
        }
    }
    #[repr(transparent)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub struct SysstatusclrKey(pub u8);
    impl SysstatusclrKey {
        pub const KEY: Self = Self(0xce);
    }
    impl SysstatusclrKey {
        pub const fn from_bits(val: u8) -> SysstatusclrKey {
            Self(val & 0xff)
        }
        pub const fn to_bits(self) -> u8 {
            self.0
        }
    }
    impl From<u8> for SysstatusclrKey {
        #[inline(always)]
        fn from(val: u8) -> SysstatusclrKey {
            SysstatusclrKey::from_bits(val)
        }
    }
    impl From<SysstatusclrKey> for u8 {
        #[inline(always)]
        fn from(val: SysstatusclrKey) -> u8 {
            SysstatusclrKey::to_bits(val)
        }
    }
    #[repr(u8)]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
    pub enum Xt1drive {
        #[doc = "Lowest drive and current."]
        LOWESTDRV = 0x0,
        #[doc = "Lower drive and current."]
        LOWERDRV = 0x01,
        #[doc = "Higher drive and current."]
        HIGHERDRV = 0x02,
        #[doc = "Highest drive and current."]
        HIGHESTDRV = 0x03,
    }
    impl Xt1drive {
        #[inline(always)]
        pub const fn from_bits(val: u8) -> Xt1drive {
            unsafe { core::mem::transmute(val & 0x03) }
        }
        #[inline(always)]
        pub const fn to_bits(self) -> u8 {
            unsafe { core::mem::transmute(self) }
        }
    }
    impl From<u8> for Xt1drive {
        #[inline(always)]
        fn from(val: u8) -> Xt1drive {
            Xt1drive::from_bits(val)
        }
    }
    impl From<Xt1drive> for u8 {
        #[inline(always)]
        fn from(val: Xt1drive) -> u8 {
            Xt1drive::to_bits(val)
        }
    }
}
